<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=yes,minimal-ui">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <title>Notas para el curso Geometría Computacional</title>

  <!-- configuración del libro -->
  <script>
    window.book_config = {
      // parámetro que indica si los capítulos, secciones y figura se auto numeran
      // para que los capítulos se auto numeren deben utilizar la etiqueta <h1>
      // para que las secciones se auto numeren deben utilizar la etiqueta <h2>
      auto_numerate_sections_and_figures: true,
      remember_last_page: true,
    }
  </script>

  <!-- núcleo del libro interactivo -->
  <link rel="stylesheet" href="book/css/style.css" type="text/css">
  <script type="text/javascript" src="book/js/book.js" charset="utf-8"></script>

  <!-- personalización del usuario -->
  <link rel="stylesheet" href="extra/fonts.css" type="text/css">
  <link rel="stylesheet" href="extra/style.css" type="text/css">

  <!-- Bibliotecas para interactivos p5js -->
  <script src="libraries/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>

  <!-- inclusión de la biblioteca KaTex -->
  <link rel="stylesheet" type="text/css" href="extra/katex/katex.min.css" />
  <script src="extra/katex/katex.min.js"></script>
  <script src="extra/katex/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }, { left: "\\[", right: "\\]", display: true }, { left: "\\(", right: "\\)", display: false }]
      });
    });
  </script>
</head>

<body>
  <div id="book_loader_container">
    <div id="book_loader"></div>
  </div>

  <div id="book_container">
    <div id="btn_back_page"></div>
    <div id="btn_next_page"></div>
    <button id="go_to_table_of_content"></button>

    <button id="btn_config"></button>
    <div id="config_options">
      <div id="dark_light_mode"></div>
    </div>

    <!-- si este elemento no esta presente, el botón de la tabla de contenido lleva a la primera página con un elemento class="toc_link" -->
    <div id="table_of_content"></div>

    <div id="pages_container">
      <!--  -->
      <div class="page" style="background-color:transparent;"></div>

      <!-- Portada -->
      <div class="page invertcolor"
        style="margin:0; padding:0; background-size:contain; background-image:url(images/general/portada.svg);">
        <div class="cover_title">Notas para el curso</div>
        <div class="cover_subtitle">Geometría Computacional</div>
      </div>

      <!--  -->
      <div class="page" style="display:flex; align-items:center; justify-content:center;">VACÍA</div>

      <!--  -->
      <!-- init-page-num="true" es un parámetro que indica que a partir de esta página comienza la numeración -->
      <!-- inicialmente los números de las páginas se numeran con numerales romanos -->
      <!-- num="" es un parámetro que indica que esta página no lleva numeración visible -->
      <!--  -->
      <div class="page" init-page-num="true" style="text-align:right; font-size:120%;" num="">
        <br>
        <p><b style="font-size:150%;">Notas para el curso Geometría Computacional</b></p>

        <br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <p style="text-align:right; margin:0;">
          <br>
          <b>Edgar Samuel Perea Domínguez</b>
          <br><br>
          Universidad Nacional Autónoma de México
        </p>

      </div>

      <!--  -->
      <div class="page" num="">
        <p>
          Título de la obra:
          <br>
          Notas para el curso Geometría Computacional
        </p>
        <br>

        <p>
          Autores:
          <br>
          Edgar Samuel Perea Domínguez
        </p>
        <br><br>

        <p>
          Código JavaScript para el libro: <a target="_blank" href="https://github.com/jlongi/libro_interactivo"
            target="_blank">Joel
            Espinosa Longi</a>, <a target="_blank" href="https://www.matem.unam.mx/" target="_blank">IMATE</a>, UNAM.
          <br>
          Recursos interactivos: <a target="_blank" href="http://descartes.matem.unam.mx/"
            target="_blank">DescartesJS</a>
          <br>
          Fuentes: <a target="_blank" href="https://fonts.google.com/specimen/Lato" target="_blank">Lato</a> y <a
            href="https://fonts.google.com/specimen/Ubuntu+Mono" target="_blank">UbuntuMono</a>
        </p>
        <br>

        <p>
          DATOS DE LA EDICIÓN
        </p>
        <br><br>

        <p>
        <p>LICENCIA</p>
        <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank"><img
            src="images/general/by-nc-sa.svg" style="height:1.75em; margin-right:0.75em;"></a>
        <p>El contendido de esta obra esta bajo una licencia <a
            href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank">Creative Commons
            (Atribución-NoComercial-CompartirIgual)</a>.</p>
        </p>
      </div>

      <!-- Indice -->
      <div class="page">
        <h2>Tabla de contenido</h2>

        <!-- con esto se agrega una entrada en la tabla de contenido,
        href="#prefacio" indica una referencia a una elemento html con 
        el parámetro id="prefacio", automáticamente se busca está referencia
        y se agrega el título correspondiente y la página donde se encuentra -->

        <div class="toc_link" href="#prefacio"></div>

        <!-- Capitulo 1 -->
        <div class="toc_link" href="#introduccion"></div>
        <div class="toc_link" href="#cap1_definiciones_generales"></div>
        <div class="toc_link" href="#cap1_repaso_estructuras_datos"></div>
        <div class="toc_link" href="#cap1_preliminares_geometricos"></div>

        <!-- Capitulo 2 -->
        <div class="toc_link" href="#cierre_convexo"></div>
        <div class="toc_link" href="#cap2_cota_minima"></div>
        <div class="toc_link" href="#cap2_algorithmo_grahan"></div>
        <div class="toc_link" href="#cap2_algoritmo_jarvis"></div>
        <div class="toc_link" href="#cap2_algoritmos_divide_venceras"></div>
        <div class="toc_link" href="#cap2_algoritmos_dinamicos"></div>
        <div class="toc_link" href="#cap2_extensiones_variantes"></div>

        <!-- Capitulo 3 -->
        <div class="toc_link" href="#intersecciones_segmentos"></div>
        <div class="toc_link" href="#cap3_deteccion"></div>
        <div class="toc_link" href="#cap3_algoritmos"></div>
        <div class="toc_link" href="#cap3_lista_doblemente_ligada"></div>
        <div class="toc_link" href="#cap3_calculando_traslape"></div>
        <div class="toc_link" href="#cap3_barrido_topologico"></div>
        <div class="toc_link" href="#cap3_ordenando_pendientes"></div>

        <!-- Capitulo 4 -->
        <div class="toc_link" href="#triangulacion_divisibilidad"></div>
        <div class="toc_link" href="#cap4_vigilancia_triangulaciones"></div>
        <div class="toc_link" href="#cap4_dividiendo_polígono"></div>
        <div class="toc_link" href="#cap4_triangulando_polígono"></div>
        <div class="toc_link" href="#cap4_calcular_grafica_divisibilidad"></div>

      </div>

      <div class="page">
        <!-- Capitulo 5 -->
        <div class="toc_link" href="#programacion_lineal"></div>
        <div class="toc_link" href="#cap5_geometria_amoldado"></div>
        <div class="toc_link" href="#cap5_interseccion_semiplanos"></div>
        <div class="toc_link" href="#cap5_circulo_contenedor"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_incremental"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_aleatoria"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_dimensiones"></div>

        <!-- Capitulo 6 -->
        <div class="toc_link" href="#busqueda_rangos"></div>
        <div class="toc_link" href="#cap6_busqueda_una_dimension"></div>
        <div class="toc_link" href="#cap6_arboles_kd"></div>
        <div class="toc_link" href="#cap6_arboles_rangos"></div>

        <!-- Capitulo 7 -->
        <div class="toc_link" href="#localizacion_puntos"></div>
        <div class="toc_link" href="#cap7_localizacion_punto_subdivision"></div>
        <div class="toc_link" href="#cap7_metodo_bandas"></div>
        <div class="toc_link" href="#cap7_metodo_cadena"></div>
        <div class="toc_link" href="#cap7_metodo_trapezoidal"></div>
        <div class="toc_link" href="#cap7_algoritmo_incremental"></div>

        <!-- Capitulo 8 -->
        <div class="toc_link" href="#diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_definicion_propiedades"></div>
        <div class="toc_link" href="#cap8_construyendo_diagrama"></div>
        <div class="toc_link" href="#cap8_cota_minima"></div>
        <div class="toc_link" href="#cap8_diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_aplicaciones"></div>
      </div>

      <div class="page">
        <!-- Capitulo 9 -->
        <div class="toc_link" href="#arreglos_lineas_dualidad"></div>
        <div class="toc_link" href="#cap9_arreglos"></div>
        <div class="toc_link" href="#cap9_dualidad"></div>
        <div class="toc_link" href="#cap9_triangulacion_delaunay"></div>

        <!-- Capitulo 10 -->
        <div class="toc_link" href="#proximidad"></div>
        <div class="toc_link" href="#cap10_puntos_cercanos_lejanos"></div>
        <div class="toc_link" href="#cap10_arboles_generadores_minimos"></div>
        <div class="toc_link" href="#cap10_agente_viagero"></div>

        <!-- Capitulo 11 -->
        <div class="toc_link" href="#estructuras_datos_geometricas"></div>
        <div class="toc_link" href="#cap11_arboles_intervalos"></div>
        <div class="toc_link" href="#cap11_arboles_prioridades_busqueda"></div>
        <div class="toc_link" href="#cap11_arboles_segmentos"></div>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- num-type-arabic="true" es un parámetro que indica que a partir de esta página la numeración utilizara numerales arábigos -->
      <!--  -->
      <div class="page" num-type-arabic="true">
        <h1 id="prefacio">Prefacio</h1>

        <p>
          Este es un ejemplo sin contenido para
          comenzar la creación de un libro interactivo.
        </p>
      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="introduccion">Introducción</h1>
          <h1 class="chap_num">1</h1>
        </div>
        <p>
          El objetivo de esta sección será refrescar o
          introducir, los conceptos que se consideran
          básicos o necesarios, para que el lector
          pueda comprender con mayor facilidad los
          temas que se abordarán en el resto del libro,
          además de adoptar una notación para los
          mismos.
        </p>
        <p>
          Es por ello que, solamente formarán parte de
          esta sección las definiciones básicas, las
          definiciones que puedan ser más complejas
          serán presentadas en los capítulos
          correspondientes.
        </p>
        <p>
          Ya que es bastante común que en el estudio de
          la <span class="bolded">Geometría computacional</span>, se
          aborden temas que hacen uso de conjuntos de
          puntos en un espacio euclidiano, es necesario
          saber representar a estos puntos.<br>
          Sin embargo, resulta claro que no es
          suficiente con solo saber representar puntos,
          pues, los objetos geométricos que se estudian
          o de los que se hace uso para estudiar la
          <span class="bolded">Geometría computacional</span>, a
          pesar de no que necesitan consistir de un
          número finito de puntos, sí resulta necesario
          que tengan una especificación finita.
          <br>
          Es por eso que, además de considerar
          <span class="bolded">puntos</span>
          individuales, se consideran elementos más
          complejos, tales como,
          <span class="bolded">líneas rectas</span>, <span class="bolded">segmentos
            de líneas rectas</span>,
          <span class="bolded">planos</span>,
          <span class="bolded">polígonos</span>, etcétera, cuyas
          definiciones y/o conceptos básicos serán
          presentados en la primer parte del capítulo
          actual.
        </p>
      </div>

      <div class="page">
        <p>
          Adicionalmente, para el uso de algoritmos
          geométricos es necesario manipular
          estructuras que no son manejadas a nivel de
          lenguaje de máquina. Por lo que es necesario
          implementar y/o utilizar diversas estructuras
          de datos, de las cuales las más comúnmente
          utilizadas son los conjuntos y los conjuntos
          ordenados, pero resulta claro comprender que
          estas no son las únicas utilizadas. Sin
          embargo en este capítulo solo se mencionarán
          las que se consideran necesarias, teniendo en
          cuenta que el lector ya cuenta con
          conocimientos de las estructuras de datos más
          básicas.
        </p>
      </div>
      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!-- Parte 1: Definiciones generales -->
      <!--  -->
      <div class="page">
        <h2 id="cap1_definiciones_generales">Definiciones generales.</h2>
        <p>
          Para comenzar, denotaremos como
          $\mathbb{R}^d$ al espacio euclídeo
          d-dimensional, esto es, el espacio de
          d-vectores $(x_1 , \dots , x_d)$ de números
          reales $\ x_i, \ i = 1, … , d\ $ con
          <a target="_blank" href="https://en.wikipedia.org/wiki/Metric_(mathematics)">
            métrica
          </a>
          $( \sum^{d}_{i=1} x^{2}_{i})^{1/2}$.
        </p>
        <p>
          Dada esta definición podemos continuar con
          las que resultan más indispensables para el
          estudio de la geometría computacional.
        </p>
        <!-- PUNTO -->
        <h4><span class="bolded">Punto.</span></h4>
        <p>
          Un vector con $d$ componentes $(x_1 , \dots ,
          x_d)$ aplicado en el origen de $\mathbb{R}^d$
          denota un
          <span class="bolded">punto</span> $p$ en $\mathbb{R}^d$.
        </p>
        <p>
          En la <ref ref_id="ejemplo_punto"></ref> se muestra un interactivo
          en el cual se representa un punto en el
          espacio en $\mathbb{R}^2$, al cual podemos
          cambiar sus valores en cada uno de sus
          componentes.
        </p>
        <figure id="ejemplo_punto">
          <div class="interactive" width="400" height="200"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_punto.html"></div>
          <figcaption>Ejemplo de punto en $\mathbb{R}^2$.</figcaption>
        </figure>
      </div>

      <div class="page">
        <!-- LINEA -->
        <h4><span class="bolded">Línea.</span></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, el conjunto de todos los
          puntos $r$ que satisfacen

          \[ r = \alpha \ p_1
          + (1 -\alpha ) p_2 \qquad ( \alpha \in
          \mathbb{R} ) \]

          describe una
          <span class="bolded">línea</span> en $\mathbb{R}^d$.
        </p>
        <p>
          A pesar de que un solo par de puntos
          distintos definen perfectamente una línea,
          una línea en $\mathbb{R}^d$ contiene un
          número infinito de puntos. Lo cual puede
          apreciarse en la <ref ref_id="linea"></ref>, en el cual las
          flechas azul y verde, representan la partes
          respectivas que aportan los puntos $p_2$ y
          $p_1$ al nuevo punto $r$ respectivamente.
          <br> De esta manera, al cambiar el valor de
          $\alpha$ podemos obtener cualquier punto
          sobre la línea roja.
        </p>

        <figure id="linea">
          <div class="interactive" width="500" height="300" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_linea.html"></div>
          <figcaption>
            Ejemplo de definición de
            línea.
          </figcaption>
        </figure>

      </div>
      <div class="page">
        <!-- Segmento de línea-->
        <h4><span class="bolded">Segmento de línea.</span></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, si a la definición anterior
          agregamos la condición $ \ 0 \leq \alpha \leq
          1 \ $, esto es \[ r = \alpha \ p_1 + (1
          -\alpha ) p_2 \qquad ( 0 \leq \alpha \leq 1 )
          \] el conjunto de todos los puntos que
          satisfacen dicha definición, describe el
          <span class="bolded">segmento de línea</span>
          recta que une los dos puntos $ \ p_1 \ $ y $
          \ p_2 \ $ en $\mathbb{R}^d$. Normalmente este
          <span class="bolded">segmento de línea</span>
          se denota como $ \ \overline{ p_1 p_2}$.
        </p>
        <p>
          La <ref ref_id="segmento_de_linea"></ref> muestra un
          interactivo que funciona de la misma manera
          al presentado en la <ref ref_id="linea"></ref>, el cual muestra la
          definición de línea, sin embargo se puede
          notar como en este recurso el valor de
          $\alpha$ cumple la condición $( 0 \leq \alpha
          \leq 1 )$, lo cual nos limita a solo poder
          representar puntos que están sobre la línea y
          a su vez entre los puntos $ p_1 p_2 $.
        </p>
        <figure id="segmento_de_linea">
          <div class="interactive" width="500" height="280" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_segmento.html"></div>
          <figcaption>
            Ejemplo de definición de segmento
            de línea.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <!-- Polígono-->
        <h4><span class="bolded">Polígono.</span></h4>
        <p>
          En $\mathbb{R}^d$ un
          <span class="bolded">polígono</span> $P$, es
          la región cerrada del plano, acotada por una
          colección finita de segmentos de línea,
          formando una <span class="bolded">curva
            cerrada simple</span>.
          <br>
          Ya que puede ser complejo explicar el
          significado de
          <span class="bolded">curva cerrada simple</span>, podemos
          abordar la definición de la siguiente manera,
          para poderlo explicar de una forma más
          sencilla.
        </p>
        <p>
          Sean $ \ v_0, v_1, v_2,\dots, v_{n-1} $, $n$
          puntos en el plano. Sean $ e_0 = $
          $ \overline{v_0 v_1}, \ e_1 = $
          $ \overline{v_1 v_2}, \ \ \dots \ ,e_i =$
          $ \overline{v_{i} v_{i+1}}, \ \dots$
          $, e_{n-1} = \overline{v_{n-1} v_{0}} $;
          $n - 1$ segmentos conectando los
          puntos, estos segmentos delimitan un
          <span class="bolded">polígono</span>
          si y solo si:
        </p>
        <ol>
          <li>
            La intersección de cada par de segmentos
            adyacentes en el ciclo ordenado es el único
            punto que comparten entre ellos:
            <br>
            $ e_i \cap e_{i+1} = v_{i+1, \ }$ para todo
            $i = 0, \dots, n - 1$.
          </li>
          <li>
            Los segmentos no adyacentes no se
            intersectan:
            <br>
            $ e_i \cap e_{j} = \emptyset, \ $ para todo
            $j \neq i - 1$.
          </li>
        </ol>

        <figure id="poligono_condiciones">
          <img src="./images/capitulo_01/Ejemplo_condiciones_poligono.png">
          <figcaption>Ejemplo condiciones del
            polígono.</figcaption>
        </figure>

      </div>



      <div class="page">
        <p>
          En la <ref ref_id="poligono_condiciones"></ref> tenemos un ejemplo de un
          conjunto de segmentos de línea que no cumplen
          ambas condiciones.
          <br>
          Podemos observar como las aristas $e_1$ y
          $e_2$ (azul y roja, respectivamente) no
          cumplen la segunda condición, y a su vez las
          aristas $e_3$ y $e_4$ (negra y verde,
          respectivamente) no cumplen la primer
          condición.
        </p>
        <p>
          Dada esta definición, podemos explicar de una
          forma más simple, qué es una
          <span class="bolded">curva cerrada
            simple</span>. <br> La razón por la cual
          estos segmentos de línea se definen como una
          <span class="bolded">curva</span> es porque
          es una línea continua, pues los segmentos
          están conectados por los extremos; la razón
          por la cual esta curva es
          <span class="bolded">cerrada</span> es porque
          forma un ciclo, pues el último segmento se
          conecta con el primero y la razón por la que
          la curva cerrada, es además <span class="bolded">simple</span>, es porque los
          segmentos no adyacentes no se intersectan.
        </p>
        <p>
          Podemos definir a los objetos que cumplen
          solo la primer condición como
          <span class="bolded">polígonos no simples</span>, si
          cumplen también la segunda (los segmentos no
          adyacentes no se intersectan) los llamaremos
          <span class="bolded">polígonos simples</span>, otra forma
          más sencilla de definirlo es que un polígono es
          simple si sus elementos no se intersectan entre sí.
          <br>
          Ya que prácticamente solo se hará uso de los
          <span class="bolded">polígonos no simples</span>, por
          simplicidad solo los llamaremos
          <span class="bolded">polígonos</span>.
        </p>
        <p>
          En un polígono, los segmentos $e_i$ son
          llamados <span class="bolded">aristas</span>
          (se usa la notación $e$ ya que la traducción
          de arista al inglés es edge, y es bastante
          común encontrar dicha notación en la
          literatura, utilizaremos dicha notación por
          esa razón), y los puntos $v_i$ (puntos donde
          se intersectan los segmentos de línea
          adyacentes) son llamados
          <span class="bolded">vértices</span>.
        </p>
      </div>

      <div class="page">
        <p>
          Un polígono, con sus aristas y vértices,
          encierra una región del plano, nos
          referiremos a esta región como el
          <span class="bolded">interior del polígono</span>. La
          región no delimitada que rodea al polígono
          forma el <span class="bolded">exterior del polígono</span>.
        </p>
        <p>
          El conjunto de vértices y aristas de un
          polígono $P$ (el polígono sin su interior) es
          llamado perímetro, y es denotado como $
          \partial P$.
          <br>
          A lo largo de las notas cuando nos refiramos a
          un polígono nos referiremos a la unión de su
          perímetro y su interior. Lo que significa que
          si mencionamos un punto en un polígono este
          se puede encontrar ya sea en el interior o en
          su perímetro.
          <br><br>
        </p>

        <p>
          Existen algoritmos que necesitan dividir a
          los polígonos en varias partes para
          procesarlos. Una forma natural de dividir a
          los polígonos en partes más simples se logra
          dibujando <span class="bolded">diagonales</span>.
          <br>
          Una <span class="bolded">diagonal</span> de un polígono
          $P$, es un segmento de línea que conecta dos
          vértices de $P$ y que yace en el interior de
          $P$, este segmento no toca a $ \partial P$
          excepto en su punto inicial y su punto final.
        </p>
        <p>
          Dos diagonales no se cruzan si no comparten
          puntos interiores, esto es, si comparten a lo
          más alguno de sus puntos de inicio o fin.
        </p>

      </div>

      <div class="page">
        TO DO
        <!-- <img src="/images/capitulo_01/Diagonales_from_Devad_discrete_and_computational_geo.jpg" width="90%">
        <br>
        Figure 1.2 shows (a) a polygon, (b) a diagonal, (c) a line segment
        that is not a diagonal, and (d) two crossing diagonals.
        <br><br>
        Definition. A triangulation of a polygon P is a decomposition of P into
        triangles by a maximal set of noncrossing diagonals.
        Here maximal means that no further diagonal may be added to the
        set without crossing (sharing an interior point with) one already in
        the set. -->
      </div>

      <!-- REPASO DE ESTRUCTURAS DE DATOS -->
      <div class="page">
        <h2 id="cap1_repaso_estructuras_datos">Repaso de estructuras de datos</h2>
        <p>
          Como ya se mencionó al inicio de este
          capítulo las estructuras de datos resultan
          una herramienta fundamental para el uso de
          los algoritmos geométricos. Muchas de estas
          estructuras de datos son descritas en el
          curso referente a estructuras de datos, y
          dado que no es la intención de este libro
          volver a describir dichas estructuras, a
          continuación serán presentadas únicamente las
          que resulten indispensables por no formar
          parte del temario oficial de dicho curso.
          <br><br>
        </p>

        <h2 id="cap1_preliminares_geometricos">Preliminares geométricos</h2>
        TO DO
      </div>

      <!--  -->
      <!-- CAPITULO 2: CIERRE CONVEXO -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="cierre_convexo">
            Cierre convexo de un conjunto de puntos
          </h1>
          <h1 class="chap_num">2</h1>
        </div>
        <p>
          Antes de comenzar este capítulo, necesitamos
          saber que es un <span class="bolded">cierre convexo</span>,
          antes de definirlo formalmente, podemos
          tomarnos la libertad de definirlo de una
          forma más intuitiva.
        </p>
        <p>
          Esto es, dado un conjunto finito de puntos
          $S$ en el plano, si vemos a cada punto de $S$
          como un clavo colocado en una superficie plana,
          una madera por ejemplo, y tomamos una liga para estirarla
          al rededor de todos los clavos y la soltamos,
          podemos ver al <span class="bolded">cierre convexo</span> de $S$
          como la región que queda encerrada por la
          liga al rededor de todos los clavos.
        </p>
        <p>
          La <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>,
          contiene un recurso interactivo que nos
          muestra esta idea, donde los círculos
          representan los "clavos" (puntos en $S$) y
          las líneas verdes la "liga" que los encierra.
          <br>
          Puedes hacer clic en cualquiera de los
          círculos blancos que representan a los puntos
          en $S$ para poder moverlo en la dirección que
          muevas el cursor, y a su vez puedes dar de
          nuevo clic para dejarlo fijo en la nueva
          posición de cursor y ver como se modifica el
          cierre convexo.
        </p>
      </div>

      <div class="page">

        <figure id="cierre-convexo">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_2/intuitive_idea.html"></div>
          <figcaption>Ejemplo de la idea intuitiva de un cierre convexo.</figcaption>
        </figure>

        Ahora que tenemos esta definición que nos sirve
        para tener más clara la idea geométrica,
        podemos avanzar más fácilmente y comenzar con
        definiciones adicionales que sean más formales.
        </p>
        <p>
          A continuación definiremos una <span class="bolded">combinación convexa</span>
          para definir lo que es un <span class="bolded">cierre convexo</span>
          a partir de la primera.
          <br>
        </p>

        <p>
          <!-- Conjunto convexo.-->
        <h4><span class="bolded">Combinación convexa.</span></h4>
        Dado un número finito $k$ de puntos
        $p_0, p_1, p_2,\dots, p_{k}$ en $\mathbb{R}^d$,
        una combinación convexa de dicho conjunto de puntos es
        un punto de la forma:
        \[
        r = \alpha_1 p_1 + \alpha_2 p_2 + \dots + \alpha_k p_k
        \]
        donde $\alpha_i$ satisfacen las siguientes condiciones:
        \[
        ( \alpha_i \in \mathbb{R}, \ \ 0 \leq \alpha_i \leq 1,\ \ \alpha_1 + \dots + \alpha_k = 1 )
        \]
        <bibref ref_id="CG_in_C"></bibref>
        </p>



      </div>

      <div class="page">
        <p>
          Si prestamos atención, podemos notar que un
          <span class="bolded">segmento de línea</span>
          consta de todas las combinaciones convexas
          que pueden ser generadas de sus puntos
          extremos que lo definen. Lo cual puede ser
          visto claramente en la <pageref ref_id="segmento_de_linea">
            <ref ref_id="segmento_de_linea"></ref>
          </pageref>.
        </p>
        <p>
          De manera similar podemos notar como un
          triángulo consiste de todas las combinaciones
          convexas de los 3 puntos (no colineales) que
          lo definen. Lo cual puede ser visto en la
          <ref ref_id="comb-convexa"></ref>, en la
          cual, al presionar el botón en la parte
          inferior, podemos generar una combinación
          convexa aleatoria a partir de los tres puntos
          que forman al triángulo. En la parte superior
          podemos apreciar como se define al punto $r$
          siguiendo la definición de combinación
          convexa, tomando cada uno de los puntos que
          definen al triángulo ($p_1 = (1,5)$, $p_2 =
          (8,1)$ y $p_3 = (8,8)$) multiplicándolos por
          una $\alpha_i$ aleatoria, de tal manera que
          la suma de las $\alpha_i$ suman 1.
        </p>
        <figure id="comb-convexa">
          <div class="interactive" width="500" height="295" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_conjunto_convexo.html"></div>
          <figcaption>Ejemplo de una combinación convexa generada por los puntos que definen un triángulo.</figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Una vez vistos los ejemplos anteriores
          podemos ver un ejemplo más, con 5
          puntos, $p_1 = (1,5)$, $p_2 = (8,1)$ y $p_3 =
          (8,8)$, $p_4 = (4,6)$ y $p_5 = (7,6)$. <br>
          En la
          <ref ref_id="comb-convexa-2"></ref>
          podemos dar valores entre cero y uno a cada
          $\alpha_i$ (cada $\alpha_i$ tiene al mismo
          color del punto al cual multiplica), y en el
          caso que cumplan la condición $ \alpha_1 +
          \dots + \alpha_5 = 1 $ el punto $r$ será una
          combinación convexa generada con los 5
          puntos, justo como en los ejemplos anteriores
          y en la definición.

        </p>
        <figure id="comb-convexa-2">
          <div class="interactive" width="600" height="365" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_combinacion_convexa_2.html"></div>
          <figcaption>Ejemplo de combinación convexa generada por 5 puntos.</figcaption>
        </figure>
        <p>
          Después de apreciar este ejemplo, podemos
          notar como todas las posibles combinaciones
          convexas generadas del conjunto de puntos,
          resultan estar contenidas en un área convexa,
          la cual en las figuras, <pageref ref_id="comb-convexa">
            <ref ref_id="comb-convexa"></ref>
          </pageref>
          y
          <pageref ref_id="comb-convexa-2">
            <ref ref_id="comb-convexa-2"></ref>
          </pageref>
          se muestra de color morado.
        </p>
      </div>

      <div class="page">
        <p>
          Ahora pensemos a que nos recuerda si tomamos
          cada punto del conjunto como un clavo clavado
          en el plano y los rodeamos con una liga, esto
          sin lugar a dudas nos resultará familiar,
          esta misma era la idea intuitiva del
          <span class="bolded">cierre convexo</span>,
          lo que nos deja ver que el área formada por
          todas las posibles combinaciones convexas
          generadas del conjunto de puntos, es justo el
          área encerrada por la liga, dicho de otra
          manera, es el cierre convexo del conjunto de
          puntos.
        </p>
        <p>
          Por lo que, aprovechándonos de esto, podemos
          pasar a definir más formalmente a nuestro
          <span class="bolded">cierre convexo</span> de
          la siguiente manera.
        </p>
        <!-- Cierre convexo.-->
        <p>
        <h4><span class="bolded">Cierre
            convexo.</span></h4>
        Dado un conjunto finito $S$ de puntos en
        $\mathbb{R}^d$, el <span class="bolded">cierre
          convexo</span>
        de $S$, denotado por $conv(S)$, es el conjunto
        de todas las combinaciones convexas de los
        puntos en $S$.
        <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Ahora que podemos comprender que es el cierre
          convexo, nos sería de gran utilidad saber
          ¿cómo representar al cierre convexo? y ¿qué
          significa calcular el cierre convexo?, pues
          resulta necesario para nuestro objetivo, que
          es indagar en los algoritmos para calcularlo.
        </p>
        <p>
          Comencemos primero por buscar una forma de
          representarlo.
        </p>
        <p>
          Recordando la idea intuitiva de la liga que
          rodea a los clavos, podemos notar que el área
          que encierra esta liga es un polígono
          convexo, lo cual podemos ver en la <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>, moviendo los puntos a voluntad.
          <br>
          Esto nos lleva a una definición alternativa,
          que es la siguiente.
        </p>
      </div>

      <div class="page">
        <p>
        <h4><span class="bolded">Cierre convexo
            definición alternativa.</span></h4>
        El cierre convexo de un conjunto finito $S$ de
        puntos en el plano es el único polígono convexo
        cuyos vértices son puntos de $S$ y que
        contienen todos los puntos de $S$.
        </p>
        <p>
          Ya que el objetivo de este libro no es ser
          totalmente formales, se pasan por alto muchas
          de las pruebas, pero se invita al lector a
          buscar en la bibliografía en caso de requerir
          más formalidad.
          <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Esta nueva definición nos resulta útil pues
          podremos representar al cierre convexo como
          un polígono convexo, teniendo en cuenta que
          el área contenida por este polígono es el
          cierre convexo.
        </p>
        <p>
          Ahora que sabemos que podemos representar al
          cierre convexo de un conjunto de puntos $S$
          como un polígono, resulta esencial saber como
          representar a este polígono.
        </p>
        <p>
          Una forma natural de hacerlo es listando los
          vértices de dicho polígono en orden de las
          manecillas del reloj, comenzando desde algún
          punto arbitrario.
        </p>
        <p>
          Tomando esta forma de representar a un
          conjunto convexo, podemos describir el
          problema de encontrar el conjunto convexo de
          un conjunto de puntos, de la siguiente
          manera:
        </p>
        <h4><span class="bolded">Descripción del problema.</span></h4>
        <p>
          Dado un conjunto de puntos $S =
          p_0, p_1, p_2,\dots, p_{n}$ en el plano,
          calcular una lista que contenga a todos los
          puntos de $S$ que son vértices del $conv(S)$
          listados en orden contrario a las manecillas del
          reloj.
        </p>
      </div>
      <div class="page">
        <p>
          Por ejemplo, dado el siguiente conjunto de puntos:
          <img src="./images/capitulo_01/Ejemplo_ch_problema.png">
        <figcaption>Conjunto de puntos de entrada y polígono formado por la salida.</figcaption>
        <br>
        La entrada y salida serían las siguientes:
        \[
        Entrada = conjunto \ de \ puntos \ completo: \\
        p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9
        \]
        \[
        Salida = conjunto \ de \ puntos \\
        que \ representan \ al \ cierre \ convexo: \\
        p_2, p_8, p_5, p_4, p_9
        \]
        </p>
      </div>

      <div class="page">
        <p>
          Es importante recordar que los puntos $p_2,
          p_9, p_4, p_5, p_8$ no son el cierre convexo de
          $S$, son solo la representación de cierre
          convexo pues el cierre convexo sería el
          polígono (interior y perímetro) formado con
          estos puntos, lo que en el ejemplo se
          representa con el área color morado.
        </p>
        <p>
          Ahora que sabemos qué es un cierre convexo, y
          además sabemos como describir el problema
          dada una cierta entrada para obtener una
          cierta salida, podemos empezar a indagar de
          que manera podremos solucionar estos
          problemas.
        </p>
      </div>

      <!-- Algoritmo de Graham.-->
      <div class="page" id="graham_algorithm_page">
        <h2 id="cap2_algorithmo_grahan">Algoritmo de Graham</h2>

        <h4><span class="bolded">Contexto</span></h4>
        <p>
          El algoritmo que se abordará en esta sección,
          surgió a finales de la década de 1960, en los
          laboratorios Bell, de la necesidad de su
          creador Ron Graham, por calcular el cierre
          convexo de una gran cantidad de puntos en el
          plano. Una complejidad de $O(n^2)$ en tiempo
          no le resultaba practica, lo que lo llevó a
          describir un algoritmo con una complejidad de
          $O(n log n)$ en tiempo, el cual pasó a ser el
          posiblemente el primer articulo publicado en el
          campo de la geometría computacional en 1972.
        </p>
        <p>
          En esta publicación Graham mostró que al
          realizar un ordenamiento de los puntos, al
          inicio del algoritmo, podía encontrar los
          puntos externos que describen al cierre
          convexo con una complejidad de $O(n)$ en
          tiempo.
        </p>
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por los puntos que son vértices
          del polígono que forman al cierre convexo
          $conv(S)$.
        </p>
        <p>
          Dividamos al algoritmo en pasos, para una
          mejor comprensión del mismo.

        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Comencemos por encontrar al punto con la
          coordenada en $y$ más pequeña, de ser más de
          uno, tomaremos entre estos, al punto con la
          coordenada en $x$ más grande y lo agregamos
          al conjunto de salida $conv(S)$.
        </p>
      </div>
      <div class="page">
        <p>
          Dado que este punto es el punto inferior
          sabemos que pertenece al polígono que forma
          al cierre convexo, y lo tomaremos como punto
          inicial, para de aquí ir agregando a los
          puntos restantes.
        </p>
        <figure id="punto_inferior">
          <img src="./images/capitulo_02/punto_inferior.png" width="45%" height="45%"
            alt="Imagen que muestra el punto inferior seleccionado.">
          <figcaption>Seleccionamos el punto interior.</figcaption>
        </figure>
        <h5><span class="bolded">Paso 2. Ordenar los puntos con respecto al inferior.</span></h5>
        <p>
          Posteriormente ordenaremos todos los demás
          puntos en $S$ por el ángulo que forma la
          línea trazada desde el punto inferior hasta
          el punto actual, con respecto al eje $x$, al
          sentido contrario a las manecillas del reloj.
        </p>

        <figure id="ordenar_puntos">
          <img src="./images/capitulo_02/puntos_ordenados.png" width="50%" height="50%"
            alt="Imagen que muestra el punto inferior seleccionado y a los demás ordenados con respecto a este.">
          <figcaption>Ordenamos con respecto al punto interior.</figcaption>
        </figure>
      </div>
      <div class="page" id="graham_step_3">
        <h5><span class="bolded">Paso 3. Recorrer los puntos ordenados y agregar puntos al $conv(S)$.</span></h5>
        <p>
          A partir de aquí, iremos procesando cada
          punto en el orden que resultó del paso
          anterior, al cual llamaremos $p_i$.
        </p>
        <p>
          Para procesar al siguiente punto $p_i$
          haremos uso de los últimos dos puntos
          agregados a $conv(S)$.
          <br>
          Podemos apreciar que iniciamos esta parte del
          algoritmo con solo un punto en $conv(S)$, por
          lo que en este caso, agregaremos al siguiente
          punto a procesar $p_i$ automáticamente.
        </p>
        <p>
          Una vez que es posible tomar los últimos dos
          puntos en $conv(S)$, formaremos una tripleta
          con los últimos dos puntos dentro del $conv(S)$
          que llamaremos $p_k$ y $p_{k-1}$ y el
          siguiente punto a procesar $p_i$.
          <br>
          Tomando esta tripleta $ ( p_{k-1} , p_{k} ,
          p_{i} ) $, realizaremos una comprobación de
          si la secuencia de los tres puntos realiza
          una vuelta hacia la izquierda, hacia la
          derecha, o si los 3 puntos son colineales.
          <br>
          Para verificar si la secuencia de los 3
          puntos dan una vuelta izquierda, derecha o
          son colineales, comprobaremos si el tercer
          punto de la secuencia está a la izquierda,
          derecha o en la <span class="bolded">línea
            dirigida</span> formada por los primeros dos
          puntos.
          <br>
          Diremos que una <span class="bolded">línea
            dirigida</span> es formada por una secuencia
          de dos puntos, la línea es la formada por
          ambos puntos y la dirección va del primer
          punto al segundo punto.
          <bibref ref_id="CG_in_C">Pag. 29</bibref>
        </p>
        <p>
          La siguiente Figura muestra un ejemplo de
          la vuelta izquierda y la vuelta derecha.
        </p>
      </div>
      <div class="page">
        <figure id="ordenar_puntos">
          <img src="./images/capitulo_02/Ejemplo_vueltas_1.jpg" width="80%" height="60%"
            alt="Ejemplo de la definición de vuelta derecha e izquierda.">
          <figcaption>Ejemplo de la definición de vuelta derecha e izquierda.</figcaption>
        </figure>
        <p>
          Una vez sabiendo si la tripleta de puntos dan
          una vuelta derecha o izquierda, actuamos de
          la siguiente manera.
        </p>
        <p>
          Si la tripleta $ ( p_{k-1} , p_{k} , p_{i} )
          $ forma una vuelta izquierda, agregamos al
          punto $p_{i}$ a nuestro conjunto de salida
          $conv(S)$.
        </p>
        <p>
          Si la tripleta $ ( p_{k-1} , p_{k} , p_{i} )
          $ forma una vuelta derecha o los puntos son
          colineales, eliminamos al último punto de
          nuestro conjunto de salida $conv(S)$, esto es
          al punto $p_{k}$.
        </p>
        <p>
          Repetiremos este proceso hasta que hayamos
          procesando todos los puntos que ordenamos al
          inicio.
        </p>
        <p>
          En la <ref ref_id="graham_scan_algorithm"></ref> podemos ver un ejemplo de la
          ejecución del algoritmo de Graham paso a paso
        </p>
      </div>
      <div class="page">

        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/graham_scan.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Graham.</figcaption>
        </figure>
        <!-- Fuentes: Discrete%20and%20computational%20geometry%20by%20Devadoss%20S.,%20ORourke%20J.%20(z-lib.org).pdf -->
        <!-- Computational_Geometry_An_Introduction_by_Franco_P_Preparata,_Michael. -->
        <!-- Computational%20Geometry%20in%20C%20by%20Joseph%20ORourke%20(z-lib.org).pdf -->
      </div>

      <div class="page" id="graham_algorithm__complexity_page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Dado que lo único que nos interesa en este
          paso es obtener un punto en algún extremo del
          conjunto de puntos $S$, resulta indistinto
          cual escoger, en este caso se toma al punto
          interior.
          <br>
          Para obtener este punto inferior resulta
          claro que es necesario recorrer todos y cada
          uno de los puntos en $S$ y llevar registro
          del que tiene el menor valor en el eje $y$,
          lo cual podemos hacer en una complejidad en
          tiempo de $ \ O(n) \ $ donde $ \ n \ $ es el número
          de puntos en $S$.
        </p>
        <h5><span class="bolded">Paso 2. Ordenar los puntos con respecto al inferior.</span></h5>
        <p>
          Para esta parte del algoritmo necesitamos
          ordenar todos los demás puntos en $S$ por el
          ángulo que forma la línea trazada desde el
          punto inferior hasta el punto que deseamos
          ordenar, con respecto al eje $x$
          (considerando al punto inferior como el
          origen) al sentido contrario a las manecillas
          del reloj.
          <br>
          Es posible hacer este ordenamiento,
          comparando cada punto a ordenar, usando el
          valor del ángulo de la línea trazada desde el
          punto inferior hasta dicho punto. Como se
          puede apreciar en la <ref ref_id="compare_points_by_angle"></ref>
          donde el ángulo de $p_2$ es menor al ángulo
          de $p_3$.
        </p>
        <p>
          Para que el ordenamiento resulte en
          $O(nlogn)$ necesitamos una forma de comparar
          dos puntos en tiempo constante, lo cual
          podemos hacer calculando los ángulos
          directamente.
        </p>
      </div>

      <div class="page">
        <p>
          Esta forma de comparar podría tener algunos
          inconvenientes, por lo que hay formas
          alternativas para comparar los puntos que
          aprovechan el mismo calculo necesario para
          calcular si 3 puntos dan una vuelta derecha o
          izquierda, sin embargo, no ahondaremos en más
          dichos detalles.
        <figure id="compare_points_by_angle">
          <img src="./images/capitulo_02/Ejemplo_comparar_angulos.svg" width="80%" height="60%" alt="Ejemplo de la
          comparación de dos puntos por sus ángulos.">
          <figcaption>Ejemplo de la comparación de los
            ángulos de $p_2$ y $p_3$ con respecto a punto
            inferior $p_1$.</figcaption>
        </figure>
        </p>
        <p>
          Entonces, asumiendo que la complejidad de la
          comparación usada para el ordenamiento toma
          tiempo constante, este paso nos resulta
          en $O(nlogn)$.
        </p>

      </div>
      <div class="page">
        <h5>
          <span class="bolded">Paso 3. Recorrer los
            puntos ordenados y agregar puntos al
            $conv(S)$.</span>
        </h5>
        <p>
          En este paso podemos observar que recorremos
          la lista de puntos ordenados uno por uno,
          verificando si forma una vuelta derecha o
          izquierda, dicha comprobación puede ser
          realizada de la siguiente manera.
        </p>
        <p>
          Dada la tripleta de puntos $(a,b,c)$ podemos
          calcular las pendientes de los segmentos
          $A = \overline{a b}$ y $B = \overline{b c}$
          denotadas como:
        </p>
        $$ m_{A} = \frac{b_y - a_y}{b_x - a_x} $$
        $$ m_{B} = \frac{c_y - b_y}{c_x - b_x} $$
        <p>
          Si la $ m_{A} > m_{B} $ entonces tenemos una
          vuelta derecha, si por el contrario $ m_{A} < m_{B} $ entonces tenemos una vuelta izquierda, y en el caso que
            $ m_{A}=m_{B} $ entonces no hay vuelta, ya que los puntos son colineales. </p>

            <p>
              En la figura <ref ref_id="comparacion_pendientes"></ref> podemos apreciar esta comparación,
              la cual podemos calcular fácilmente como:
              $$ (b_y - a_y) * (c_x b_x) - (c_y - b_y)*(b_x - a_x) $$
              Formula que se deriva de restar $ m_{A} - m_{B}$ y cuyo resultado es
              positivo cuando $ m_{A} > m_{B} $, negativo cuando $ m_{A} < m_{B} $ y 0 cuando $ m_{A}=m_{B} $ .</p>
                <p>
                  Por lo que gracias a esto podemos calcular de que tipo de vuelta se trata en tiempo constante.
                </p>
      </div>

      <div class="page">
        <figure id="comparacion_pendientes">
          <div class="interactive" width="500" height="350" window-size="false"
            src="./Interactivos/capitulo_2/descartesJS/Ejemplo_comparacion_de_pendientes.html"></div>
          <figcaption>Ejemplo de comparación de pendientes para saber que tipo de vuelta dan los puntos.
          </figcaption>
        </figure>

        <p>
          Además podemos observar que cada punto en
          el
          conjunto ordenado, es añadido y removido del
          conjunto de salida $conv(S)$ a lo más una
          vez, entonces, dicho recorrido sobre los
          puntos ordenados se realiza en $O(n)$
          iteraciones.
        </p>
        <p>
          Por lo tanto la complejidad es $O(nlog(n))$,
          pues la complejidad de ordenar a los puntos
          en el paso 2 domina las complejidades de los
          pasos 1 y 3.
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmo_jarvis">Algoritmo de Jarvis</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          En el algoritmo anterior comenzamos
          identificando un punto extremo en el
          conjunto de puntos original, ahora bien,
          ¿podríamos hacer lo mismo para encontrar
          todos los puntos que representan al cierre
          convexo?
          <br>
          Ciertamente, encontrar todos los puntos
          extremos no resulta tan fácil como encontrar
          el inferior, el superior, el más a la derecha
          y el más a la izquierda, sin embargo, una vez
          tomado un extremo, resulta más fácil
          encontrar otro punto extremo, si sabemos que
          la línea que trazan ambos puntos, está en un
          extremo también, es decir, si todos los demás
          puntos en $S$ están, sobre la misma línea o
          a un solo lado de la línea.<bibref ref_id="CG_an_Introduction">Pag. 110</bibref>
        </p>
        <p>
          La siguiente figura muestra un ejemplo de
          esto, tomando los puntos $p_8$ y
          $p_5$ podemos trazar una línea que cumple
          la condición ya mencionada.
        </p>
        <figure id="linea_extrema">
          <img src="./images/capitulo_02/Ejemplo_linea_extrema.png" width="75%" height="75%"
            alt="Linea que se encuentra al extremo inferior, con todos los demás puntos por arriba de ella.">
          <figcaption>Línea que se encuentra al extremo inferior, con todos los demás puntos por arriba de ella.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Podríamos hacer uso de este conocimiento y
          buscar todos los pares de puntos que
          representan líneas que cumplen dicha
          condición, pues justo estas son las que
          forman al $conv(S)$, sin embargo el número de
          parejas de puntos sobre las que deberíamos
          iterar para comprobar si cumplen dicha
          condición, son <a target="_blank" href="https://en.wikipedia.org/wiki/Complete_graph">
            $n(n-1)/2$</a>, lo cual nos tomaría un tiempo
          de $O(n^2)$, además de que para cada línea
          formada por cada par de puntos deberíamos
          comprobar si todos los demás puntos cumplen
          la condición de yacer solo a un lado de la
          línea, lo que nos tomaría $O(n)$ para cada
          par de puntos, esto es $O(n^3)$ para el
          algoritmo completo.
        </p>
        <p>
          ¿Se podría hacer algo mejor que eso usando la
          misma idea? <br>
          Tal parece que sí, Jarvis en su articulo de
          1973, mostró como se puede reducir la
          complejidad a $O(n^2)$ si tomamos en cuenta
          que una vez tenemos un par de puntos $p_a$ y
          $p_b$ en $conv(S)$, sabemos que debe existir
          otro punto $p_c$ que junto con $p_b$ definan
          una línea que tenga a todos los demás puntos
          de un solo lado.
          <bibref ref_id="CG_an_Introduction">Pag.
            111</bibref>
        </p>
        <p>
          El algoritmo presentado en esta sección hará
          uso de esta idea para obtener todos los
          puntos que representan a $conv(S)$.
        </p>

      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado lo que sabemos hasta ahora, podemos describir el algoritmo de Jarvis
          en solo dos pasos, los cuales son los siguientes:
        </p>

        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Este paso es exactamente igual al primer paso del
          <pageref ref_id="graham_algorithm_page">algoritmo de
            Graham antes descrito</pageref>.
        </p>
        <h5><span class="bolded">Paso 2. Ir agregando puntos a $conv(S)$ tomando el último punto en
            $conv(S)$ como referencia.</span></h5>

        <p>
          En esta parte del algoritmo tomamos al último
          punto que fue agregado a $conv(S)$, al que
          nos referiremos como $p_k$, posteriormente,
          procedemos a comparar a todos los demás
          puntos en $S$ por al ángulo que forman con
          respecto a dicho punto $p_k$ en sentido
          contrario a las manecillas del reloj, y
          tomamos al que tenga el menor ángulo, este
          será el siguiente punto en ser agregado a
          $conv(S)$.
          <br>
          Repetiremos este procedimiento hasta que el
          siguiente punto a agregar sea uno que ya
          pertenece a $conv(S)$.
        </p>
      </div>
      <div class="page">
        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/jarvis_march.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Jarvis.</figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Esto sería igual al análisis del primer paso
          del
          <pageref ref_id="graham_algorithm__complexity_page">algoritmo
            de graham antes descrito</pageref>. Es decir,
          tenemos una complejidad de $O(n)$.
        </p>
        <h5><span class="bolded">Paso 2. Ir agregando puntos a $conv(S)$ tomando el último punto en
            $conv(S)$ como referencia.</span></h5>
        <p>
          Para esta parte del algoritmo necesitamos a
          un punto $p$ cuyo ángulo (en sentido
          contrario a las manecillas del reloj) que
          forma con respecto al último punto $p_k$ en
          $conv(S)$ sea el menor entre todos los
          ángulos formados con los puntos en $S$.
          <br>
          Haciendo uso del producto cruz, dados dos
          puntos podemos comparar cual de ellos es
          menor respecto al ángulo (en sentido
          contrario a las manecillas del reloj) que
          forma con nuestro último punto en $conv(S)$,
          $ \ p_k$.
          <br>
          Esto lo tenemos que hacer para cada punto en
          $S$ usando al último punto en $conv(S)$ hasta
          que no es posible agregar más puntos a
          $conv(S)$. Lo que significa que para cada
          punto en $conv(S)$ iteraremos sobre todos los
          puntos en $S$, esto, en el peor de los casos
          tiene una complejidad de $O(n^2)$ pues en el
          peor de los casos $S = conv(S)$.

        </p>
      </div>

      <div class="page">
        <p>
          Esta cota superior es acertada, sin embargo,
          es posible hacerla un poco más justa, ya que
          sabemos que no siempre se cumple que $S =
          conv(S)$, por lo que, si tomamos a $n$ como
          el numero de puntos en $S$ y a $h$ el numero
          de puntos en $conv(S)$, podemos decir que
          el algoritmo tiene una complejidad de $O(nh)$
          pues la complejidad del paso 1 es $O(n)$ y
          $O(nh)$ domina.
        </p>
        <p>
          Esta característica nos deja ver como este
          algoritmo se ejecuta más rápido en casos donde el
          cierre convexo es pequeño, a este tipo de algoritmos
          se les suele llamar <a target="_blank" href="https://en.wikipedia.org/wiki/Output-sensitive_algorithm">
            algoritmos sensibles a la salida
          </a>
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_divide_venceras">Algoritmos usando divide y vencerás</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          En esta sección nos centraremos en un nuevo
          enfoque para, resolver el problema del cierre
          convexo, el cual hará uso de un paradigma
          ampliamente conocido y utilizado, el
          paradigma
          <a target="_blank" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide
            y vencerás</a>.
          <br>
          Los primeros en aplicar este paradigma para
          encontrar el cierre convexo fueron
          <a target="_blank" href="https://dl.acm.org/doi/abs/10.1145/359423.359430">Franco Preparata y June Hong en
            1977</a>,
          utilizándolo no solo para el problema en 2
          dimensiones, si no que también para 3
          dimensiones, lo cual hace de este enfoque aún
          mas interesante.
        </p>
        <p>
          Este algoritmo, divide el problema inicial,
          de encontrar el cierre convexo de un conjunto
          de puntos $S$, en subproblemas que serán
          resueltos y posteriormente unidos, de una
          manera muy similar al algoritmo de
          ordenamiento <a target="_blank" href="https://en.wikipedia.org/wiki/Merge_sort"><i>merge
              sort</i> </a>.
          <br>
          La forma de dividir el problema en
          subproblemas es bastante simple, pues es
          posible ordenar los puntos por su componente
          en $x$ y dividir el problema en dos, calcular
          el cierre convexo de la primer mitad de
          dichos puntos ordenados y hacer lo mismo para
          la segunda mitad, posteriormente es necesario
          unir los cierres convexos resultantes de
          dichos subproblemas, sin embargo, realizar
          dicha union de los subproblemas, de una forma
          optima, no resulta trivial.
        </p>
        <p>
          En este momento, nos queda la pregunta, dados
          dos cierres convexos, ¿cómo podemos unirlos
          para formar el cierre convexo de ambos?
        </p>
        <p>
          Lo único que necesitamos es encontrar dos
          líneas tangentes a ambos cierres convexos,
          una superior y una inferior, un ejemplo de
          tales líneas puede ser apreciado en la <ref ref_id="lineas_tangentes"></ref>
        </p>
      </div>

      <div class="page">
        <figure id="lineas_tangentes">
          <img src="./images/capitulo_02/Ejemplo_lineas_tangentes.png" width="80%" height="80%">
          <figcaption>Ejemplo de líneas tangentes en dos cierres convexos.</figcaption>
        </figure>
        <p>
          La primer idea que nos puede venir a la
          mente, para encontrar dichas líneas
          tangentes, es tomar todos los posibles
          segmentos de líneas, que se pueden formar
          tomando un punto de cada cierre convexo, y
          tomar al par que forme una línea tal que
          todos los demás puntos estén bajo ella y al
          par que forme una línea tal que todos los
          demás puntos estén sobre ella.
          <br>
          Si embargo, realizar este procedimiento no
          sería muy eficiente, pues resultaría en
          comprobar para cada par de puntos $n(n-1)$ si
          todos los demás puntos $n-2$ yacen todos
          sobre el mismo lado de la línea, lo cual
          tendría una complejidad de $O(n^3)$.
        </p>
        <p>
          Una posible mejora que podríamos realizar a
          este algoritmo sería evitar
          comparar cada línea con todos los demás
          puntos para saber si es una línea tangente.
          <br>
          ¿Cómo podemos comprobar que una línea es
          tangente a los cierres convexos sin comparar
          con todos los puntos?
        </p>
      </div>

      <div class="page">
        <p>
          Podemos trazar una línea vertical, entre
          ambos cierres convexos, y para cada línea
          trazada por los puntos entre los cierres
          convexos, tomaremos en cuenta el punto en el
          que intercepta a la línea que trazamos,
          entonces, tomaremos como nuestras líneas
          tangentes por arriba y por abajo, a las
          líneas con el mayor y menor valor de
          intersección, con la línea vertical que
          trazamos entre ambos puntos.
          <br>
          La <ref ref_id="ch_slow_merge_algorithm"></ref> muestra un ejemplo
          en el que se puede visualizar esto fácilmente.
        </p>
        <figure id="ch_slow_merge_algorithm">
          <div class="interactive" width="810" height="750" window-size="false"
            src="./Interactivos/capitulo_2/ch_slow_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos.</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Haciendo uso de este algoritmo la
          complejidad para encontrar las líneas
          tangentes superior e inferior pasa a $O(n^2)$, sin
          embargo, esto aún no es óptimo.
        </p>
        <p>
          ¿Qué se puede hacer para mejorarlo?
        </p>
        <p>
          Podemos evitar revisar todas las parejas de
          puntos y solo revisar las que resulte
          indispensable, esto es posible usando a la
          idea que proponen Preparata y Hong en su
          artículo.
          <br>
          La idea es la siguiente y resulta
          prácticamente la misma para obtener la
          tangente superior, o la inferior, por lo que
          a continuación solo se describe como obtener
          una de ellas.
        </p>
        <p>
          Dado que sabemos que la tangente $T$ que
          buscamos, tiene un punto en el cierre convexo
          del subproblema izquierdo, y un punto en el
          cierre convexo del subproblema derecho,
          tomaremos como $T$, a la línea formada por el
          punto mas a la derecha del cierre convexo
          izquierdo, y el punto más a la izquierda del
          cierre convexo derecho. Posteriormente,
          comenzaremos a hacer "descender" la tangente
          $T$ cambiando primero su punto en un cierre
          convexo y después sobre el otro, repitiendo
          hasta encontrar la tangente inferior.
        </p>
        <p>
          Dicho proceso de descenso, se realiza
          haciendo uso del hecho, de que la
          representación de cada cierre convexo es una
          lista de puntos, ordenada en sentido
          contrario a las manecillas del reloj.
          <br>
          Este descenso comienza sustituyendo el punto
          actual $pd_j$ en el conjunto convexo derecho,
          por el punto anterior a él $pd_{j-1}$ (el
          siguiente en sentido de las manecillas del
          reloj), siempre y cuando la línea nueva $T$
          resultante esté mas abajo que la anterior
          (para saber eso usamos el valor de
          intersección con la línea vertical), y
          seguiremos sustituyendo este punto hasta que
          no podamos encontrar una $T$ más abajo.
        </p>

      </div>


      <div class="page">
        <p>
          Una vez hayamos "descendido" lo más posible
          sobre el punto del cierre convexo derecho,
          hacemos lo equivalente con el punto del lado
          izquierdo $pi_k$, pero en lugar de cambiar
          con el punto anterior $pi_{k-1}$, cambiamos
          el punto actual por el siguiente en el cierre
          convexo $pi_{k+1}$ (el siguiente en sentido
          contrario a las manecillas del reloj), y
          seguimos cambiando por el siguiente punto
          mientras la $T$ resultante se encuentre más
          abajo que a anterior.
          <br>
          Una vez que ya no sea posible "descender" más
          sobre el cierre convexo izquierdo, repetimos
          el proceso comenzando a descender lo más
          posible sobre el punto del cierre convexo
          derecho y luego sobre el izquierdo, hasta que
          no sea posible descender más en ninguno de los
          dos.
        </p>
        <p>
          La <ref ref_id="ch_merge_algorithm"></ref> muestra como es este algoritmo
          de forma interactiva.
        </p>
        <p>
          De esta manera encontramos la tangente
          inferior, en tiempo $O(n)$ pues la forma en
          la que descendemos nunca da pasos atrás, por
          lo tanto no pasa más de una vez por cada
          punto. Y como ya mencionamos, el proceso para
          encontrar la tangente superior, resulta ser
          análogo. Una vez conociendo cuales son estas
          tangentes, combinar ambos cierres convexos
          resulta trivial, pues solo es cuestión de
          recorrer los cierres convexos que ya
          conocíamos, desde una tangente a otra,
          proceso en el cual visitaríamos a lo más
          todos los puntos en ambos cierres convexos
          una sola vez, lo cual puede ser realizado en
          $O(n)$.
        </p>
        <p>
          Gracias a este algoritmo para unir dos
          conjuntos convexos, reducimos la complejidad que
          teníamos de $O(n^2)$ a $O(n)$.
        </p>
      </div>

      <div class="page">
        <figure id="ch_merge_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/ch_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos de forma eficiente.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por los puntos que son vértices
          del polígono que forma al cierre convexo
          $conv(S)$.
        </p>
        <p>
          Ahora que conocemos la forma de unir dos
          cierres convexos de forma eficiente, podemos
          describir el algoritmo completo, en lo siguientes pasos
          que resultan suficientemente descriptivos.
        </p>

        <h5><span class="bolded">Paso 1. Ordenar los puntos por sus coordenadas en x.</span></h5>
        <br>
        <h5><span class="bolded">
            Paso 2. Dividir los puntos en dos
            conjuntos $I$ y $D$ con la primera mitad de puntos
            y la segunda mitad de puntos
            respectivamente.
          </span></h5>
        <br>
        <h5><span class="bolded">Paso 3. Calcular recursivamente los cierres convexos de $I$ y $D$.</span></h5>
        <br>
        <h5><span class="bolded">Paso 4. Unir $conv(I)$ y $conv(D)$.</span></h5>

      </div>

      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, sin embargo, en
          esta ocasión dividiremos el algoritmo en las
          partes, <span class="bolded">Dividir</span>,
          <span class="bolded">Vencer</span> y <span class="bolded">Combinar</span>, pues el
          presente algoritmo es recursivo, y de esta
          manera describiremos la complejidad usando la
          <a target="_blank" href="https://es.wikipedia.org/wiki/Relación_de_recurrencia#:~:text=La%20conexión%20con">
            relación de recurrencia
          </a>.
        </p>
        <p>
          Antes de empezar dejemos en claro la notación
          para describir la recurrencia, tomaremos a
          $T(n)$ como el tiempo de ejecutar el
          algoritmo para encontrar el cierre convexo de
          $n$ puntos (los cuales asumimos están ordenados
          de forma ascendente respecto al eje $x$), a
          $D(n)$ como el tiempo que toma dividir el
          problema con $n$ puntos en los subproblemas
          necesarios, y a $C(n)$ como el tiempo que
          toma combinar las soluciones de los
          subproblemas para formar la solución del
          problema original.
        </p>
        <p>

        </p>
        <h5><span class="bolded">Dividir.</span></h5>
        <p>
          El paso de dividir solo requiere encontrar
          el punto medio de los puntos ya ordenados,
          lo cual toma tiempo constante. Por lo tanto,
          podemos decir que la complejidad de este paso
          es constante, i.e. $D(n)$ = $O(1)$.
        </p>
        <h5><span class="bolded">Vencer.</span></h5>
        <p>
          Sabemos que en el paso de dividir obtuvimos
          únicamente dos subproblemas de tamaño $n/2$,
          pues dividimos.
          Entonces, podemos describir la complejidad de
          resolver los subproblemas (vencer), como
          $2T(2/n)$ pues son dos subproblemas cada uno de tamaño
          $n/2$.
        </p>
      </div>
      <div class="page">
        <h5><span class="bolded">Combinar.</span></h5>
        <p>
          Gracias al algoritmo ya mencionado para unir
          dos cierres convexos en tiempo $O(n)$ donde
          $n$ es la suma de los tamaños de los cierres
          que combinaremos, podemos decir que que
          complejidad de este paso es lineal, i.e.
          $C(n)$ = $O(n)$.
        </p>
        <br>
        <p>
          Uniendo estas complejidades podemos describir
          a $T(n)$ como:
        </p>
        $T(n) = O(1) + 2T(n/n) + O(n)$
        <p>
          Sin embargo, ya que el termino constante
          resulta no tener mucho peso especialmente al
          incrementar el tamaño de $n$, podemos
          reescribir a $T(n)$ como :
        </p>
        $T(n) = 2T(n/n) + O(n)$
        <p>
          La cual es una relación de recurrencia clásica
          en las ciencias de la computación cuya solución es
          <a target="_blank"
            href="https://www.cs.cornell.edu/courses/cs3110/2014sp/recitations/21/solving-recurrences.html">
            $T(n) = O(nlogn)$
          </a>.
          <br>
          Por lo tanto podemos concluir que la
          complejidad del algoritmo para encontrar el
          cierre convexo de $n$ puntos usando la técnica
          de divide y vencerás es de $O(nlogn)$, pues
          nuestro preprocesamiento de puntos al
          ordenarlos toma $O(nlogn)$ y usando estos
          puntos ordenados la técnica de dividir y
          vencerás también toma $O(nlogn)$.
        </p>

      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_dinamicos">Algoritmos dinámicos</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          Después de haber llegado a la complejidad en
          tiempo $O(nlogn)$ y sabiendo que esta no
          puede ser mejorada, indagar más sobre el
          problema del cierre convexo podría parecer
          sin sentido, pero ¿qué tal si abordamos el
          problema con algunas modificaciones mínimas?.
        </p>
        <p>
          Una modificación bastante interesante al
          problema del cierre convexo es, el algoritmo
          incremental. La idea es ir agregando puntos
          uno por uno, e ir construyendo el cierre
          convexo resultante en cada paso, haciendo uso
          del cierre convexo formado antes de agregar
          el punto actual.
        </p>
        <p>
          Ya que este no es el mismo problema que hemos
          estado estudiando, resulta bastante útil dar
          una mejor descripción del problema, asumiendo
          para simplicidad, que no hay tres puntos que
          sean colineales.
        </p>
        <h4><span class="bolded">Descripción del problema.</span></h4>
        <p>
          Dado una secuencia de $n$ puntos $S = p_0,
          p_1, p_2,\dots, p_{n}$ en el plano, calcular
          su cierre convexo de tal forma que después de
          procesar al punto $p_{i}$ obtengamos al
          cierre convexo del conjunto de puntos $ \{
          p_0, p_1, p_2,\dots, p_{i} \} \ $ esto es
          $ \ conv( \{ p_0, p_1, p_2,\dots, p_{i} \} ) $.
        </p>
      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Para comenzar el algoritmo podemos tomar los
          primeros 3 puntos en la secuencia (esto
          haciendo uso de que no hay 3 puntos que sean
          colineales), pues sabemos que este será
          nuestro primer cierre convexo que formaremos.
          <br>
          Una vez teniendo un cierre convexo $C$, al
          agregar un punto $p_i$ nos deja con dos posibles
          casos: cuando el nuevo punto $p_i$ que
          agregaremos, está contenido en el cierre
          convexo $ p_i \in C$ (recordemos que esto es que el punto
          esté en el área o el perímetro del polígono
          que representa al cierre convexo) o no lo
          está $ p_i \notin C$.
        </p>
        <div class="step">
          <h5><span class="bolded">$p_i \in C$</span></h5>
          <p>
            Si este es el caso, podemos simplemente
            descartar a $p_i$.
            <br>
            ¿Cómo podemos comprobar que en efecto $p_i$
            se encuentra en el cierre convexo actual?
            <br>
            Podemos usar el mismo procedimiento que
            usamos en el <pageref ref_id="graham_step_3">paso 3 del algoritmo
              de Graham</pageref>, para comprobar con cada
            arista en el cierre convexo si el punto $p_i$
            da vuelta derecha o no. Si tomando a cada una
            de las aristas en el cierre convexo actual,
            como la línea dirigida comprobamos que $p_i$
            nunca da una vuelta derecha en alguna arista,
            podemos decir que $p_i$ se encuentra dentro
            del cierre convexo actual.
            <br>
            Este proceso se realiza para todas las
            aristas del cierre convexo actual por lo que
            tomaría una complejidad de $O(n)$.
          </p>
        </div>
        <div class="step">
          <h5><span class="bolded">$p_i \notin C$</span></h5>
          <p>
            Si este es el caso, (cosa que comprobaremos
            revisando si alguna tripleta da vuelta
            derecha, usando el criterio de vuelta
            derecha e izquierda que usamos en el
            algoritmo de Graham, usando dos puntos
            consecutivos en el cierre convexo y al
            punto $p_i$ como
          </p>
        </div>
      </div>
      <div class="page">
        <div class="step">
          <p>
            tripleta), tenemos que añadir a $p_i$ al
            cierre convexo.
          </p>
        </div>
        <p>
          Ahora lo que necesitamos es una forma de unir
          el cierre convexo actual con $p_i$. Si
          recordamos como se realiza la unión de dos
          cierres convexos en el algoritmo divide y
          vencerás, podemos ver que lo único que
          necesitamos es encontrar dos líneas tangentes
          a $p_i$ y después quitar los puntos que ya no
          formen parte del cierre convexo si es que los
          hay.
        </p>
        <p>
          Podemos encontrar las líneas tangentes usando
          el mismo recorrido que usamos para saber si
          $p_i$ está en el cierre convexo actual o no,
          pues justo estos puntos en el cierre convexo
          que forman la tangente son los puntos que
          pertenecen a dos aristas que dan vuelta en
          sentidos opuestos.
          <br>
          La <ref ref_id="cierre_convexo_union_punto"></ref>,
          muestra un ejemplo de esto, en el cual las
          líneas rojas muestran la dirección de la
          vuelta que daría una arista dirigida al punto
          $p$, esto es, de que lado yace el punto $p$
          con respecto a la flecha roja.
        </p>
        <figure id="cierre_convexo_union_punto">
          <img src="./images/capitulo_02/Ejemplo_unir_punto_a_ch.png" width="75%" height="75%">
          <figcaption>Ejemplo que muestra un cierre convexo y un punto exterior a el que se agregará
            al cierre, las líneas tangentes que se deben agregar para formar el nuevo cierre se muestran en amarillo.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Una vez que agregamos al nuevo punto o
          ignoramos dependiendo el caso, estamos
          seguros de que tenemos el cierre convexo para
          los primeros 4 puntos. Para seguir calculando
          el cierre convexo a medida que agregamos
          puntos es suficiente agregar el nuevo punto y
          repetir el mismo procedimiento aplicado
          anteriormente.

        </p>
        <figure id="finding_tangents_with_a_point">
          <div class="interactive" width="810" height="830" window-size="false"
            src="./Interactivos/capitulo_2/ch_merge_point.html">
          </div>
          <figcaption>Ejemplo del recorrido que verifica si un punto está dentro o fuera del
            cierre convexo actual y si está fuera actualiza el cierre convexo.
          </figcaption>
        </figure>
      </div>



      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Calcular el
            cierre convexo para los primeros 3
            puntos.</span></h5>
        <div class="step">
          <p>
            Calcular el cierre convexo de los primeros 3
            puntos en $S$ nos toma tiempo $ \ O(1) \ $
            pues 3 es un número constante y el número de
            operaciones para formar su cierre convexo son
            solo las necesarias para unir a estos puntos.
          </p>
        </div>
        <h5><span class="bolded">Paso 2. Agregar un punto
            y calcular el cierre convexo resultante.</span></h5>
        <div class="step">
          <p>
            La complejidad de agregar un punto nuevo como
            hemos visto resulta ser $O(n)$, pues en el
            peor de los casos recorremos todos los puntos
            que hemos agregado hasta dicha iteración.
            Este segundo paso será ejecutado para cada
            nuevo punto agregado hasta que no falten
            puntos por agregar.
          </p>
        </div>
        <p>
          Por lo tanto podemos concluir que la
          complejidad de ejecutar este algoritmo
          dinámico es de $O(n^{2})$, lo cual a pesar de
          no ser igual de óptimo que el algoritmo no
          dinámico resulta ser más eficiente que la
          idea más simple que podríamos ocupar para
          resolver este problema, la cual sería
          calcular el cierre convexo para cada
          iteración con alguno de los algoritmos con
          complejidad $O(nlogn)$ ya mencionados, que
          nos dejaría una complejidad total de
          $O(n^{2}logn)$.
        </p>
        <p>
          A pesar de esto, sí es posible mejorar la
          complejidad aún más si utilizamos una técnica
          más eficiente que $O(n)$ para insertar, lo
          cual describe
          <a target="_blank"
            href="http://galaxy.cti.gr/dep/sites/default/files/member/zagouras/course-files/p402-preparata.pdf">
            Preparata
          </a>
          mejorando la complejidad de inserción a
          $\theta(logn)$ y así la complejidad total a
          $O(nlogn)$. Sin embargo, dicho algoritmo
          resulta bastante más complejo por lo cual no
          será abarcado en estas notas.
        </p>
      </div>



      <div class="page">
        <h2 id="cap2_extensiones_variantes">Extensiones y variantes</h2>
      </div>

      <div class="page">
        <h2 id="cap2_cota_minima">Cota mínima</h2>
        <p>
          Después de ver distintos algoritmos que nos sirven para encontrar el cierre convexo, es natural
          preguntarnos, ¿podemos encontrar un algoritmo aún mejor en cuanto a complejidad en tiempo?
          <br>
          La respuesta es sencilla es no, y en esta sección ahondaremos un poco más en como
          es que podemos estar seguros de esto.
        </p>
        <p>
          Después de haber revisado los
          algoritmos anteriores, sabemos que la
          complejidad para calcular el cierre
          convexo es $O(nlogn)$, ¿cómo podemos
          demostrar que es lo mejor que podemos hacer?,
          para hacerlo deberíamos poder demostrar que
          $O(nlogn)$ es una cota inferior que se cumple
          para cualquier algoritmo que podamos pensar,
          y esto no es una tarea fácil, sin embargo,
          podemos
          <a target="_blank" href="https://en.wikipedia.org/wiki/Reduction_(complexity)">reducir</a>
          el problema de ordenamiento al problema de
          calcular el cierre convexo en tiempo lineal,
          pues sabemos que el problema de ordenamiento
          cuenta con una cota inferior
          de $\Omega (nlogn)$.
        </p>
        <p>
          La reducción se puede realizar de la
          siguiente manera. Supongamos que tenemos $k$
          números reales $n_1, \dots, n_k \in
          \mathbb{R}$, los cuales queremos ordenar. A
          partir de estos números construyamos un
          conjunto de puntos $S = p_0, p_1, p_2,\dots,
          p_{k}$ donde cada punto este definido como
          $p_i = (n_i, n_{i}^{2})$, lo cual corresponde
          a tomar cada número y mapearlo a un punto
          sobre el eje $x$, y a su vez este punto
          trasladarlo verticalmente al punto sobre la
          parabola unitaria que tiene la misma
          coordenada en $x$, como se muestra en la <ref ref_id="lower_bound_1"></ref>. Como se puede
          apreciar en la <ref ref_id="lower_bound_2"></ref>, el orden en el
          que los puntos aparecen en el cierre convexo
          inferior es justo el orden de los números
          $n_{i}$.
        </p>
      </div>

      <div class="page">
        <br>
        <figure id="lower_bound_1">
          <img src="./images/capitulo_02/Ejemplo_cota_inferior.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo del mapeo de un número $n_i$ al punto $(n_i,
            n_{i}^{2})$.
          </figcaption>
        </figure>
        <br>
        <figure id="lower_bound_2">
          <img src="./images/capitulo_02/Ejemplo_cota_inferior_cierre.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo obtener el cierre convexo del ejemplo anterior del mapeo.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Como podemos notar los puntos caen en una
          parabola, por lo que después de ejecutar
          nuestro algoritmo para calcular el cierre
          convexo en tiempo $T(n)$, todos los puntos se
          encuentran en el resultado, posteriormente
          buscamos al punto $p_0$ con la coordenada $x$ más
          pequeña, en tiempo $O(n)$, y ya que sabemos
          que nuestro algoritmo nos devuelve los puntos
          en orden contrario a las manecillas del
          reloj, los puntos a partir de $p_0$ están
          ordenados, podemos recorrerlos en $O(n)$,
          para finalmente obtener los números en $X$
          ordenados.
        </p>
        <p>
          Nos basta con hacer esto, pues, si tenemos un
          algoritmo con complejidad $T(n)$ para
          calcular el cierre convexo, entonces
          podríamos tener un algoritmo con complejidad
          $O(n) + T(n)$ para ordenar. Pero como sabemos que
          no podemos tener un algoritmo menor a
          $O(nlogn)$ para ordenar, esto nos resultaría
          en una contradicción, lo que nos deja con el
          algoritmo de calcular el cierre convexo con
          la misma cota inferior al algoritmo de
          ordenamiento.
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_bib">Bibliografía</h2>

        <bibref ref_id="CG_an_Introduction">Pag. 106</bibref>

        <bibitem id="CG_in_C">
          O'Rourke, Joseph. <b>Computational Geometry In C.
          </b> Cambridge University Press, February 15, 2001.
        </bibitem>

        <bibitem id="Discrete_and_CG">
          Satyan L. Devadoss, Joseph O'Rourke. <b>
            Discrete and Computational geometry. </b>
          Princeton University Press, 2011
        </bibitem>

        <bibitem id="CG_an_Introduction">
          Franco P. Preparata, Michael Ian Shamos. <b>
            Computational Geometry An Introduction </b>
          Springer-Verlag New York Inc, 1985
        </bibitem>

        <bibitem id="CG_an_Introduction">
          Preparata, F.P. <b>
            An optimal real-time algorithm for planar
            convex hulls
          </b> Commun. ACM, 22, 402-405. 1979
        </bibitem>
        https://en.wikipedia.org/wiki/Reduction_(complexity) (20/09/22)
      </div>

      <!--  -->
      <!-- CAPITULO 3: INTERSECCIÓN DE SEGMENTOS -->
      <!--  -->
      <div class="page">

        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="intersecciones_segmentos">Intersecciones entre segmentos de rectas</h1>
          <h1 class="chap_num">3</h1>
        </div>
        <p>
          El problema que se abordará en este capítulo
          es la intersección de segmentos de rectas,
          pero antes de comenzar, necesitamos tener en
          claro que significa esto y definir qué es una
          intersección.
        </p>
        <p>


          Definición de intersección

          TO DO: Añadir imágenes que muestren las intersecciones.
        </p>

      </div>

      <div class="page">
        <h2 id="cap3_deteccion">Detección</h2>
        <p>
          Ahora que tenemos bien definido nuestro
          problema podemos comenzar a pensar en una
          solución.
        </p>
        <p>
          Como primer acercamiento podemos comparar
          cada segmento de línea en el conjunto $S$
          contra todos los demás, lo cual es una buena
          idea, pues nos permite calcular todas las
          intersecciones entre los segmentos, además de
          que su complejidad es de $O(n^{2})$, lo cual,
          si pensamos detenidamente, es lo mejor que
          podemos hacer en el peor de los casos, esto
          es, cuando todos los segmentos se intersectan
          entre sí, pues justamente estamos revisando
          todas las intersecciones que puede haber
          entre los segmentos de línea en $S$.
        </p>
        <p>
          Listo, entonces hemos terminado, ¿o no?.
          <br>
          Es verdad que en situaciones donde tenemos
          que lidiar con el peor escenario no podemos
          reducir el número de comparaciones, sin
          embargo, en aplicaciones reales, dicho caso
          es poco común y resultaría bastante
          conveniente tener un algoritmo que sea más
          eficiente si el número de
          intersecciones es menor.
        </p>


      </div>

      <div class="page">

        <h2 id="cap3_algoritmos">Algoritmo</h2>
        TO DO: sweep line algorithm description and interactive resource.

        <h2 id="cap3_lista_doblemente_ligada">Lista doblemente conexa de aristas</h2>
        <h2 id="cap3_calculando_traslape">Calculando el traslape de dos subdivisiones</h2>
      </div>


      <!--  -->
      <!-- CAPITULO 4: TRIANGULACIÓN Y VISIBILIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="triangulacion_divisibilidad">
            Triangulación de polígonos y visibilidad
          </h1>
          <h1 class="chap_num">4</h1>
        </div>
        <p>
          Para comenzar con el problema de la
          triangulación de polígonos, antes tomaremos
          en cuenta un problema racionado con ello.
          <br>
          Dicho problema suele ser llamado el problema
          de la galería de arte, el cual describiremos
          a continuación.
        </p>
        <p>
          Supongamos que queremos resguardar las
          valiosas piezas de una galería de arte, y
          para ello usaremos cámaras para vigilar
          cada parte de la galería fácilmente, dichas
          cámaras pueden rotar para abarcar un area
          más grande, sin embargo nos interesaría
          poder hacer uso de las menos cámaras
          posibles, ya que, todas estas serían
          transmitidas a un conjunto de pantallas que
          una persona se encargaría de vigilar, y
          resulta menos problemático vigilar solo una
          cantidad reducida de pantallas. Sin
          embargo, no podemos tener tan pocas cámaras
          al punto que no podamos vigilar cada area
          de la galería.
          <br>
          Entonces, lo que queremos es
          saber cual sería el menor número de cámaras
          necesarias para vigilar toda la galería,
          además, dado que dependiendo de donde se
          pone cada cámara puede vigilar una area
          distinta, también queremos saber, en que
          partes de la galería poner dichas cámaras.
        </p>
        <h2 id="cap4_vigilancia_triangulaciones">Vigilancia y triangulaciones</h2>
        <p>
          Ya tenemos la idea del problema que queremos
          resolver, ahora veamos que tiene que ver
          este problema con las triangulaciones de
          polígonos.
        </p>
      </div>

      <div class="page">
        <p>
          Para comenzar, podemos abstraer una galería
          de arte a un polígono en 2 dimensiones y
          trabajar sobre este polígono, pues podemos
          ver a la galería como un plano de la misma y
          sobre este buscar los puntos donde poner las
          cámaras.
        </p>

        <!-- https://thetourguy.com/travel-blog/france/paris/louvre/top-ten-things-to-see-at-the-louvre-museum/
        17/11/2022 imagen louvre -->
        <figure id="poligono_condiciones">
          <img src="./images/capitulo_04/Map_Great-Sphinx-of-Tanis_Louvre_The-Tour-Guy-750x420.jpg" width="90%"
            height="90%">
          <figcaption>Ejemplo de un plano del
            famoso museo louvre.</figcaption>
        </figure>

        <p>
          Sin embargo, para motivos de estas notas, no
          trabajaremos polígonos como este plano del
          museo Louvre, ya que nos limitaremos a
          trabajar con
          <span class="bolded">polígonos simples</span>
          (que no hace intersección consigo mismo y no
          tiene agujeros).
        </p>
        <p>
          Ahora que tenemos una abstracción para las
          galerías, ¿qué hay de las cámaras? Estas las
          podemos representar con un punto que esté
          dentro del polígono.
        </p>
        <p>
          Además, diremos que esta cámara puede vigilar
          todos los puntos en el polígono a los que
          pueda trazar un segmento de tal manera que
          dicho segmento esté contenido totalmente en
          el polígono.
          <br>
          En la <ref ref_id="camara"></ref> se muestra
          un ejemplo de esto.
        </p>
      </div>

      <div class="page">
        <figure id="camara">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_4/intuitive_idea_Camera.html"></div>
          <figcaption>Ejemplo de la idea de una cámara
            (punto) en una galería (polígono simple) y el
            area que puede vigilar (area
            blanca).</figcaption>
        </figure>
        <p>
          Ahora que tenemos estas abstracciones,
          podemos preguntarnos, ¿cuántas cámaras
          necesitamos para vigilar totalmente un
          polígono simple? Podemos hablar de este
          número de cámaras en términos del número de
          aristas de nuestro polígono, sin embargo, no
          nos podemos guiar unicamente por el número de
          vertices ya que a pesar de que calcular el
          número de cámaras para polígonos convexos no
          implica mayor dificultad, ya que pueden ser
          vigilados en su totalidad por una sola
          cámara, el número de vertices no nos dice
          mucho para cualquier polígono no convexo.
          <br>
          De hecho, el calcular el número mínimo
          necesario de cámaras necesarias para vigilar
          un polígono simple es un problema
          <a
            href="https://es.wikipedia.org/wiki/NP-hard#:~:text=En%20teoría%20de%20la%20complejidad,ser%20transformado%20polinomialmente%20en%20H.">
            <b>NP-Difícil</b>
          </a>.
        </p>
        <p>
          A pesar de que no podemos obtener la mejor
          solución del problema, podemos calcular una muy buena
          solución al problema haciéndolo más fácil,
          descomponiendo el polígono en piezas más
          pequeñas.

        </p>
      </div>
      <div class="page">
        <p>
          ¿Cómo podríamos descomponer el polígono en
          piezas más pequeñas? Sabemos que los
          polígonos convexos solo requieren una cámara
          para ser vigilados por lo que nos resultaría
          util trabajar con polígonos convexos, sin
          embargo, para hacer la descomposición aún más
          simple, descompondremos el polígono en
          triángulos.
          <br>
          Aquí es donde entra la triangulación de polígonos,
          pero antes de abordarla, definamos que es una diagonal.
        </p>
        <p>
        <h4><span class="bolded">Diagonal.</span></h4>
        Es un segmento de línea recta que conecta dos
        vértices no contiguos de un polígono $P$ tal que cada
        punto este segmento yace completamente dentro
        de $P$.
        </p>
        TO DO: Ejemplos de que sí es y que no es una diagonal
        <p>
        <h4><span class="bolded">Triangulación de un polígono.</span></h4>
        Es una descomposición de un polígono en un
        conjunto de triángulos por un conjunto
        maximal de diagonales que no se intersectan
        entre ellas.
        </p>
      </div>
      <div class="page">
        <p>
          Las triangulaciones no suelen ser únicas,
          como se puede apreciar en la Figura (TODO),
          sin embargo, esto nos importa, dado que
          teniendo alguna triangulación, podemos
          colocar una cámara en cada triangulo para
          poder resolver nuestro problema.
        </p>
        TODO Figura con al menos dos triangulaciones distintas
        <p>
          Lo que realmente nos interesa, es saber si
          siempre es posible encontrar alguna
          triangulación para cualquier polígono simple.
          La respuesta es sí, además, si el polígono
          simple tiene $n$ vertices, el número de triángulos
          que resultantes son $n - 2$.
        </p>
        <p>
        <div class="bolded">
          De todo polígono simple se puede obtener una
          triangulación, y cualquier triangulación de
          un polígono simple de $n$ vertices consistirá
          de $n - 2$ vertices.
        </div>
        </p>
        <div class="bolded">
          Caso Base: $n = 3$ (triangulo)
        </div>
        <p>
          En este caso el triangulo ya está triangulado por definición
          y para sus $n = 3$ lados, contiene $n - 2 = 3 - 2 = 1$ un triángulo.
        </p>
        TO DO: imagen triangulo

        <div class="bolded">
          Hipótesis de inducción
        </div>
        <p>
          Supongamos que para un polígono con $n = k$ su triangulación
          existe y tiene $k - 2$ triángulos.
        </p>

        <div class="bolded">
          Paso inductivo: demostrar para $n = k + 1$
        </div>
        <p>
          Tomar al vértice más a la izquierda $v$, tomamos a los vertices $u$ y $w$
          que comparten arista con $v$, y trazamos un segmento de recta de $u$ a $w$.

          Dos casos, $\overline{uw}$ es diagonal o no.
          TODO imágenes de ejemplo si es diagonal y si no lo es.
        </p>
      </div>
      <div class="page">
        <p></p>
      </div>
      <div class="page">
        <h2 id="cap4_dividiendo_polígono">Dividiendo un
          polígono en piezas monótonas</h2>
        <h2 id="cap4_triangulando_polígono">Triangulando un
          polígono monótono</h2>
        <h2 id="cap4_calcular_grafica_divisibilidad">Calcular
          la gráfica de visibilidad</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 5: PROGRAMACIÓN LINEAL -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="programacion_lineal">Programación lineal</h1>
          <h1 class="chap_num">5</h1>
        </div>

        <h2 id="cap5_geometria_amoldado">La geometría de amoldado</h2>
        <h2 id="cap5_interseccion_semiplanos">Intersección de semiplanos</h2>
        <h2 id="cap5_circulo_contenedor">Círculo contenedor de radio mínimo</h2>
        <h2 id="cap5_programacion_lineal_incremental">Programación lineal incremental</h2>
        <h2 id="cap5_programacion_lineal_aleatoria">Programación lineal aleatoria</h2>
        <h2 id="cap5_programacion_lineal_dimensiones">Programación lineal en dimensiones superiores</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 6: BÚSQUEDA DE RANGOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="busqueda_rangos">Búsqueda de rangos ortogonales</h1>
          <h1 class="chap_num">6</h1>
        </div>

        <h2 id="cap6_busqueda_una_dimension">Búsqueda en una dimensión</h2>
        <h2 id="cap6_arboles_kd">Árboles Kd</h2>
        <h2 id="cap6_arboles_rangos">Árboles de rangos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 7: LOCALIZACIÓN DE PUNTOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="localizacion_puntos">Localización de puntos</h1>
          <h1 class="chap_num">7</h1>
        </div>

        <h2 id="cap7_localizacion_punto_subdivision">Localización de un punto en una subdivisión plana</h2>
        <h2 id="cap7_metodo_bandas">Método de bandas</h2>
        <h2 id="cap7_metodo_cadena">Método de cadena</h2>
        <h2 id="cap7_metodo_trapezoidal">Método trapezoidal</h2>
        <h2 id="cap7_algoritmo_incremental">Algoritmo incremental aleatorio</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 8: DIAGRAMAS DE VORONOI -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="diagramas_voronoi">Diagramas de Voronoi</h1>
          <h1 class="chap_num">8</h1>
        </div>

        <h2 id="cap8_definicion_propiedades">Definición y propiedades básicas</h2>
        <h2 id="cap8_construyendo_diagrama">Construyendo el diagrama de Voronoi</h2>
        <h2 id="cap8_cota_minima">Cota mínima</h2>
        <h2 id="cap8_diagramas_voronoi">Diagramas de Voronoi de orden superior</h2>
        <h2 id="cap8_aplicaciones">Aplicaciones</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 9: ARREGLOS DE LINEAS Y DUALIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="arreglos_lineas_dualidad">Arreglos de líneas y dualidad</h1>
          <h1 class="chap_num">9</h1>
        </div>

        <h2 id="cap9_arreglos">Arreglos de líneas</h2>
        <h2 id="cap9_dualidad">Dualidad</h2>
        <h2 id="cap9_triangulacion_delaunay">Triangulación de Delaunay</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 10: PROXIMIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="proximidad">Proximidad</h1>
          <h1 class="chap_num">10</h1>
        </div>

        <h2 id="cap10_puntos_cercanos_lejanos">Par de puntos más cercanos y más lejanos</h2>
        <h2 id="cap10_arboles_generadores_minimos">Árboles generadores mínimos euclidianos</h2>
        <h2 id="cap10_agente_viagero">El problema del agente viajero euclidiano</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 11: ESTRUCTURAS DE DATOS GEOMÉTRICAS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="estructuras_datos_geometricas">Algunas estructuras de datos geométricas</h1>
          <h1 class="chap_num">11</h1>
        </div>

        <h2 id="cap11_arboles_intervalos">Árboles de intervalos</h2>
        <h2 id="cap11_arboles_prioridades_busqueda">Árboles de prioridades y búsqueda</h2>
        <h2 id="cap11_arboles_segmentos">Árboles de segmentos</h2>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>


      <!--  -->
      <!-- <div class="page">
        <iframe src="https://youtu.be/EzeYI7p9MjU?t=2135"
          frameborder="0" allowtransparency="true" allow="encrypted-media" style="width:100%;height:400px"></iframe>
      </div> -->

      <!--  -->
      <div class="page">

      </div>

      <!--  -->
      <div class="page invertcolor" num=""
        style="background-image: radial-gradient(white, #ecf0f1, #e3e5e7); display:flex; align-items:center; justify-content:center;">
        <a style="width:50%" target="_blank" href="http://descartes.matem.unam.mx/"><img
            src="images/general/logo_descartes.svg" width="100%"></a>
      </div>
    </div>

    <!-- [cierra] pages_container -->
  </div>
  <!-- [cierra] book_container -->
  </div>

</body>

</html>