<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=yes,minimal-ui">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <title>Notas para el curso Geometría Computacional</title>

  <!-- configuración del libro -->
  <script>
    window.book_config = {
      // parámetro que indica si los capítulos, secciones y figura se auto numeran
      // para que los capítulos se auto numeren deben utilizar la etiqueta <h1>
      // para que las secciones se auto numeren deben utilizar la etiqueta <h2>
      auto_numerate_sections_and_figures: true,
      remember_last_page: true,
    }
  </script>

  <!-- núcleo del libro interactivo -->
  <link rel="stylesheet" href="book/css/style.css" type="text/css">
  <script type="text/javascript" src="book/js/book.js" charset="utf-8"></script>

  <!-- personalización del usuario -->
  <link rel="stylesheet" href="extra/fonts.css" type="text/css">
  <link rel="stylesheet" href="extra/style.css" type="text/css">

  <!-- Bibliotecas para interactivos p5js -->
  <script src="libraries/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>

  <!-- inclusión de la biblioteca KaTex -->
  <link rel="stylesheet" type="text/css" href="extra/katex/katex.min.css" />
  <script src="extra/katex/katex.min.js"></script>
  <script src="extra/katex/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }, { left: "\\[", right: "\\]", display: true }, { left: "\\(", right: "\\)", display: false }]
      });
    });
  </script>
</head>

<body>
  <div id="book_loader_container">
    <div id="book_loader"></div>
  </div>

  <div id="book_container">
    <div id="btn_back_page"></div>
    <div id="btn_next_page"></div>
    <button id="go_to_table_of_content"></button>

    <button id="btn_config"></button>
    <div id="config_options">
      <div id="dark_light_mode"></div>
    </div>

    <!-- si este elemento no esta presente, el botón de la tabla de contenido lleva a la primera página con un elemento class="toc_link" -->
    <div id="table_of_content"></div>

    <div id="pages_container">
      <!--  -->
      <div class="page" style="background-color:transparent;"></div>

      <!-- Portada -->
      <div class="page invertcolor"
        style="margin:0; padding:0; background-size:contain; background-image:url(images/general/portada.svg);">
        <div class="cover_title">Notas para el curso</div>
        <div class="cover_subtitle">Geometría Computacional</div>
      </div>

      <!--  -->
      <div class="page" style="display:flex; align-items:center; justify-content:center;">VACÍA</div>

      <!--  -->
      <!-- init-page-num="true" es un parámetro que indica que a partir de esta página comienza la numeración -->
      <!-- inicialmente los números de las páginas se numeran con numerales romanos -->
      <!-- num="" es un parámetro que indica que esta página no lleva numeración visible -->
      <!--  -->
      <div class="page" init-page-num="true" style="text-align:right; font-size:120%;" num="">
        <br>
        <p><b style="font-size:150%;">Notas para el curso Geometría Computacional</b></p>

        <br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <p style="text-align:right; margin:0;">
          <br>
          <b>Edgar Samuel Perea Domínguez</b>
          <br><br>
          Universidad Nacional Autónoma de México
        </p>

      </div>

      <!--  -->
      <div class="page" num="">
        <p>
          Título de la obra:
          <br>
          Notas para el curso Geometría Computacional
        </p>
        <br>

        <p>
          Autores:
          <br>
          Edgar Samuel Perea Domínguez
        </p>
        <br><br>

        <p>
          Código JavaScript para el libro: <a target="_blank" href="https://github.com/jlongi/libro_interactivo"
            target="_blank">Joel
            Espinosa Longi</a>, <a target="_blank" href="https://www.matem.unam.mx/" target="_blank">IMATE</a>, UNAM.
          <br>
          Recursos interactivos: <a target="_blank" href="http://descartes.matem.unam.mx/"
            target="_blank">DescartesJS</a>
          <br>
          Fuentes: <a target="_blank" href="https://fonts.google.com/specimen/Lato" target="_blank">Lato</a> y <a
            href="https://fonts.google.com/specimen/Ubuntu+Mono" target="_blank">UbuntuMono</a>
        </p>
        <br>

        <p>
          DATOS DE LA EDICIÓN
        </p>
        <br><br>

        <p>
        <p>LICENCIA</p>
        <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank"><img
            src="images/general/by-nc-sa.svg" style="height:1.75em; margin-right:0.75em;"></a>
        <p>El contendido de esta obra esta bajo una licencia <a
            href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank">Creative Commons
            (Atribución-NoComercial-CompartirIgual)</a>.</p>
        </p>
      </div>

      <!-- Indice -->
      <div class="page">
        <h2>Tabla de contenido</h2>

        <!-- con esto se agrega una entrada en la tabla de contenido,
        href="#prefacio" indica una referencia a una elemento html con 
        el parámetro id="prefacio", automáticamente se busca está referencia
        y se agrega el título correspondiente y la página donde se encuentra -->

        <div class="toc_link" href="#prefacio"></div>

        <!-- Capitulo 1 -->
        <div class="toc_link" href="#introduccion"></div>
        <div class="toc_link" href="#cap1_definiciones_generales"></div>
        <div class="toc_link" href="#cap1_repaso_estructuras_datos"></div>
        <div class="toc_link" href="#cap1_preliminares_geometricos"></div>

        <!-- Capitulo 2 -->
        <div class="toc_link" href="#cierre_convexo"></div>
        <div class="toc_link" href="#cap2_cota_minima"></div>
        <div class="toc_link" href="#cap2_algorithmo_grahan"></div>
        <div class="toc_link" href="#cap2_algoritmo_jarvis"></div>
        <div class="toc_link" href="#cap2_algoritmos_divide_venceras"></div>
        <div class="toc_link" href="#cap2_algoritmos_dinamicos"></div>
        <div class="toc_link" href="#cap2_extensiones_variantes"></div>

        <!-- Capitulo 3 -->
        <div class="toc_link" href="#intersecciones_segmentos"></div>
        <div class="toc_link" href="#cap3_deteccion"></div>
        <div class="toc_link" href="#cap3_algoritmos"></div>
        <div class="toc_link" href="#cap3_lista_doblemente_ligada"></div>
        <div class="toc_link" href="#cap3_calculando_traslape"></div>
        <div class="toc_link" href="#cap3_barrido_topologico"></div>
        <div class="toc_link" href="#cap3_ordenando_pendientes"></div>

        <!-- Capitulo 4 -->
        <div class="toc_link" href="#triangulacion_divisibilidad"></div>
        <div class="toc_link" href="#cap4_vigilancia_triangulaciones"></div>
        <div class="toc_link" href="#cap4_dividiendo_polígono"></div>
        <div class="toc_link" href="#cap4_triangulando_polígono"></div>
        <div class="toc_link" href="#cap4_calcular_grafica_divisibilidad"></div>

      </div>

      <div class="page">
        <!-- Capitulo 5 -->
        <div class="toc_link" href="#programacion_lineal"></div>
        <div class="toc_link" href="#cap5_geometria_amoldado"></div>
        <div class="toc_link" href="#cap5_interseccion_semiplanos"></div>
        <div class="toc_link" href="#cap5_circulo_contenedor"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_incremental"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_aleatoria"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_dimensiones"></div>

        <!-- Capitulo 6 -->
        <div class="toc_link" href="#busqueda_rangos"></div>
        <div class="toc_link" href="#cap6_busqueda_una_dimension"></div>
        <div class="toc_link" href="#cap6_arboles_kd"></div>
        <div class="toc_link" href="#cap6_arboles_rangos"></div>

        <!-- Capitulo 7 -->
        <div class="toc_link" href="#localizacion_puntos"></div>
        <div class="toc_link" href="#cap7_localizacion_punto_subdivision"></div>
        <div class="toc_link" href="#cap7_metodo_bandas"></div>
        <div class="toc_link" href="#cap7_metodo_cadena"></div>
        <div class="toc_link" href="#cap7_metodo_trapezoidal"></div>
        <div class="toc_link" href="#cap7_algoritmo_incremental"></div>

        <!-- Capitulo 8 -->
        <div class="toc_link" href="#diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_definicion_propiedades"></div>
        <div class="toc_link" href="#cap8_construyendo_diagrama"></div>
        <div class="toc_link" href="#cap8_cota_minima"></div>
        <div class="toc_link" href="#cap8_diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_aplicaciones"></div>
      </div>

      <div class="page">
        <!-- Capitulo 9 -->
        <div class="toc_link" href="#arreglos_lineas_dualidad"></div>
        <div class="toc_link" href="#cap9_arreglos"></div>
        <div class="toc_link" href="#cap9_dualidad"></div>
        <div class="toc_link" href="#cap9_triangulacion_delaunay"></div>

        <!-- Capitulo 10 -->
        <div class="toc_link" href="#proximidad"></div>
        <div class="toc_link" href="#cap10_puntos_cercanos_lejanos"></div>
        <div class="toc_link" href="#cap10_arboles_generadores_minimos"></div>
        <div class="toc_link" href="#cap10_agente_viagero"></div>

        <!-- Capitulo 11 -->
        <div class="toc_link" href="#estructuras_datos_geometricas"></div>
        <div class="toc_link" href="#cap11_arboles_intervalos"></div>
        <div class="toc_link" href="#cap11_arboles_prioridades_busqueda"></div>
        <div class="toc_link" href="#cap11_arboles_segmentos"></div>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- num-type-arabic="true" es un parámetro que indica que a partir de esta página la numeración utilizara numerales arábigos -->
      <!--  -->
      <div class="page" num-type-arabic="true">
        <h1 id="prefacio">Prefacio</h1>

        <p>
          Este es un ejemplo sin contenido para
          comenzar la creación de un libro interactivo.
        </p>
      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="introduccion">Introducción</h1>
          <h1 class="chap_num">1</h1>
        </div>
        <p>
          El objetivo de esta sección será refrescar o
          introducir, los conceptos que se consideran
          básicos o necesarios, para que el lector
          pueda comprender con mayor facilidad los
          temas que se abordarán en el resto del libro,
          además de adoptar una notación para los
          mismos.
        </p>
        <p>
          Es por ello que, solamente formarán parte de
          esta sección las definiciones básicas, las
          definiciones que puedan ser más complejas
          serán presentadas en los capítulos
          correspondientes.
        </p>
        <p>
          Ya que es bastante común que en el estudio de
          la <span class="bolded">Geometría computacional</span>, se
          aborden temas que hacen uso de conjuntos de
          puntos en un espacio euclidiano, es necesario
          saber representar a estos puntos.<br>
          Sin embargo, resulta claro que no es
          suficiente con solo saber representar puntos,
          pues, los objetos geométricos que se estudian
          o de los que se hace uso para estudiar la
          <span class="bolded">Geometría computacional</span>, a
          pesar de no que necesitan consistir de un
          número finito de puntos, sí resulta necesario
          que tengan una especificación finita.
          <br>
          Es por eso que, además de considerar
          <span class="bolded">puntos</span>
          individuales, se consideran elementos más
          complejos, tales como,
          <span class="bolded">líneas rectas</span>, <span class="bolded">segmentos
            de líneas rectas</span>,
          <span class="bolded">planos</span>,
          <span class="bolded">polígonos</span>, etcétera, cuyas
          definiciones y/o conceptos básicos serán
          presentados en la primer parte del capítulo
          actual.
        </p>
      </div>

      <div class="page">
        <p>
          Adicionalmente, para el uso de algoritmos
          geométricos es necesario manipular
          estructuras que no son manejadas a nivel de
          lenguaje de máquina. Por lo que es necesario
          implementar y/o utilizar diversas estructuras
          de datos, de las cuales las más comúnmente
          utilizadas son los conjuntos y los conjuntos
          ordenados, pero resulta claro comprender que
          estas no son las únicas utilizadas. Sin
          embargo en este capítulo solo se mencionarán
          las que se consideran necesarias, teniendo en
          cuenta que el lector ya cuenta con
          conocimientos de las estructuras de datos más
          básicas.
        </p>
      </div>
      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!-- Parte 1: Definiciones generales -->
      <!--  -->
      <div class="page">
        <h2 id="cap1_definiciones_generales">Definiciones generales.</h2>
        <p>
          Para comenzar, denotaremos como
          $\mathbb{R}^d$ al espacio euclídeo
          d-dimensional, esto es, el espacio de
          d-vectores $(x_1 , \dots , x_d)$ de números
          reales $\ x_i, \ i = 1, … , d\ $ con
          <a target="_blank" href="https://en.wikipedia.org/wiki/Metric_(mathematics)">
            métrica
          </a>
          $( \sum^{d}_{i=1} x^{2}_{i})^{1/2}$.
        </p>
        <p>
          Dada esta definición podemos continuar con
          las que resultan más indispensables para el
          estudio de la geometría computacional.
        </p>
        <!-- PUNTO -->
        <h4><span class="bolded">Punto.</span></h4>
        <p>
          Un vector con $d$ componentes $(x_1 , \dots ,
          x_d)$ aplicado en el origen de $\mathbb{R}^d$
          denota un
          <span class="bolded">punto</span> $p$ en $\mathbb{R}^d$.
        </p>
        <p>
          En la <ref ref_id="ejemplo_punto"></ref> se muestra un interactivo
          en el cual se representa un punto en el
          espacio en $\mathbb{R}^2$, al cual podemos
          cambiar sus valores en cada uno de sus
          componentes.
        </p>
        <figure id="ejemplo_punto">
          <div class="interactive" width="400" height="200"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_punto.html"></div>
          <figcaption>Ejemplo de punto en $\mathbb{R}^2$.</figcaption>
        </figure>
      </div>

      <div class="page">
        <!-- LINEA -->
        <h4><span class="bolded">Línea.</span></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, el conjunto de todos los
          puntos $r$ que satisfacen

          \[ r = \alpha \ p_1
          + (1 -\alpha ) p_2 \qquad ( \alpha \in
          \mathbb{R} ) \]

          describe una
          <span class="bolded">línea</span> en $\mathbb{R}^d$.
        </p>
        <p>
          A pesar de que un solo par de puntos
          distintos definen perfectamente una línea,
          una línea en $\mathbb{R}^d$ contiene un
          número infinito de puntos. Lo cual puede
          apreciarse en la <ref ref_id="linea"></ref>, en el cual las
          flechas azul y verde, representan la partes
          respectivas que aportan los puntos $p_2$ y
          $p_1$ al nuevo punto $r$ respectivamente.
          <br> De esta manera, al cambiar el valor de
          $\alpha$ podemos obtener cualquier punto
          sobre la línea roja.
        </p>

        <figure id="linea">
          <div class="interactive" width="500" height="300" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_linea.html"></div>
          <figcaption>
            Ejemplo de definición de
            línea.
          </figcaption>
        </figure>

      </div>
      <div class="page">
        <!-- Segmento de línea-->
        <h4><span class="bolded">Segmento de línea.</span></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, si a la definición anterior
          agregamos la condición $ \ 0 \leq \alpha \leq
          1 \ $, esto es \[ r = \alpha \ p_1 + (1
          -\alpha ) p_2 \qquad ( 0 \leq \alpha \leq 1 )
          \] el conjunto de todos los puntos que
          satisfacen dicha definición, describe el
          <span class="bolded">segmento de línea</span>
          recta que une los dos puntos $ \ p_1 \ $ y $
          \ p_2 \ $ en $\mathbb{R}^d$. Normalmente este
          <span class="bolded">segmento de línea</span>
          se denota como $ \ \overline{ p_1 p_2}$.
        </p>
        <p>
          La <ref ref_id="segmento_de_linea"></ref> muestra un
          interactivo que funciona de la misma manera
          al presentado en la <ref ref_id="linea"></ref>, el cual muestra la
          definición de línea, sin embargo se puede
          notar como en este recurso el valor de
          $\alpha$ cumple la condición $( 0 \leq \alpha
          \leq 1 )$, lo cual nos limita a solo poder
          representar puntos que están sobre la línea y
          a su vez entre los puntos $ p_1 p_2 $.
        </p>
        <figure id="segmento_de_linea">
          <div class="interactive" width="500" height="280" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_segmento.html"></div>
          <figcaption>
            Ejemplo de definición de segmento
            de línea.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <!-- Polígono-->
        <h4><span class="bolded">Polígono.</span></h4>
        <p>
          En $\mathbb{R}^d$ un
          <span class="bolded">polígono</span> $P$, es
          la región cerrada del plano, acotada por una
          colección finita de segmentos de línea,
          formando una <span class="bolded">curva
            cerrada simple</span>.
          <br>
          Ya que puede ser complejo explicar el
          significado de
          <span class="bolded">curva cerrada simple</span>, podemos
          abordar la definición de la siguiente manera,
          para poderlo explicar de una forma más
          sencilla.
        </p>
        <p>
          Sean $ \ v_0, v_1, v_2,\dots, v_{n-1} $, $n$
          puntos en el plano. Sean $ e_0 = $
          $ \overline{v_0 v_1}, \ e_1 = $
          $ \overline{v_1 v_2}, \ \ \dots \ ,e_i =$
          $ \overline{v_{i} v_{i+1}}, \ \dots$
          $, e_{n-1} = \overline{v_{n-1} v_{0}} $;
          $n - 1$ segmentos conectando los
          puntos, estos segmentos delimitan un
          <span class="bolded">polígono</span>
          si y solo si:
        </p>
        <ol>
          <li>
            La intersección de cada par de segmentos
            adyacentes en el ciclo ordenado es el único
            punto que comparten entre ellos:
            <br>
            $ e_i \cap e_{i+1} = v_{i+1, \ }$ para todo
            $i = 0, \dots, n - 1$.
          </li>
          <li>
            Los segmentos no adyacentes no se
            intersectan:
            <br>
            $ e_i \cap e_{j} = \emptyset, \ $ para todo
            $j \neq i - 1$.
          </li>
        </ol>

        <figure id="poligono_condiciones">
          <img src="./images/capitulo_01/Ejemplo_condiciones_poligono.png">
          <figcaption>Ejemplo condiciones del
            polígono.</figcaption>
        </figure>

      </div>



      <div class="page">
        <p>
          En la <ref ref_id="poligono_condiciones"></ref> tenemos un ejemplo de un
          conjunto de segmentos de línea que no cumplen
          ambas condiciones.
          <br>
          Podemos observar como las aristas $e_1$ y
          $e_2$ (azul y roja, respectivamente) no
          cumplen la segunda condición, y a su vez las
          aristas $e_3$ y $e_4$ (negra y verde,
          respectivamente) no cumplen la primer
          condición.
        </p>
        <p>
          Dada esta definición, podemos explicar de una
          forma más simple, qué es una
          <span class="bolded">curva cerrada
            simple</span>. <br> La razón por la cual
          estos segmentos de línea se definen como una
          <span class="bolded">curva</span> es porque
          es una línea continua, pues los segmentos
          están conectados por los extremos; la razón
          por la cual esta curva es
          <span class="bolded">cerrada</span> es porque
          forma un ciclo, pues el último segmento se
          conecta con el primero y la razón por la que
          la curva cerrada, es además <span class="bolded">simple</span>, es porque los
          segmentos no adyacentes no se intersectan.
        </p>
        <p>
          Podemos definir a los objetos que cumplen
          solo la primer condición como
          <span class="bolded">polígonos no simples</span>, si
          cumplen también la segunda (los segmentos no
          adyacentes no se intersectan) los llamaremos
          <span class="bolded">polígonos simples</span>, otra forma
          más sencilla de definirlo es que un polígono es
          simple si sus elementos no se intersectan entre sí.
          <br>
          Ya que prácticamente solo se hará uso de los
          <span class="bolded">polígonos no simples</span>, por
          simplicidad solo los llamaremos
          <span class="bolded">polígonos</span>.
        </p>
        <p>
          En un polígono, los segmentos $e_i$ son
          llamados <span class="bolded">aristas</span>
          (se usa la notación $e$ ya que la traducción
          de arista al inglés es edge, y es bastante
          común encontrar dicha notación en la
          literatura, utilizaremos dicha notación por
          esa razón), y los puntos $v_i$ (puntos donde
          se intersectan los segmentos de línea
          adyacentes) son llamados
          <span class="bolded">vértices</span>.
        </p>
      </div>

      <div class="page">
        <p>
          Un polígono, con sus aristas y vértices,
          encierra una región del plano, nos
          referiremos a esta región como el
          <span class="bolded">interior del polígono</span>. La
          región no delimitada que rodea al polígono
          forma el <span class="bolded">exterior del polígono</span>.
        </p>
        <p>
          El conjunto de vértices y aristas de un
          polígono $P$ (el polígono sin su interior) es
          llamado perímetro, y es denotado como $
          \partial P$.
          <br>
          A lo largo de las notas cuando nos refiramos a
          un polígono nos referiremos a la unión de su
          perímetro y su interior. Lo que significa que
          si mencionamos un punto en un polígono este
          se puede encontrar ya sea en el interior o en
          su perímetro.
          <br><br>
        </p>

        <p>
          Existen algoritmos que necesitan dividir a
          los polígonos en varias partes para
          procesarlos. Una forma natural de dividir a
          los polígonos en partes más simples se logra
          dibujando <span class="bolded">diagonales</span>.
          <br>
          Una <span class="bolded">diagonal</span> de un polígono
          $P$, es un segmento de línea que conecta dos
          vértices de $P$ y que yace en el interior de
          $P$, este segmento no toca a $ \partial P$
          excepto en su punto inicial y su punto final.
        </p>
        <p>
          Dos diagonales no se cruzan si no comparten
          puntos interiores, esto es, si comparten a lo
          más alguno de sus puntos de inicio o fin.
        </p>

      </div>

      <div class="page">
        TO DO
        <!-- <img src="/images/capitulo_01/Diagonales_from_Devad_discrete_and_computational_geo.jpg" width="90%">
        <br>
        Figure 1.2 shows (a) a polygon, (b) a diagonal, (c) a line segment
        that is not a diagonal, and (d) two crossing diagonals.
        <br><br>
        Definition. A triangulation of a polygon P is a decomposition of P into
        triangles by a maximal set of noncrossing diagonals.
        Here maximal means that no further diagonal may be added to the
        set without crossing (sharing an interior point with) one already in
        the set. -->
      </div>

      <!-- REPASO DE ESTRUCTURAS DE DATOS -->
      <div class="page">
        <h2 id="cap1_repaso_estructuras_datos">Repaso de estructuras de datos</h2>
        <p>
          Como ya se mencionó al inicio de este
          capítulo las estructuras de datos resultan
          una herramienta fundamental para el uso de
          los algoritmos geométricos. Muchas de estas
          estructuras de datos son descritas en el
          curso referente a estructuras de datos, y
          dado que no es la intención de este libro
          volver a describir dichas estructuras, a
          continuación serán presentadas únicamente las
          que resulten indispensables por no formar
          parte del temario oficial de dicho curso.
          <br><br>
        </p>

        <h2 id="cap1_preliminares_geometricos">Preliminares geométricos</h2>
        TO DO
      </div>

      <!--  -->
      <!-- CAPITULO 2: CIERRE CONVEXO -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="cierre_convexo">
            Cierre convexo de un conjunto de puntos
          </h1>
          <h1 class="chap_num">2</h1>
        </div>
        <p>
          Antes de comenzar este capítulo, necesitamos
          saber que es un <span class="bolded">cierre convexo</span>,
          antes de definirlo formalmente, podemos
          tomarnos la libertad de definirlo de una
          forma más intuitiva.
        </p>
        <p>
          Esto es, dado un conjunto finito de puntos
          $S$ en el plano, si vemos a cada punto de $S$
          como un clavo colocado en una superficie plana,
          una madera por ejemplo, y tomamos una liga para estirarla
          alrededor de todos los clavos y la soltamos,
          podemos ver al <span class="bolded">cierre convexo</span> de $S$
          como la región que queda encerrada por la
          liga alrededor de todos los clavos.
        </p>
        <p>
          La <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>,
          contiene un recurso interactivo que nos
          muestra esta idea, donde los círculos
          representan los "clavos" (puntos en $S$) y
          las líneas verdes la "liga" que los encierra.
          <br>
          Puedes hacer clic en cualquiera de los
          círculos blancos que representan a los puntos
          en $S$ para poder moverlo en la dirección que
          muevas el cursor, y a su vez puedes dar de
          nuevo clic para dejarlo fijo en la nueva
          posición de cursor y ver como se modifica el
          cierre convexo.
        </p>
      </div>

      <div class="page">

        <figure id="cierre-convexo">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_2/intuitive_idea.html"></div>
          <figcaption>Ejemplo de la idea intuitiva de un cierre convexo.</figcaption>
        </figure>

        Ahora que tenemos esta definición que nos sirve
        para tener más clara la idea geométrica,
        podemos avanzar más fácilmente y comenzar con
        definiciones adicionales que sean más formales.
        </p>
        <p>
          A continuación definiremos una <span class="bolded">combinación convexa</span>
          para definir lo que es un <span class="bolded">cierre convexo</span>
          a partir de la primera.
          <br>
        </p>

        <p>
          <!-- Conjunto convexo.-->
        <h4><span class="bolded">Combinación convexa.</span></h4>
        Dado un número finito $k$ de puntos
        $p_0, p_1, p_2,\dots, p_{k}$ en $\mathbb{R}^d$,
        una combinación convexa de dicho conjunto de puntos es
        un punto de la forma:
        \[
        r = \alpha_1 p_1 + \alpha_2 p_2 + \dots + \alpha_k p_k
        \]
        donde $\alpha_i$ satisfacen las siguientes condiciones:
        \[
        ( \alpha_i \in \mathbb{R}, \ \ 0 \leq \alpha_i \leq 1,\ \ \alpha_1 + \dots + \alpha_k = 1 )
        \]
        <bibref ref_id="CG_in_C"></bibref>
        </p>



      </div>

      <div class="page">
        <p>
          Si prestamos atención, podemos notar que un
          <span class="bolded">segmento de línea</span>
          consta de todas las combinaciones convexas
          que pueden ser generadas de sus puntos
          extremos que lo definen. Lo cual puede ser
          visto claramente en la <pageref ref_id="segmento_de_linea">
            <ref ref_id="segmento_de_linea"></ref>
          </pageref>.
        </p>
        <p>
          De manera similar podemos notar como un
          triángulo consiste de todas las combinaciones
          convexas de los 3 puntos (no colineales) que
          lo definen. Lo cual puede ser visto en la
          <ref ref_id="comb-convexa"></ref>, en la
          cual, al presionar el botón en la parte
          inferior, podemos generar una combinación
          convexa aleatoria a partir de los tres puntos
          que forman al triángulo. En la parte superior
          podemos apreciar cómo se define al punto $r$
          siguiendo la definición de combinación
          convexa, tomando cada uno de los puntos que
          definen al triángulo ($p_1 = (1,5)$, $p_2 =
          (8,1)$ y $p_3 = (8,8)$) multiplicándolos por
          una $\alpha_i$ aleatoria, de tal manera que
          la suma de las $\alpha_i$ suman 1.
        </p>
        <figure id="comb-convexa">
          <div class="interactive" width="500" height="295" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_conjunto_convexo.html"></div>
          <figcaption>Ejemplo de una combinación convexa generada por los puntos que definen un triángulo.</figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Una vez vistos los ejemplos anteriores
          podemos ver un ejemplo más, con 5
          puntos, $p_1 = (1,5)$, $p_2 = (8,1)$ y $p_3 =
          (8,8)$, $p_4 = (4,6)$ y $p_5 = (7,6)$. <br>
          En la
          <ref ref_id="comb-convexa-2"></ref>
          podemos dar valores entre cero y uno a cada
          $\alpha_i$ (cada $\alpha_i$ tiene al mismo
          color del punto al cual multiplica), y en el
          caso que cumplan la condición $ \alpha_1 +
          \dots + \alpha_5 = 1 $ el punto $r$ será una
          combinación convexa generada con los 5
          puntos, justo como en los ejemplos anteriores
          y en la definición.

        </p>
        <figure id="comb-convexa-2">
          <div class="interactive" width="600" height="365" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_combinacion_convexa_2.html"></div>
          <figcaption>Ejemplo de combinación convexa generada por 5 puntos.</figcaption>
        </figure>
        <p>
          Después de apreciar este ejemplo, podemos
          notar como todas las posibles combinaciones
          convexas generadas del conjunto de puntos,
          resultan estar contenidas en un área convexa,
          la cual en las figuras, <pageref ref_id="comb-convexa">
            <ref ref_id="comb-convexa"></ref>
          </pageref>
          y
          <pageref ref_id="comb-convexa-2">
            <ref ref_id="comb-convexa-2"></ref>
          </pageref>
          se muestra de color morado.
        </p>
      </div>

      <div class="page">
        <p>
          Ahora pensemos a que nos recuerda si tomamos
          cada punto del conjunto como un clavo clavado
          en el plano y los rodeamos con una liga, esto
          sin lugar a dudas nos resultará familiar,
          esta misma era la idea intuitiva del
          <span class="bolded">cierre convexo</span>,
          lo que nos deja ver que el área formada por
          todas las posibles combinaciones convexas
          generadas del conjunto de puntos, es justo el
          área encerrada por la liga, dicho de otra
          manera, es el cierre convexo del conjunto de
          puntos.
        </p>
        <p>
          Por lo que, aprovechándonos de esto, podemos
          pasar a definir más formalmente a nuestro
          <span class="bolded">cierre convexo</span> de
          la siguiente manera.
        </p>
        <!-- Cierre convexo.-->
        <p>
        <h4><span class="bolded">Cierre
            convexo.</span></h4>
        Dado un conjunto finito $S$ de puntos en
        $\mathbb{R}^d$, el <span class="bolded">cierre
          convexo</span>
        de $S$, denotado por $conv(S)$, es el conjunto
        de todas las combinaciones convexas de los
        puntos en $S$.
        <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Ahora que podemos comprender que es el cierre
          convexo, nos sería de gran utilidad saber
          ¿cómo representar al cierre convexo? y ¿qué
          significa calcular el cierre convexo?, pues
          resulta necesario para nuestro objetivo, que
          es indagar en los algoritmos para calcularlo.
        </p>
        <p>
          Comencemos primero por buscar una forma de
          representarlo.
        </p>
        <p>
          Recordando la idea intuitiva de la liga que
          rodea a los clavos, podemos notar que el área
          que encierra esta liga es un polígono
          convexo, lo cual podemos ver en la <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>, moviendo los puntos a voluntad.
          <br>
          Esto nos lleva a una definición alternativa,
          que es la siguiente.
        </p>
      </div>

      <div class="page">
        <p>
        <h4><span class="bolded">Cierre convexo
            definición alternativa.</span></h4>
        El cierre convexo de un conjunto finito $S$ de
        puntos en el plano es el único polígono convexo
        cuyos vértices son puntos de $S$ y que
        contienen todos los puntos de $S$.
        </p>
        <p>
          Ya que el objetivo de este libro no es ser
          totalmente formales, se pasan por alto muchas
          de las pruebas, pero se invita al lector a
          buscar en la bibliografía en caso de requerir
          más formalidad.
          <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Esta nueva definición nos resulta útil pues
          podremos representar al cierre convexo como
          un polígono convexo, teniendo en cuenta que
          el área contenida por este polígono es el
          cierre convexo.
        </p>
        <p>
          Ahora que sabemos que podemos representar al
          cierre convexo de un conjunto de puntos $S$
          como un polígono, resulta esencial saber cómo
          representar a este polígono.
        </p>
        <p>
          Una forma natural de hacerlo es listando los
          vértices de dicho polígono en orden de las
          manecillas del reloj, comenzando desde algún
          punto arbitrario.
        </p>
        <p>
          Tomando esta forma de representar a un
          conjunto convexo, podemos describir el
          problema de encontrar el conjunto convexo de
          un conjunto de puntos, de la siguiente
          manera:
        </p>
        <h4><span class="bolded">Descripción del problema.</span></h4>
        <p>
          Dado un conjunto de puntos $S =
          p_0, p_1, p_2,\dots, p_{n}$ en el plano,
          calcular una lista que contenga a todos los
          puntos de $S$ que son vértices del $conv(S)$
          listados en orden contrario a las manecillas del
          reloj.
        </p>
      </div>
      <div class="page">
        <p>
          Por ejemplo, dado el siguiente conjunto de puntos:
          <img src="./images/capitulo_01/Ejemplo_ch_problema.png">
        <figcaption>Conjunto de puntos de entrada y polígono formado por la salida.</figcaption>
        <br>
        La entrada y salida serían las siguientes:
        \[
        Entrada = conjunto \ de \ puntos \ completo: \\
        p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9
        \]
        \[
        Salida = conjunto \ de \ puntos \\
        que \ representan \ al \ cierre \ convexo: \\
        p_2, p_8, p_5, p_4, p_9
        \]
        </p>
      </div>

      <div class="page">
        <p>
          Es importante recordar que los puntos $p_2,
          p_9, p_4, p_5, p_8$ no son el cierre convexo de
          $S$, son solo la representación de cierre
          convexo pues el cierre convexo sería el
          polígono (interior y perímetro) formado con
          estos puntos, lo que en el ejemplo se
          representa con el área color morado.
        </p>
        <p>
          Ahora que sabemos qué es un cierre convexo, y
          además sabemos cómo describir el problema
          dada una cierta entrada para obtener una
          cierta salida, podemos empezar a indagar de
          que manera podremos solucionar estos
          problemas.
        </p>
      </div>

      <!-- Algoritmo de Graham.-->
      <div class="page" id="graham_algorithm_page">
        <h2 id="cap2_algorithmo_grahan">Algoritmo de Graham</h2>

        <h4><span class="bolded">Contexto</span></h4>
        <p>
          El algoritmo que se abordará en esta sección,
          surgió a finales de la década de 1960, en los
          laboratorios Bell, de la necesidad de su
          creador Ron Graham, por calcular el cierre
          convexo de una gran cantidad de puntos en el
          plano. Una complejidad de $O(n^2)$ en tiempo
          no le resultaba practica, lo que lo llevó a
          describir un algoritmo con una complejidad de
          $O(n log n)$ en tiempo, el cual pasó a ser el
          posiblemente el primer artículo publicado en el
          campo de la geometría computacional en 1972.
        </p>
        <p>
          En esta publicación Graham mostró que al
          realizar un ordenamiento de los puntos, al
          inicio del algoritmo, podía encontrar los
          puntos externos que describen al cierre
          convexo con una complejidad de $O(n)$ en
          tiempo.
        </p>
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por los puntos que son vértices
          del polígono que forman al cierre convexo
          $conv(S)$.
        </p>
        <p>
          Dividamos al algoritmo en pasos, para una
          mejor comprensión del mismo.

        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Comencemos por encontrar al punto con la
          coordenada en $y$ más pequeña, de ser más de
          uno, tomaremos entre estos, al punto con la
          coordenada en $x$ más grande y lo agregamos
          al conjunto de salida $conv(S)$.
        </p>
      </div>
      <div class="page">
        <p>
          Dado que este punto es el punto inferior
          sabemos que pertenece al polígono que forma
          al cierre convexo, y lo tomaremos como punto
          inicial, para de aquí ir agregando a los
          puntos restantes.
        </p>
        <figure id="punto_inferior">
          <img src="./images/capitulo_02/punto_inferior.png" width="45%" height="45%"
            alt="Imagen que muestra el punto inferior seleccionado.">
          <figcaption>Seleccionamos el punto interior.</figcaption>
        </figure>
        <h5><span class="bolded">Paso 2. Ordenar los puntos con respecto al inferior.</span></h5>
        <p>
          Posteriormente ordenaremos todos los demás
          puntos en $S$ por el ángulo que forma la
          línea trazada desde el punto inferior hasta
          el punto actual, con respecto al eje $x$, al
          sentido contrario a las manecillas del reloj.
        </p>

        <figure id="ordenar_puntos">
          <img src="./images/capitulo_02/puntos_ordenados.png" width="50%" height="50%"
            alt="Imagen que muestra el punto inferior seleccionado y a los demás ordenados con respecto a este.">
          <figcaption>Ordenamos con respecto al punto interior.</figcaption>
        </figure>
      </div>
      <div class="page" id="graham_step_3">
        <h5><span class="bolded">Paso 3. Recorrer los puntos ordenados y agregar puntos al $conv(S)$.</span></h5>
        <p>
          A partir de aquí, iremos procesando cada
          punto en el orden que resultó del paso
          anterior, al cual llamaremos $p_i$.
        </p>
        <p>
          Para procesar al siguiente punto $p_i$
          haremos uso de los últimos dos puntos
          agregados a $conv(S)$.
          <br>
          Podemos apreciar que iniciamos esta parte del
          algoritmo con solo un punto en $conv(S)$, por
          lo que en este caso, agregaremos al siguiente
          punto a procesar $p_i$ automáticamente.
        </p>
        <p>
          Una vez que es posible tomar los últimos dos
          puntos en $conv(S)$, formaremos una tripleta
          con los últimos dos puntos dentro del $conv(S)$
          que llamaremos $p_k$ y $p_{k-1}$ y el
          siguiente punto a procesar $p_i$.
          <br>
          Tomando esta tripleta $ ( p_{k-1} , p_{k} ,
          p_{i} ) $, realizaremos una comprobación de
          si la secuencia de los tres puntos realiza
          una vuelta hacia la izquierda, hacia la
          derecha, o si los 3 puntos son colineales.
          <br>
          Para verificar si la secuencia de los 3
          puntos da una vuelta izquierda, derecha o
          son colineales, comprobaremos si el tercer
          punto de la secuencia está a la izquierda,
          derecha o en la <span class="bolded">línea
            dirigida</span> formada por los primeros dos
          puntos.
          <br>
          Diremos que una <span class="bolded">línea
            dirigida</span> es formada por una secuencia
          de dos puntos, la línea es la formada por
          ambos puntos y la dirección va del primer
          punto al segundo punto.
          <bibref ref_id="CG_in_C">Pag. 29</bibref>
        </p>
        <p>
          La siguiente Figura muestra un ejemplo de
          la vuelta izquierda y la vuelta derecha.
        </p>
      </div>
      <div class="page">
        <figure id="ordenar_puntos">
          <img src="./images/capitulo_02/Ejemplo_vueltas_1.jpg" width="80%" height="60%"
            alt="Ejemplo de la definición de vuelta derecha e izquierda.">
          <figcaption>Ejemplo de la definición de vuelta derecha e izquierda.</figcaption>
        </figure>
        <p>
          Una vez sabiendo si la tripleta de puntos dan
          una vuelta derecha o izquierda, actuamos de
          la siguiente manera.
        </p>
        <p>
          Si la tripleta $ ( p_{k-1} , p_{k} , p_{i} )
          $ forma una vuelta izquierda, agregamos al
          punto $p_{i}$ a nuestro conjunto de salida
          $conv(S)$.
        </p>
        <p>
          Si la tripleta $ ( p_{k-1} , p_{k} , p_{i} )
          $ forma una vuelta derecha o los puntos son
          colineales, eliminamos al último punto de
          nuestro conjunto de salida $conv(S)$, esto es
          al punto $p_{k}$.
        </p>
        <p>
          Repetiremos este proceso hasta que hayamos
          procesando todos los puntos que ordenamos al
          inicio.
        </p>
        <p>
          En la <ref ref_id="graham_scan_algorithm"></ref> podemos ver un ejemplo de la
          ejecución del algoritmo de Graham paso a paso.
        </p>
      </div>
      <div class="page">

        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/graham_scan.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Graham.</figcaption>
        </figure>
        <!-- Fuentes: Discrete%20and%20computational%20geometry%20by%20Devadoss%20S.,%20ORourke%20J.%20(z-lib.org).pdf -->
        <!-- Computational_Geometry_An_Introduction_by_Franco_P_Preparata,_Michael. -->
        <!-- Computational%20Geometry%20in%20C%20by%20Joseph%20ORourke%20(z-lib.org).pdf -->
      </div>

      <div class="page" id="graham_algorithm__complexity_page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Dado que lo único que nos interesa en este
          paso es obtener un punto en algún extremo del
          conjunto de puntos $S$, resulta indistinto
          cual escoger, en este caso se toma al punto
          interior.
          <br>
          Para obtener este punto inferior resulta
          claro que es necesario recorrer todos y cada
          uno de los puntos en $S$ y llevar registro
          del que tiene el menor valor en el eje $y$,
          lo cual podemos hacer en una complejidad en
          tiempo de $ \ O(n) \ $ donde $ \ n \ $ es el número
          de puntos en $S$.
        </p>
        <h5><span class="bolded">Paso 2. Ordenar los puntos con respecto al inferior.</span></h5>
        <p>
          Para esta parte del algoritmo necesitamos
          ordenar todos los demás puntos en $S$ por el
          ángulo que forma la línea trazada desde el
          punto inferior hasta el punto que deseamos
          ordenar, con respecto al eje $x$
          (considerando al punto inferior como el
          origen) al sentido contrario a las manecillas
          del reloj.
          <br>
          Es posible hacer este ordenamiento,
          comparando cada punto a ordenar, usando el
          valor del ángulo de la línea trazada desde el
          punto inferior hasta dicho punto. Como se
          puede apreciar en la <ref ref_id="compare_points_by_angle"></ref>
          donde el ángulo de $p_2$ es menor al ángulo
          de $p_3$.
        </p>
        <p>
          Para que el ordenamiento resulte en
          $O(nlogn)$ necesitamos una forma de comparar
          dos puntos en tiempo constante, lo cual
          podemos hacer calculando los ángulos
          directamente.
        </p>
      </div>

      <div class="page">
        <p>
          Esta forma de comparar podría tener algunos
          inconvenientes, por lo que hay formas
          alternativas para comparar los puntos que
          aprovechan el mismo calculo necesario para
          calcular si 3 puntos dan una vuelta derecha o
          izquierda, sin embargo, no ahondaremos en más
          dichos detalles.
        <figure id="compare_points_by_angle">
          <img src="./images/capitulo_02/Ejemplo_comparar_angulos.svg" width="80%" height="60%" alt="Ejemplo de la
          comparación de dos puntos por sus ángulos.">
          <figcaption>Ejemplo de la comparación de los
            ángulos de $p_2$ y $p_3$ con respecto a punto
            inferior $p_1$.</figcaption>
        </figure>
        </p>
        <p>
          Entonces, asumiendo que la complejidad de la
          comparación usada para el ordenamiento toma
          tiempo constante, este paso nos resulta
          en $O(nlogn)$.
        </p>

      </div>
      <div class="page">
        <h5>
          <span class="bolded">Paso 3. Recorrer los
            puntos ordenados y agregar puntos al
            $conv(S)$.</span>
        </h5>
        <p>
          En este paso podemos observar que recorremos
          la lista de puntos ordenados uno por uno,
          verificando si forma una vuelta derecha o
          izquierda, dicha comprobación puede ser
          realizada de la siguiente manera.
        </p>
        <p>
          Dada la tripleta de puntos $(a,b,c)$ podemos
          calcular las pendientes de los segmentos
          $A = \overline{a b}$ y $B = \overline{b c}$
          denotadas como:
        </p>
        $$ m_{A} = \frac{b_y - a_y}{b_x - a_x} $$
        $$ m_{B} = \frac{c_y - b_y}{c_x - b_x} $$
        <p>
          Si la $ m_{A} > m_{B} $ entonces tenemos una
          vuelta derecha, si por el contrario $ m_{A} < m_{B} $ entonces tenemos una vuelta izquierda, y en el caso que
            $ m_{A}=m_{B} $ entonces no hay vuelta, ya que los puntos son colineales. </p>

            <p>
              En la figura <ref ref_id="comparacion_pendientes"></ref> podemos apreciar esta comparación,
              la cual podemos calcular fácilmente como:
              $$ (b_y - a_y) * (c_x b_x) - (c_y - b_y)*(b_x - a_x) $$
              Formula que se deriva de restar $ m_{A} - m_{B}$ y cuyo resultado es
              positivo cuando $ m_{A} > m_{B} $, negativo cuando $ m_{A} < m_{B} $ y 0 cuando $ m_{A}=m_{B} $ .</p>
                <p>
                  Por lo que gracias a esto podemos calcular de que tipo de vuelta se trata en tiempo constante.
                </p>
      </div>

      <div class="page">
        <figure id="comparacion_pendientes">
          <div class="interactive" width="500" height="350" window-size="false"
            src="./Interactivos/capitulo_2/descartesJS/Ejemplo_comparacion_de_pendientes.html"></div>
          <figcaption>Ejemplo de comparación de pendientes para saber que tipo de vuelta dan los puntos.
          </figcaption>
        </figure>

        <p>
          Además podemos observar que cada punto en
          el
          conjunto ordenado, es añadido y removido del
          conjunto de salida $conv(S)$ a lo más una
          vez, entonces, dicho recorrido sobre los
          puntos ordenados se realiza en $O(n)$
          iteraciones.
        </p>
        <p>
          Por lo tanto la complejidad es $O(nlog(n))$,
          pues la complejidad de ordenar a los puntos
          en el paso 2 domina las complejidades de los
          pasos 1 y 3.
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmo_jarvis">Algoritmo de Jarvis</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          En el algoritmo anterior comenzamos
          identificando un punto extremo en el
          conjunto de puntos original, ahora bien,
          ¿podríamos hacer lo mismo para encontrar
          todos los puntos que representan al cierre
          convexo?
          <br>
          Ciertamente, encontrar todos los puntos
          extremos no resulta tan fácil como encontrar
          el inferior, el superior, el más a la derecha
          y el más a la izquierda, sin embargo, una vez
          tomado un extremo, resulta más fácil
          encontrar otro punto extremo, si sabemos que
          la línea que trazan ambos puntos, está en un
          extremo también, es decir, si todos los demás
          puntos en $S$ están, sobre la misma línea o
          a un solo lado de la línea.<bibref ref_id="CG_an_Introduction">Pag. 110</bibref>
        </p>
        <p>
          La siguiente figura muestra un ejemplo de
          esto, tomando los puntos $p_8$ y
          $p_5$ podemos trazar una línea que cumple
          la condición ya mencionada.
        </p>
        <figure id="linea_extrema">
          <img src="./images/capitulo_02/Ejemplo_linea_extrema.png" width="75%" height="75%"
            alt="Linea que se encuentra al extremo inferior, con todos los demás puntos por arriba de ella.">
          <figcaption>Línea que se encuentra al extremo inferior, con todos los demás puntos por arriba de ella.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Podríamos hacer uso de este conocimiento y
          buscar todos los pares de puntos que
          representan líneas que cumplen dicha
          condición, pues justo estas son las que
          forman al $conv(S)$, sin embargo el número de
          parejas de puntos sobre las que deberíamos
          iterar para comprobar si cumplen dicha
          condición, son <a target="_blank" href="https://en.wikipedia.org/wiki/Complete_graph">
            $n(n-1)/2$</a>, lo cual nos tomaría un tiempo
          de $O(n^2)$, además de que para cada línea
          formada por cada par de puntos deberíamos
          comprobar si todos los demás puntos cumplen
          la condición de yacer solo a un lado de la
          línea, lo que nos tomaría $O(n)$ para cada
          par de puntos, esto es $O(n^3)$ para el
          algoritmo completo.
        </p>
        <p>
          ¿Se podría hacer algo mejor que eso usando la
          misma idea? <br>
          Tal parece que sí, Jarvis en su artículo de
          1973, mostró como se puede reducir la
          complejidad a $O(n^2)$ si tomamos en cuenta
          que una vez tenemos un par de puntos $p_a$ y
          $p_b$ en $conv(S)$, sabemos que debe existir
          otro punto $p_c$ que junto con $p_b$ definan
          una línea que tenga a todos los demás puntos
          de un solo lado.
          <bibref ref_id="CG_an_Introduction">Pag.
            111</bibref>
        </p>
        <p>
          El algoritmo presentado en esta sección hará
          uso de esta idea para obtener todos los
          puntos que representan a $conv(S)$.
        </p>

      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado lo que sabemos hasta ahora, podemos describir el algoritmo de Jarvis
          en solo dos pasos, los cuales son los siguientes:
        </p>

        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Este paso es exactamente igual al primer paso del
          <pageref ref_id="graham_algorithm_page">algoritmo de
            Graham antes descrito</pageref>.
        </p>
        <h5><span class="bolded">Paso 2. Ir agregando puntos a $conv(S)$ tomando el último punto en
            $conv(S)$ como referencia.</span></h5>

        <p>
          En esta parte del algoritmo tomamos al último
          punto que fue agregado a $conv(S)$, al que
          nos referiremos como $p_k$, posteriormente,
          procedemos a comparar a todos los demás
          puntos en $S$ por al ángulo que forman con
          respecto a dicho punto $p_k$ en sentido
          contrario a las manecillas del reloj, y
          tomamos al que tenga el menor ángulo, este
          será el siguiente punto en ser agregado a
          $conv(S)$.
          <br>
          Repetiremos este procedimiento hasta que el
          siguiente punto a agregar sea uno que ya
          pertenece a $conv(S)$.
        </p>
      </div>
      <div class="page">
        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/jarvis_march.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Jarvis.</figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Tomar el punto inferior.</span></h5>
        <p>
          Esto sería igual al análisis del primer paso
          del
          <pageref ref_id="graham_algorithm__complexity_page">algoritmo
            de Graham antes descrito</pageref>. Es decir,
          tenemos una complejidad de $O(n)$.
        </p>
        <h5><span class="bolded">Paso 2. Ir agregando puntos a $conv(S)$ tomando el último punto en
            $conv(S)$ como referencia.</span></h5>
        <p>
          Para esta parte del algoritmo necesitamos a
          un punto $p$ cuyo ángulo (en sentido
          contrario a las manecillas del reloj) que
          forma con respecto al último punto $p_k$ en
          $conv(S)$ sea el menor entre todos los
          ángulos formados con los puntos en $S$.
          <br>
          Haciendo uso del producto cruz, dados dos
          puntos podemos comparar cuál de ellos es
          menor respecto al ángulo (en sentido
          contrario a las manecillas del reloj) que
          forma con nuestro último punto en $conv(S)$,
          $ \ p_k$.
          <br>
          Esto lo tenemos que hacer para cada punto en
          $S$ usando al último punto en $conv(S)$ hasta
          que no es posible agregar más puntos a
          $conv(S)$. Lo que significa que para cada
          punto en $conv(S)$ iteraremos sobre todos los
          puntos en $S$, esto, en el peor de los casos
          tiene una complejidad de $O(n^2)$ pues en el
          peor de los casos $S = conv(S)$.

        </p>
      </div>

      <div class="page">
        <p>
          Esta cota superior es acertada, sin embargo,
          es posible hacerla un poco más justa, ya que
          sabemos que no siempre se cumple que $S =
          conv(S)$, por lo que, si tomamos a $n$ como
          el número de puntos en $S$ y a $h$ el número
          de puntos en $conv(S)$, podemos decir que
          el algoritmo tiene una complejidad de $O(nh)$
          pues la complejidad del paso 1 es $O(n)$ y
          $O(nh)$ domina.
        </p>
        <p>
          Esta característica nos deja ver como este
          algoritmo se ejecuta más rápido en casos donde el
          cierre convexo es pequeño, a este tipo de algoritmos
          se les suele llamar <a target="_blank" href="https://en.wikipedia.org/wiki/Output-sensitive_algorithm">
            algoritmos sensibles a la salida
          </a>
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_divide_venceras">Algoritmos usando divide y vencerás</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          En esta sección nos centraremos en un nuevo
          enfoque para, resolver el problema del cierre
          convexo, el cual hará uso de un paradigma
          ampliamente conocido y utilizado, el
          paradigma
          <a target="_blank" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide
            y vencerás</a>.
          <br>
          Los primeros en aplicar este paradigma para
          encontrar el cierre convexo fueron
          <a target="_blank" href="https://dl.acm.org/doi/abs/10.1145/359423.359430">Franco Preparata y June Hong en
            1977</a>,
          utilizándolo no solo para el problema en 2
          dimensiones, sino que también para 3
          dimensiones, lo cual hace de este enfoque aún
          más interesante.
        </p>
        <p>
          Este algoritmo, divide el problema inicial,
          de encontrar el cierre convexo de un conjunto
          de puntos $S$, en subproblemas que serán
          resueltos y posteriormente unidos, de una
          manera muy similar al algoritmo de
          ordenamiento <a target="_blank" href="https://en.wikipedia.org/wiki/Merge_sort"><i>merge
              sort</i> </a>.
          <br>
          La forma de dividir el problema en
          subproblemas es bastante simple, pues es
          posible ordenar los puntos por su componente
          en $x$ y dividir el problema en dos, calcular
          el cierre convexo de la primer mitad de
          dichos puntos ordenados y hacer lo mismo para
          la segunda mitad, posteriormente es necesario
          unir los cierres convexos resultantes de
          dichos subproblemas, sin embargo, realizar
          dicha unión de los subproblemas, de una forma
          optima, no resulta trivial.
        </p>
        <p>
          En este momento, nos queda la pregunta, dados
          dos cierres convexos, ¿cómo podemos unirlos
          para formar el cierre convexo de ambos?
        </p>
        <p>
          Lo único que necesitamos es encontrar dos
          líneas tangentes a ambos cierres convexos,
          una superior y una inferior, un ejemplo de
          tales líneas puede ser apreciado en la <ref ref_id="lineas_tangentes"></ref>
        </p>
      </div>

      <div class="page">
        <figure id="lineas_tangentes">
          <img src="./images/capitulo_02/Ejemplo_lineas_tangentes.png" width="80%" height="80%">
          <figcaption>Ejemplo de líneas tangentes en dos cierres convexos.</figcaption>
        </figure>
        <p>
          La primer idea que nos puede venir a la
          mente, para encontrar dichas líneas
          tangentes, es tomar todos los posibles
          segmentos de líneas, que se pueden formar
          tomando un punto de cada cierre convexo, y
          tomar al par que forme una línea tal que
          todos los demás puntos estén bajo ella y al
          par que forme una línea tal que todos los
          demás puntos estén sobre ella.
          <br>
          Si embargo, realizar este procedimiento no
          sería muy eficiente, pues resultaría en
          comprobar para cada par de puntos $n(n-1)$ si
          todos los demás puntos $n-2$ yacen todos
          sobre el mismo lado de la línea, lo cual
          tendría una complejidad de $O(n^3)$.
        </p>
        <p>
          Una posible mejora que podríamos realizar a
          este algoritmo sería evitar
          comparar cada línea con todos los demás
          puntos para saber si es una línea tangente.
          <br>
          ¿Cómo podemos comprobar que una línea es
          tangente a los cierres convexos sin comparar
          con todos los puntos?
        </p>
      </div>

      <div class="page">
        <p>
          Podemos trazar una línea vertical, entre
          ambos cierres convexos, y para cada línea
          trazada por los puntos entre los cierres
          convexos, tomaremos en cuenta el punto en el
          que intercepta a la línea que trazamos,
          entonces, tomaremos como nuestras líneas
          tangentes por arriba y por abajo, a las
          líneas con el mayor y menor valor de
          intersección, con la línea vertical que
          trazamos entre ambos puntos.
          <br>
          La <ref ref_id="ch_slow_merge_algorithm"></ref> muestra un ejemplo
          en el que se puede visualizar esto fácilmente.
        </p>
        <figure id="ch_slow_merge_algorithm">
          <div class="interactive" width="810" height="750" window-size="false"
            src="./Interactivos/capitulo_2/ch_slow_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos.</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Haciendo uso de este algoritmo la
          complejidad para encontrar las líneas
          tangentes superior e inferior pasa a $O(n^2)$, sin
          embargo, esto aún no es óptimo.
        </p>
        <p>
          ¿Qué se puede hacer para mejorarlo?
        </p>
        <p>
          Podemos evitar revisar todas las parejas de
          puntos y solo revisar las que resulte
          indispensable, esto es posible usando a la
          idea que proponen Preparata y Hong en su
          artículo.
          <br>
          La idea es la siguiente y resulta
          prácticamente la misma para obtener la
          tangente superior, o la inferior, por lo que
          a continuación solo se describe como obtener
          una de ellas.
        </p>
        <p>
          Dado que sabemos que la tangente $T$ que
          buscamos, tiene un punto en el cierre convexo
          del subproblema izquierdo, y un punto en el
          cierre convexo del subproblema derecho,
          tomaremos como $T$, a la línea formada por el
          punto más a la derecha del cierre convexo
          izquierdo, y el punto más a la izquierda del
          cierre convexo derecho. Posteriormente,
          comenzaremos a hacer "descender" la tangente
          $T$ cambiando primero su punto en un cierre
          convexo y después sobre el otro, repitiendo
          hasta encontrar la tangente inferior.
        </p>
        <p>
          Dicho proceso de descenso, se realiza
          haciendo uso del hecho, de que la
          representación de cada cierre convexo es una
          lista de puntos, ordenada en sentido
          contrario a las manecillas del reloj.
          <br>
          Este descenso comienza sustituyendo el punto
          actual $pd_j$ en el conjunto convexo derecho,
          por el punto anterior a él $pd_{j-1}$ (el
          siguiente en sentido de las manecillas del
          reloj), siempre y cuando la línea nueva $T$
          resultante esté más abajo que la anterior
          (para saber eso usamos el valor de
          intersección con la línea vertical), y
          seguiremos sustituyendo este punto hasta que
          no podamos encontrar una $T$ más abajo.
        </p>

      </div>


      <div class="page">
        <p>
          Una vez hayamos "descendido" lo más posible
          sobre el punto del cierre convexo derecho,
          hacemos lo equivalente con el punto del lado
          izquierdo $pi_k$, pero en lugar de cambiar
          con el punto anterior $pi_{k-1}$, cambiamos
          el punto actual por el siguiente en el cierre
          convexo $pi_{k+1}$ (el siguiente en sentido
          contrario a las manecillas del reloj), y
          seguimos cambiando por el siguiente punto
          mientras la $T$ resultante se encuentre más
          abajo que la anterior.
          <br>
          Una vez que ya no sea posible "descender" más
          sobre el cierre convexo izquierdo, repetimos
          el proceso comenzando a descender lo más
          posible sobre el punto del cierre convexo
          derecho y luego sobre el izquierdo, hasta que
          no sea posible descender más en ninguno de los
          dos.
        </p>
        <p>
          La <ref ref_id="ch_merge_algorithm"></ref> muestra como es este algoritmo
          de forma interactiva.
        </p>
        <p>
          De esta manera encontramos la tangente
          inferior, en tiempo $O(n)$ pues la forma en
          la que descendemos nunca da pasos atrás, por
          lo tanto no pasa más de una vez por cada
          punto. Y como ya mencionamos, el proceso para
          encontrar la tangente superior, resulta ser
          análogo. Una vez conociendo cuales son estas
          tangentes, combinar ambos cierres convexos
          resulta trivial, pues solo es cuestión de
          recorrer los cierres convexos que ya
          conocíamos, desde una tangente a otra,
          proceso en el cual visitaríamos a lo más
          todos los puntos en ambos cierres convexos
          una sola vez, lo cual puede ser realizado en
          $O(n)$.
        </p>
        <p>
          Gracias a este algoritmo para unir dos
          conjuntos convexos, reducimos la complejidad que
          teníamos de $O(n^2)$ a $O(n)$.
        </p>
      </div>

      <div class="page">
        <figure id="ch_merge_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/ch_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos de forma eficiente.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por los puntos que son vértices
          del polígono que forma al cierre convexo
          $conv(S)$.
        </p>
        <p>
          Ahora que conocemos la forma de unir dos
          cierres convexos de forma eficiente, podemos
          describir el algoritmo completo, en los siguientes pasos
          que resultan suficientemente descriptivos.
        </p>

        <h5><span class="bolded">Paso 1. Ordenar los puntos por sus coordenadas en x.</span></h5>
        <br>
        <h5><span class="bolded">
            Paso 2. Dividir los puntos en dos
            conjuntos $I$ y $D$ con la primera mitad de puntos
            y la segunda mitad de puntos
            respectivamente.
          </span></h5>
        <br>
        <h5><span class="bolded">Paso 3. Calcular recursivamente los cierres convexos de $I$ y $D$.</span></h5>
        <br>
        <h5><span class="bolded">Paso 4. Unir $conv(I)$ y $conv(D)$.</span></h5>

      </div>

      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, sin embargo, en
          esta ocasión dividiremos el algoritmo en las
          partes, <span class="bolded">Dividir</span>,
          <span class="bolded">Vencer</span> y <span class="bolded">Combinar</span>, pues el
          presente algoritmo es recursivo, y de esta
          manera describiremos la complejidad usando la
          <a target="_blank" href="https://es.wikipedia.org/wiki/Relación_de_recurrencia#:~:text=La%20conexión%20con">
            relación de recurrencia
          </a>.
        </p>
        <p>
          Antes de empezar dejemos en claro la notación
          para describir la recurrencia, tomaremos a
          $T(n)$ como el tiempo de ejecutar el
          algoritmo para encontrar el cierre convexo de
          $n$ puntos (los cuales asumimos están ordenados
          de forma ascendente respecto al eje $x$), a
          $D(n)$ como el tiempo que toma dividir el
          problema con $n$ puntos en los subproblemas
          necesarios, y a $C(n)$ como el tiempo que
          toma combinar las soluciones de los
          subproblemas para formar la solución del
          problema original.
        </p>
        <p>

        </p>
        <h5><span class="bolded">Dividir.</span></h5>
        <p>
          El paso de dividir solo requiere encontrar
          el punto medio de los puntos ya ordenados,
          lo cual toma tiempo constante. Por lo tanto,
          podemos decir que la complejidad de este paso
          es constante, i.e. $D(n)$ = $O(1)$.
        </p>
        <h5><span class="bolded">Vencer.</span></h5>
        <p>
          Sabemos que en el paso de dividir obtuvimos
          únicamente dos subproblemas de tamaño $n/2$,
          pues dividimos.
          Entonces, podemos describir la complejidad de
          resolver los subproblemas (vencer), como
          $2T(2/n)$ pues son dos subproblemas cada uno de tamaño
          $n/2$.
        </p>
      </div>
      <div class="page">
        <h5><span class="bolded">Combinar.</span></h5>
        <p>
          Gracias al algoritmo ya mencionado para unir
          dos cierres convexos en tiempo $O(n)$ donde
          $n$ es la suma de los tamaños de los cierres
          que combinaremos, podemos decir que
          complejidad de este paso es lineal, i.e.
          $C(n)$ = $O(n)$.
        </p>
        <br>
        <p>
          Uniendo estas complejidades podemos describir
          a $T(n)$ como:
        </p>
        $T(n) = O(1) + 2T(n/n) + O(n)$
        <p>
          Sin embargo, ya que el término constante
          resulta no tener mucho peso especialmente al
          incrementar el tamaño de $n$, podemos
          reescribir a $T(n)$ como :
        </p>
        $T(n) = 2T(n/n) + O(n)$
        <p>
          La cual es una relación de recurrencia clásica
          en las ciencias de la computación cuya solución es
          <a target="_blank"
            href="https://www.cs.cornell.edu/courses/cs3110/2014sp/recitations/21/solving-recurrences.html">
            $T(n) = O(nlogn)$
          </a>.
          <br>
          Por lo tanto podemos concluir que la
          complejidad del algoritmo para encontrar el
          cierre convexo de $n$ puntos usando la técnica
          de divide y vencerás es de $O(nlogn)$, pues
          nuestro preprocesamiento de puntos al
          ordenarlos toma $O(nlogn)$ y usando estos
          puntos ordenados la técnica de dividir y
          vencerás también toma $O(nlogn)$.
        </p>

      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_dinamicos">Algoritmos dinámicos</h2>
        <h4><span class="bolded">Contexto</span></h4>
        <p>
          Después de haber llegado a la complejidad en
          tiempo $O(nlogn)$ y sabiendo que esta no
          puede ser mejorada, indagar más sobre el
          problema del cierre convexo podría parecer
          sin sentido, pero ¿qué tal si abordamos el
          problema con algunas modificaciones mínimas?.
        </p>
        <p>
          Una modificación bastante interesante al
          problema del cierre convexo es, el algoritmo
          incremental. La idea es ir agregando puntos
          uno por uno, e ir construyendo el cierre
          convexo resultante en cada paso, haciendo uso
          del cierre convexo formado antes de agregar
          el punto actual.
        </p>
        <p>
          Ya que este no es el mismo problema que hemos
          estado estudiando, resulta bastante útil dar
          una mejor descripción del problema, asumiendo
          para simplicidad, que no hay tres puntos que
          sean colineales.
        </p>
        <h4><span class="bolded">Descripción del problema.</span></h4>
        <p>
          Dado una secuencia de $n$ puntos $S = p_0,
          p_1, p_2,\dots, p_{n}$ en el plano, calcular
          su cierre convexo de tal forma que después de
          procesar al punto $p_{i}$ obtengamos al
          cierre convexo del conjunto de puntos $ \{
          p_0, p_1, p_2,\dots, p_{i} \} \ $ esto es
          $ \ conv( \{ p_0, p_1, p_2,\dots, p_{i} \} ) $.
        </p>
      </div>

      <div class="page">
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Para comenzar el algoritmo podemos tomar los
          primeros 3 puntos en la secuencia (esto
          haciendo uso de que no hay 3 puntos que sean
          colineales), pues sabemos que este será
          nuestro primer cierre convexo que formaremos.
          <br>
          Una vez teniendo un cierre convexo $C$, al
          agregar un punto $p_i$ nos deja con dos posibles
          casos: cuando el nuevo punto $p_i$ que
          agregaremos, está contenido en el cierre
          convexo $ p_i \in C$ (recordemos que esto es que el punto
          esté en el área o el perímetro del polígono
          que representa al cierre convexo) o no lo
          está $ p_i \notin C$.
        </p>
        <h5><span class="bolded">$p_i \in C$</span></h5>
        <p>
          Si este es el caso, podemos simplemente
          descartar a $p_i$.
          <br>
          ¿Cómo podemos comprobar que en efecto $p_i$
          se encuentra en el cierre convexo actual?
          <br>
          Podemos usar el mismo procedimiento que
          usamos en el <pageref ref_id="graham_step_3">paso 3 del algoritmo
            de Graham</pageref>, para comprobar con cada
          arista en el cierre convexo si el punto $p_i$
          da vuelta derecha o no. Si tomando a cada una
          de las aristas en el cierre convexo actual,
          como la línea dirigida comprobamos que $p_i$
          nunca da una vuelta derecha en alguna arista,
          podemos decir que $p_i$ se encuentra dentro
          del cierre convexo actual.
          <br>
          Este proceso se realiza para todas las
          aristas del cierre convexo actual por lo que
          tomaría una complejidad de $O(n)$.
        </p>
        <h5><span class="bolded">$p_i \notin C$</span></h5>
        <p>
          Si este es el caso, (cosa que comprobaremos
          revisando si alguna tripleta da vuelta
          derecha, usando el criterio de vuelta
          derecha e izquierda que usamos en el
          algoritmo de Graham, usando dos puntos
          consecutivos en el cierre convexo y al
          punto $p_i$ como
        </p>
      </div>
      <div class="page">
        <p>
          tripleta), tenemos que añadir a $p_i$ al
          cierre convexo.
        </p>
        <p>
          Ahora lo que necesitamos es una forma de unir
          el cierre convexo actual con $p_i$. Si
          recordamos como se realiza la unión de dos
          cierres convexos en el algoritmo divide y
          vencerás, podemos ver que lo único que
          necesitamos es encontrar dos líneas tangentes
          a $p_i$ y después quitar los puntos que ya no
          formen parte del cierre convexo si es que los
          hay.
        </p>
        <p>
          Podemos encontrar las líneas tangentes usando
          el mismo recorrido que usamos para saber si
          $p_i$ está en el cierre convexo actual o no,
          pues justo estos puntos en el cierre convexo
          que forman la tangente son los puntos que
          pertenecen a dos aristas que dan vuelta en
          sentidos opuestos.
          <br>
          La <ref ref_id="cierre_convexo_union_punto"></ref>,
          muestra un ejemplo de esto, en el cual las
          líneas rojas muestran la dirección de la
          vuelta que daría una arista dirigida al punto
          $p$, esto es, de qué lado yace el punto $p$
          con respecto a la flecha roja.
        </p>
        <figure id="cierre_convexo_union_punto">
          <img src="./images/capitulo_02/Ejemplo_unir_punto_a_ch.png" width="75%" height="75%">
          <figcaption>Ejemplo que muestra un cierre convexo y un punto exterior a el que se agregará
            al cierre, las líneas tangentes que se deben agregar para formar el nuevo cierre se muestran en amarillo.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Una vez que agregamos al nuevo punto o
          ignoramos dependiendo el caso, estamos
          seguros de que tenemos el cierre convexo para
          los primeros 4 puntos. Para seguir calculando
          el cierre convexo a medida que agregamos
          puntos es suficiente agregar el nuevo punto y
          repetir el mismo procedimiento aplicado
          anteriormente.

        </p>
        <figure id="finding_tangents_with_a_point">
          <div class="interactive" width="810" height="830" window-size="false"
            src="./Interactivos/capitulo_2/ch_merge_point.html">
          </div>
          <figcaption>Ejemplo del recorrido que verifica si un punto está dentro o fuera del
            cierre convexo actual y si está fuera actualiza el cierre convexo.
          </figcaption>
        </figure>
      </div>



      <div class="page">
        <h4><span class="bolded">Complejidad</span></h4>
        <p>
          Procederemos a hacer un análisis simple de la
          complejidad del algoritmo, con ayuda de su
          división en pasos, analizaremos la
          complejidad de cada uno para obtener la total
          del algoritmo.
        </p>
        <h5><span class="bolded">Paso 1. Calcular el
            cierre convexo para los primeros 3
            puntos.</span></h5>
        <p>
          Calcular el cierre convexo de los primeros 3
          puntos en $S$ nos toma tiempo $ \ O(1) \ $
          pues 3 es un número constante y el número de
          operaciones para formar su cierre convexo son
          solo las necesarias para unir a estos puntos.
        </p>
        <h5><span class="bolded">Paso 2. Agregar un punto
            y calcular el cierre convexo resultante.</span></h5>
        <p>
          La complejidad de agregar un punto nuevo como
          hemos visto resulta ser $O(n)$, pues en el
          peor de los casos recorremos todos los puntos
          que hemos agregado hasta dicha iteración.
          Este segundo paso será ejecutado para cada
          nuevo punto agregado hasta que no falten
          puntos por agregar.
        </p>
        <p>
          Por lo tanto podemos concluir que la
          complejidad de ejecutar este algoritmo
          dinámico es de $O(n^{2})$, lo cual a pesar de
          no ser igual de óptimo que el algoritmo no
          dinámico resulta ser más eficiente que la
          idea más simple que podríamos ocupar para
          resolver este problema, la cual sería
          calcular el cierre convexo para cada
          iteración con alguno de los algoritmos con
          complejidad $O(nlogn)$ ya mencionados, que
          nos dejaría una complejidad total de
          $O(n^{2}logn)$.
        </p>
        <p>
          A pesar de esto, sí es posible mejorar la
          complejidad aún más si utilizamos una técnica
          más eficiente que $O(n)$ para insertar, lo
          cual describe
          <a target="_blank"
            href="http://galaxy.cti.gr/dep/sites/default/files/member/zagouras/course-files/p402-preparata.pdf">
            Preparata
          </a>
          mejorando la complejidad de inserción a
          $\theta(logn)$ y así la complejidad total a
          $O(nlogn)$. Sin embargo, dicho algoritmo
          resulta bastante más complejo por lo cual no
          será abarcado en estas notas.
        </p>
      </div>



      <div class="page">
        <h2 id="cap2_extensiones_variantes">Extensiones y variantes</h2>
      </div>

      <div class="page">
        <h2 id="cap2_cota_minima">Cota mínima</h2>
        <p>
          Después de ver distintos algoritmos que nos sirven para encontrar el cierre convexo, es natural
          preguntarnos, ¿podemos encontrar un algoritmo aún mejor en cuanto a complejidad en tiempo?
          <br>
          La respuesta es sencilla es no, y en esta sección ahondaremos un poco más en cómo
          es que podemos estar seguros de esto.
        </p>
        <p>
          Después de haber revisado los
          algoritmos anteriores, sabemos que la
          complejidad para calcular el cierre
          convexo es $O(nlogn)$, ¿cómo podemos
          demostrar que es lo mejor que podemos hacer?,
          para hacerlo deberíamos poder demostrar que
          $O(nlogn)$ es una cota inferior que se cumple
          para cualquier algoritmo que podamos pensar,
          y esto no es una tarea fácil, sin embargo,
          podemos
          <a target="_blank" href="https://en.wikipedia.org/wiki/Reduction_(complexity)">reducir</a>
          el problema de ordenamiento al problema de
          calcular el cierre convexo en tiempo lineal,
          pues sabemos que el problema de ordenamiento
          cuenta con una cota inferior
          de $\Omega (nlogn)$.
        </p>
        <p>
          La reducción se puede realizar de la
          siguiente manera. Supongamos que tenemos $k$
          números reales $n_1, \dots, n_k \in
          \mathbb{R}$, los cuales queremos ordenar. A
          partir de estos números construyamos un
          conjunto de puntos $S = p_0, p_1, p_2,\dots,
          p_{k}$ donde cada punto este definido como
          $p_i = (n_i, n_{i}^{2})$, lo cual corresponde
          a tomar cada número y mapearlo a un punto
          sobre el eje $x$, y a su vez este punto
          trasladarlo verticalmente al punto sobre la
          parábola unitaria que tiene la misma
          coordenada en $x$, como se muestra en la <ref ref_id="lower_bound_1"></ref>. Como se puede
          apreciar en la <ref ref_id="lower_bound_2"></ref>, el orden en el
          que los puntos aparecen en el cierre convexo
          inferior es justo el orden de los números
          $n_{i}$.
        </p>
      </div>

      <div class="page">
        <br>
        <figure id="lower_bound_1">
          <img src="./images/capitulo_02/Ejemplo_cota_inferior.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo del mapeo de un número $n_i$ al punto $(n_i,
            n_{i}^{2})$.
          </figcaption>
        </figure>
        <br>
        <figure id="lower_bound_2">
          <img src="./images/capitulo_02/Ejemplo_cota_inferior_cierre.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo obtener el cierre convexo del ejemplo anterior del mapeo.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Como podemos notar los puntos caen en una
          parábola, por lo que después de ejecutar
          nuestro algoritmo para calcular el cierre
          convexo en tiempo $T(n)$, todos los puntos se
          encuentran en el resultado, posteriormente
          buscamos al punto $p_0$ con la coordenada $x$ más
          pequeña, en tiempo $O(n)$, y ya que sabemos
          que nuestro algoritmo nos devuelve los puntos
          en orden contrario a las manecillas del
          reloj, los puntos a partir de $p_0$ están
          ordenados, podemos recorrerlos en $O(n)$,
          para finalmente obtener los números en $X$
          ordenados.
        </p>
        <p>
          Nos basta con hacer esto, pues, si tenemos un
          algoritmo con complejidad $T(n)$ para
          calcular el cierre convexo, entonces
          podríamos tener un algoritmo con complejidad
          $O(n) + T(n)$ para ordenar. Pero como sabemos que
          no podemos tener un algoritmo menor a
          $O(nlogn)$ para ordenar, esto nos resultaría
          en una contradicción, lo que nos deja con el
          algoritmo de calcular el cierre convexo con
          la misma cota inferior al algoritmo de
          ordenamiento.
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_bib">Bibliografía</h2>

        <bibitem id="CG_in_C">
          O'Rourke, Joseph. <b>Computational Geometry In C.
          </b> Cambridge University Press, February 15, 2001.
        </bibitem>

        <bibitem id="Discrete_and_CG">
          Satyan L. Devadoss, Joseph O'Rourke. <b>
            Discrete and Computational geometry. </b>
          Princeton University Press, 2011
        </bibitem>

        <bibitem id="CG_an_Introduction">
          Franco P. Preparata, Michael Ian Shamos. <b>
            Computational Geometry An Introduction </b>
          Springer-Verlag New York Inc, 1985
          Añadir páginas? Pag. 106
        </bibitem>

        <bibitem id="CG_an_Introduction">
          Preparata, F.P. <b>
            An optimal real-time algorithm for planar
            convex hulls
          </b> Commun. ACM, 22, 402-405. 1979
        </bibitem>
        https://en.wikipedia.org/wiki/Reduction_(complexity) (20/09/22)
      </div>

      <!--  -->
      <!-- CAPITULO 3: INTERSECCIÓN DE SEGMENTOS -->
      <!--  -->
      <div class="page">

        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="intersecciones_segmentos">Intersecciones entre segmentos de rectas</h1>
          <h1 class="chap_num">3</h1>
        </div>
        <p>
          El problema que se abordará en este capítulo
          es la intersección de segmentos de rectas,
          el cual se describe a continuación.
        </p>

        <h4><span class="bolded">Definición del problema.</span></h4>
        <p>
          Sea $S$ un conjunto de $n$ segmentos de recta cerrados
          en $\mathbb{R}^2$, encontrar todos los puntos de
          intersección entre los segmentos de $S$.
        </p>
        <p>
          Nótese que al considerar los segmentos en $S$ como
          cerrados, la intersección del inicio de
          un segmento de recta con el interior de otro segmento
          de recta, sí está considerado como intersección,
          como lo muestra la figura <ref ref_id="intersección"></ref>.
        </p>
        <figure id="intersección">
          <img src="./images/capitulo_03/interseccion.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo de intersecciones de segmentos de recta en rojo.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <h2 id="cap3_deteccion">Detección</h2>
        <p>
          Como primer acercamiento podemos comparar
          cada segmento de línea en el conjunto $S$
          contra todos los demás, lo cual es una buena
          idea, pues nos permite calcular todas las
          intersecciones entre los segmentos, además de
          que su complejidad es de $O(n^{2})$, lo cual,
          si pensamos detenidamente, es lo mejor que
          podemos hacer en el peor de los casos, esto
          es, cuando todos los segmentos se intersectan
          entre sí (como se muestra en la
          <ref ref_id="intersecciones_cuadrático"></ref>),
          pues justamente estamos revisando
          todas las intersecciones que puede haber
          entre los segmentos de línea en $S$.
        </p>
        <figure id="intersecciones_cuadrático">
          <img src="./images/capitulo_03/ejemplo_cuadratico.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo de intersecciones que requiere $O(n^2)$ comparaciones.
          </figcaption>
        </figure>
        <p>
          Sin embargo, en aplicaciones reales, dicho
          caso es poco común y resultaría bastante
          conveniente tener un algoritmo que sea más
          eficiente si el número de intersecciones es
          menor, tal como lo mencionamos en el
          capítulo anterior, un algoritmo sensible a la
          salida.
        </p>
      </div>

      <div class="page">
        <p>
          La idea que se utilizará para reducir la
          complejidad será hacer uso de un
          <a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm">
            algoritmo de barrido de línea
          </a>, para esto, simularemos hacer un barrido
          por el plano con una línea $l$ paralela al
          eje $x$ y solo compararemos los segmentos en
          $S$ que estén siendo intersectados al mismo
          tiempo por dicha línea $l$. De esta manera
          evitaremos comparar segmentos que están
          alejados en el eje $y$ y por lo tanto, que no
          se intersectan.
        </p>
        <figure id="barrido_de_línea_interactivo">
          <div class="interactive" width="570" height="420" window-size="false"
            src="./Interactivos/capitulo_3/descartesJS/barrido_de_línea_interactivo.html"></div>
          <figcaption>
            Ejemplo del barrido de línea, nótese como
            solo necesitamos comparar entre sí, a los
            segmentos que están siendo intersectados
            por la línea de barrido (segmentos de color
            verde).
          </figcaption>
        </figure>

      </div>

      <div class="page">
        <p>
          Implementar la idea del barrido de línea como
          se muestra en la
          <ref ref_id="barrido_de_línea_interactivo"></ref>
          puede parecer bastante complejo, sin embargo
          podemos simular el barrido en pasos
          discretos.
          <br>
          Para ello definamos el estado de la línea de
          barrido y los puntos que usaremos para
          cambiar el estado de la línea de forma
          discreta.
        </p>
        <h4><span class="bolded">Estado.</span></h4>
        <p>
          Diremos que el <b>estado</b> de la línea de
          barrido es el conjunto de segmentos en $S$
          que la intersectan.
          La figura <ref ref_id="barrido_de_línea_interactivo"></ref>
          muestra el estado de la línea de barrido en
          cada momento coloreando de color verde a los
          segmentos que forman parte del estado.
        </p>
        <h4>
          <span class="bolded">
            Punto de evento.
          </span>
        </h4>
        <p>
          Diremos que un punto es un
          <b>punto de evento</b>
          si es un punto en un extremo de algún
          segmento en $S$.
          La figura <ref ref_id="barrido_de_línea_interactivo"></ref>
          muestra el los puntos de evento como puntos
          de color negro, en los extremos de los
          segmentos.
        </p>
        <p>
          Para realizar el barrido de forma discreta,
          actualizaremos el estado de la línea de
          barrido solamente en los puntos de evento.
          En adición a esto, calcularemos las posibles
          intersecciones de igual manera, únicamente en
          los puntos de evento.
        </p>
        <p>
          Dicho esto, es claro que tenemos dos tipos de
          puntos de evento, cuando el punto de evento es
          el punto superior de un segmento y cuando es el
          punto inferior de un segmento. Ignoraremos el
          caso de líneas horizontales por el momento.
        </p>
        <p>
          En aquellos que son <b> punto superior</b>,
          agregaremos al segmento del que forman parte,
          al estado de la línea de barrido, y además,
          calcularemos las intersecciones con los demás
          segmentos en el estado.
        </p>
      </div>

      <div class="page">
        <p>
          En aquellos que son <b> punto inferior</b>,
          solamente tendremos que eliminar a dicho
          segmento del estado de la línea de barrido.
        </p>
        <p>
          La <ref ref_id="barrido_de_línea_interactivo_discreto"></ref>
          muestra cómo serían los pasos discretos del
          barrido de línea, donde en cada nuevo punto
          de eventos que forma parte del inicio de un
          segmento, se comprueba la intersección del
          segmento agregado contra todos los segmentos
          en el estado en ese momento (color verde).
          Nótese como en los puntos de evento 2, 5 y 7
          se encuentran intersecciones.
        </p>
        <figure id="barrido_de_línea_interactivo_discreto">
          <div class="interactive" width="500" height="450" window-size="false"
            src="./Interactivos/capitulo_3/descartesJS/barrido_de_línea_interactivo_discreto.html"></div>
          <figcaption>
            Ejemplo del barrido de línea, haciendo los
            pasos discretos.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Sin embargo, el número de comparaciones
          hechas realizando el algoritmo de esta
          manera, no nos proporciona un algoritmo
          sensible a la salida, como queríamos, un
          claro ejemplo de esto se muestra en la
          <ref ref_id="ejemplo_lineas_verticales"></ref>
          donde el estado de la línea de barrido tiene
          un punto donde todos los segmentos en $S$
          intersectan a la línea de barrido pero no hay
          ninguna intersección entre segmentos.
        </p>
        <figure id="ejemplo_lineas_verticales">
          <img src="./images/capitulo_03/lineas_verticales.svg" width="85%" height="85%">
          <figcaption>
            Ejemplo de segmentos que requieren $O(n^2)$
            comparaciones sin que haya intersecciones entre ellos.
          </figcaption>
        </figure>
        <p>
          El problema con este algoritmo, es que,
          aunque evitamos comparar segmentos que está
          alejados en el eje $y$, no evita comparar a
          los segmentos que están alejados en el eje
          $x$.
        </p>
        <p>
          Para poder evitar comparar los segmentos
          que están alejados en el eje $x$,
          mantendremos el orden de los segmentos que
          intersectan a la línea de barrido, por lo que
          agregaremos una propiedad al estado, este
          será formado por los segmentos ordenados por
          el componente en $x$ de intersección con la
          línea de barrido.
        </p>
      </div>
      <div class="page">
        <p>
          Además, actualizaremos este orden en cada
          punto de evento ya mencionado, y
          adicionalmente, también en los lugares donde
          los segmentos se intersectan, lo cual será un
          nuevo punto de evento.
        </p>
        <figure id="barrido_de_línea_interactivo_discreto">
          <div class="interactive" width="500" height="450" window-size="false"
            src="./Interactivos/capitulo_3/descartesJS/barrido_de_línea_interactivo_discreto_estados.html"></div>
          <figcaption>
            Ejemplo del barrido de línea con el estado
            ordenado, haciendo los pasos discretos.
          </figcaption>
        </figure>
        <p>
          Con esta modificación ahora tenemos tres
          tipos de puntos de eventos, los que son el
          <b> punto superior</b> de un segmento, los
          que son el <b> punto inferior</b>
          de un segmento y los que son una <b>intersección
            de partes internas de segmentos</b>.
        </p>
      </div>

      <div class="page">
        <p>
          Cabe destacar que los puntos que son una
          intersección de partes internas deben ser
          calculados mientras se ejecuta el algoritmo,
          es por esto, que debemos asegurar que sean
          detectados antes de que la línea de barrido
          pase por donde estos se encuentran. Para
          lograrlo, cada que dos segmentos de recta se
          vuelvan adyacentes a lo largo de la línea de
          barrido, revisaremos si dichos segmentos se
          intersectan en algún punto debajo de la línea
          de barrido. Realizar esta comprobación nos
          asegura detectar los puntos en el momento
          adecuado para la correcta ejecución del
          algoritmo.
        </p>
        <p>
          A continuación describiremos las acciones que
          se realizarán para cada tipo de punto de
          eventos:
        </p>
        <p>
          Caso 1: El punto de evento es el punto superior de un
          segmento.
          <br>
          Agregaremos en orden al nuevo
          segmento del que forma parte el punto de
          evento y comprobamos si hay intersección,
          entre el segmento agregado y los dos
          segmentos que están antes y después del nuevo
          segmento en el estado ordenado.
          Por ejemplo, si $S_b$ es el segmento agregado y
          $S_a , S_c$ son los segmentos que están
          antes y después en el estado, una vez que $S_b$
          fue insertado, comprobaremos intersecciones de
          $S_a$ con $S_b$, y $S_b$ con $S_c$.
        </p>
        <p>
          Caso 2: El punto de eventos es el punto inferior de un
          segmento
          <br>
          Eliminamos al segmento del que
          forma parte y comprobamos si no se
          intersectan los dos segmentos que estaban
          antes y después del segmento eliminado en el
          estado ordenado, pues ahora estos segmentos
          son adyacentes.
          Por ejemplo, si $S_b$ es el segmento eliminado y
          $S_a , S_c$ son los segmentos que están antes
          y después en el estado, una vez que $S_b$ fue
          eliminado, comprobaremos intersecciones de
          $S_a$ con $S_c$.
        </p>
      </div>

      <div class="page">
        <p>
          Caso 3: Es una intersección interna de dos
          segmentos.
          <br>
          Intercambiamos el orden de dichos segmentos,
          y comprobamos si el segmento más a la
          izquierda intersecta con el segmento que le
          precede y si el segmento más a la derecha
          intersecta con el segmento que le procede.
        </p>
        <p>
          La figura <ref ref_id="barrido_de_línea_interactivo_discreto"></ref>
          muestra un ejemplo de la ejecución del
          algoritmo, indicando en cuál de los 3 casos
          entra el punto de eventos que se ejecuta en
          cada momento.
        </p>
        <figure id="barrido_de_línea_interactivo_discreto">
          <div class="interactive" width="500" height="450" window-size="false"
            src="./Interactivos/capitulo_3/descartesJS/ejemplo_algoritmo.html"></div>
          <figcaption>
            Ejemplo del barrido de línea mejorado.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Ahora que tenemos la idea general del
          algoritmo, pasemos a describir el algoritmo
          por pasos y calcular su complejidad.
          <br>
          Pero antes de esto, definamos las estructuras de
          datos que requerimos para el algoritmo.
        </p>
        <p>
          Para mantener ordenados tanto los puntos de
          eventos como los segmentos del estado,
          haremos uso de árboles binarios de búsqueda
          balanceados.
        </p>
        <p>
          Llamaremos cola de eventos $C$ al árbol
          binario de búsqueda balanceado que usaremos
          para interactuar con los puntos de eventos.
          En dicha estructura necesitamos definir un
          orden para los puntos que almacenará, este lo
          definiremos de la siguiente manera.
        </p>
        <p>
          Sean $p$ y $q$ dos puntos de eventos, diremos
          que $p < q$ si $p_y> q_y$ o si $p_y = q_y$ y
            $p_x < q_x$ donde $p_y$ es la componente en $y$ de $p$ y $p_x$ su componente en $x$. </p>
              <p>
                Gracias a que $C$ es un árbol de
                búsqueda balanceado podemos insertar
                nuevos puntos de evento, lo cual es
                necesario en el caso en que notamos una
                nueva intersección y queremos añadir
                esta misma como nuevo punto de evento.
                También nos permite evitar insertar
                puntos de evento ya existentes, lo cual
                es útil cuando existen segmentos que se
                intersectan en los puntos extremos.
                Para esto, cada punto de evento
                presente en $C$ también contendrá todos
                los segmentos a los que corresponda
                dicho punto. Además podremos eliminar
                los puntos ya procesados.
                <br>
                Todas estas operaciones tomarán un
                tiempo logarítmico sobre el número de
                puntos, gracias a esta estructura.
              </p>
      </div>
      <div class="page">
        <p>
          Llamaremos Estado denotado como $E$ al árbol
          binario de búsqueda balanceado que usaremos
          para almacenar a la secuencia de segmentos
          que intersecta la línea de barrido, los
          cuales estarán ordenados de menor a mayor por
          la componente en $x$ del punto donde
          intersecta el segmento con la línea de
          barrido. Esta estructura, al igual que la
          anterior, nos permitirá insertar, consultar,
          y eliminar en tiempo logarítmico sobre el
          número de segmentos.
        </p>
        <h4><span class="bolded">Algoritmo</span></h4>
        <p>
          Inicialización:
          <br>
          Para comenzar el algoritmo necesitamos
          identificar los puntos de evento, como los
          puntos de evento del caso 3, son calculados
          al momento de correr el algoritmo, solo
          identificaremos a los puntos de los casos 1 y
          2. Por lo tanto crearemos a la cola de
          eventos $C$ con dichos puntos, como $C$ es un
          árbol binario de búsqueda balanceado este
          proceso nos tomará $O(nlog(n))$.
          De igual manera inicializaremos al Estado
          $E$ vacío lo que nos toma $O(1)$.
        </p>
        <p>
          Procesamiento de eventos:
          <br>
          En este paso procesaremos cada punto de
          evento en la cola de eventos $C$ hasta que no
          haya más puntos. Como ya describimos
          anteriormente hay 3 casos para procesar cada
          punto, y en cada uno de ellos se actualizan
          tanto al estado $E$ como a la cola de eventos
          $C$.
        </p>

        <p>
          Primero tomemos en cuenta la complejidad de
          realizar una operación sobre $E$, esta
          estructura puede llegar a tener $n$ elementos
          en el peor de los casos (cuando a línea de
          barrido intersecta a todos los segmentos al
          mismo tiempo), dicho esto ya que $E$ es un
          árbol binario de búsqueda balanceado,
          realizar una operación sobre $E$ nos tomará
          $O(log(n))$.
        </p>
      </div>

      <div class="page">
        <p>
          Ahora tomemos en cuenta la complejidad de
          actualizar $C$, esta estructura puede llegar
          a tener $2n + I$ elementos en el peor de los
          casos (tomando en cuenta que no agregamos
          eventos repetidos a $C$), donde $I$ es el
          número total de intersecciones en $S$. Ya que
          $C$ es un árbol binario de búsqueda
          balanceado, realizar una operación sobre $C$
          nos tomará $O(log(2n + I))$. Observemos que
          $I \leq n^{2}$ entonces la complejidad puede
          verse como:
          $$ O(log(n^{2})) = O(2log(n)) = O(log(n))$$
        </p>
        <p>
          Notemos que en cada punto de evento se agrega
          o elimina un número constante de segmentos,
          pues en el caso 1, se agrega un nuevo
          segmento, en el caso 2 se elimina un segmento
          de $E$ y en el caso 3 se cambia el orden de
          dos segmentos, lo que podemos realizar
          eliminando dichos segmentos y agregándolos de
          nuevo. En cuanto a puntos de evento, se
          agregan también un número constante de estos,
          pues en cada caso, solo se agrega uno por
          cada nueva intersección con algún segmento
          adyacente a los segmentos que fueron
          alterados.
        </p>
        <p>
          Por lo tanto, se realizarán a lo más un número
          constante de operaciones sobre $C$ y $E$, y
          cada operación en dichas estructuras tiene
          una complejidad de $O(log(n))$, la
          complejidad del procesamiento de todos los
          eventos será $$O((2n + I)log(n)) = O((n +
          I)log(n)) = O(nlog(n) + Ilog(n))$$
        </p>
        <p>
          Tomando en cuenta las
          complejidades de la inicialización
          $O(nlog(n))$ y del procesamiento de todos los
          puntos de evento $O(nlog(n) + Ilog(n))$,
          podemos concluir que la complejidad del
          algoritmo completo es $O(nlog(n) + Ilog(n))$.
        </p>
      </div>

      <div class="page">
        <h2 id="cap3_lista_doblemente_ligada">Lista
          doblemente conexa de aristas</h2>
        <p>
          En la sección anterior, resolvimos el
          problema de encontrar las intersecciones
          entre un conjunto de segmentos, lo cual nos
          resulta útil en sistemas tipo GIS (sistema de
          información geográfica), en específico para
          sobreponer dos mapas, pues podemos ver a cada
          mapa como un conjunto de segmentos, y con
          esto lograr encontrar las intersecciones de
          ambos mapas.
          <br>
          Sin embargo, hay otras situaciones en las que
          nos interesa sobreponer dos mapas,
          donde estos cuentan con más
          información.
          <br>
          Un ejemplo son mapas como el
          presente en la <ref ref_id="mapa_bioclimas"></ref>.
        </p>
        <figure id="mapa_bioclimas">
          <img src="./images/capitulo_03/mapa_bioclimas.jpg" width="100%" height="100%">
          <figcaption>Ejemplo de un mapa con subdivisiones de bioclimas.
            (https://www.scielo.org.mx/img/revistas/igeo/n95//2448-7279-igeo-95-00004-gf3.jpg)</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Como podemos ver en la <ref ref_id="mapa_bioclimas"></ref>,
          dicho mapa cuenta con más información que
          solo segmentos de rectas, ya que estos mapas
          representan subdivisiones del plano en
          regiones etiquetadas. Un ejemplo de esto es
          el típico mapa de la republica mexicana donde
          el mapa es una subdivisión del plano donde
          las áreas están etiquetadas por los estados
          que conforman al país.
        </p>
        <p>
          Ya que las subdivisiones son formas bastante
          útiles de representar mapas, resulta
          interesante buscar la forma de calcular la
          intersección de dos subdivisiones.
          <br>
          Sin embargo, antes es necesario
          representar dichas subdivisiones, por lo
          que este será el tema a tratar en la presente
          sección.
        </p>
        <p>
          Comencemos definiendo lo siguiente.
        </p>
        <p>
          Subdivisión
          <br>
          Diremos que una subdivisión plana es una
          estructura inducida por un conjunto de
          segmentos de línea que solo pueden
          intersectarse por extremos compartidos.
        </p>
        <figure id="mapa_bioclimas">
          <img src="./images/capitulo_03/ejemplo_subdivision.svg" width="70%" height="70%">
          <figcaption>Ejemplo de subdivisión.</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Diremos que una subdivisión estará formada
          por los siguientes elementos.
        </p>
        <p>
          Vértices
          <br>
          Los vértices de una subdivisión
          son los puntos extremos de los segmentos de
          línea.
        </p>
        <p>
          Aristas
          <br>
          Las aristas de una subdivisión
          son los segmentos de línea, sin los puntos
          extremos de los mismos.
        </p>
        <p>
          Caras
          <br>
          Una cara de una subdivisión es un
          subconjunto conexo maximal del plano, que no
          contiene ni aristas ni vértices.
        </p>
        <figure id="barrido_de_línea_interactivo_discreto">
          <div class="interactive" width="500" height="340" window-size="false"
            src="./Interactivos/capitulo_3/descartesJS/ejemplo_punto_superior_elementos.html"></div>
          <figcaption>
            Ejemplo de los elementos que forman a una
            subdivisión, al seleccionar cada opción se
            muestran en color verde.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Sea $v$ un vértice, $a$ una arista y $c$ una
          cara, si $v$ está en un extremo de $a$
          diremos que $v$ y $a$ son incidentes, si $v$
          está en el perímetro de $c$ entonces $v$ y
          $c$ son incidentes, de igual manera si $a$
          está en el perímetro de $c$ entonces $a$ y
          $c$ son incidentes.
        </p>
        <p>
          En la <ref ref_id="ejemplo_subdivision_incidencia"></ref>
          se pueden apreciar los siguientes ejemplos de
          incidencias:

        </p>
        <p>
          El vértice verde y la arista azul son incidentes.
          <br>
          El vértice verde y la cara morada son incidentes.
          <br>
          La arista azul y la cara morada son incidentes.
        </p>
        <figure id="ejemplo_subdivision_incidencia">
          <img src="./images/capitulo_03/ejemplo_subdivision_incidencia.svg" width="90%" height="90%">
          <figcaption>
            Ejemplo de subdivisión con un vértice en
            verde, una arista en azul y una cara en
            morado, todos ellos incidentes.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Habiendo definido esto, podemos comenzar a
          describir la estructura de datos que usaremos
          para representar una subdivisión.
          <br>
          Dicha estructura es llamada <b>lista de
            aristas doblemente conectadas</b>
          o <b>DCEL</b> por sus siglas en inglés.
        </p>
        <p>
          Para representar una subdivisión, una lista
          de aristas doblemente conectadas contendrá
          información de cada vértice, arista y cara de
          la subdivisión.
        </p>
        <p>
          A cada arista le daremos una dirección, y así
          podremos almacenar un apuntador de una arista
          a su siguiente y un apuntador a su anterior,
          esto nos ayudará a poder hacer un recorrido
          alrededor de las caras de la subdivisión
          tanto en sentido de las manecillas del reloj
          como al contrario.
        </p>
        <figure id="ejemplo_apuntadores">
          <img src="./images/capitulo_03/ejemplo_apuntadores.svg" width="90%" height="90%">
          <figcaption>
            Ejemplo de aristas con apuntadores a la
            siguiente arista alrededor de una cara.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Además, para evitar tener múltiples aristas
          siguientes para cada arista, dividiremos cada
          arista en dos mitades yendo de extremo a
          extremo pero en direcciones
          opuestas, cada mitad será una <b>media-arista</b>,
          las dos medias-aristas que surgen de una
          misma arista serán llamadas <b>gemelas</b>,
          dichas aristas tienen direcciones opuestas,
          podemos llamar <b>origen</b> al vértice
          de donde surge una media-arista y
          <b>destino</b> el vértice a donde apunta,
          entonces dos aristas gemelas comparten los
          mismos extremos pero lo que para una es el
          origen para la otra es el destino y
          viceversa. Por lo regular una arista tendrá
          dos caras a las cuales es incidente, entonces
          dicha división además nos permite que cada
          media-arista sea incidente a una sola cara y
          así guarde un solo apuntador a dicha cara.
          Para asegurar un orden en cuanto a las
          aristas, diremos que la cara con la que una
          media-arista es incidente está a la izquierda
          de dicha media-arista.
        </p>
        <figure id="ejemplo_apuntadores_medias_aristas">
          <img src="./images/capitulo_03/ejemplo_apuntadores_medias_aristas.svg" width="90%" height="90%">
          <figcaption>
            Ejemplo de medias-aristas que apuntan a la
            siguiente alrededor de una cara y solo son
            incidentes a una sola cara.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          De esta manera cada media-arista tiene una
          sola media-arista siguiente, facilitando de
          esta manera el recorrido al rededor de una
          cara y añadiendo la posibilidad de calcular
          el perímetro de una cara a partir de conocer
          únicamente una media-arista.
          <br>
          Sin embargo en el caso en que una cara tenga
          agujeros necesitaremos conocer al menos una
          media-arista correspondiente a cada agujero
          dentro de la cara, la siguiente <ref ref_id="ejemplo_cara_con_agujeros"></ref>
          muestra una cara con agujeros, notemos como
          además la dirección de las medias-aristas de
          las subdivisiones dentro de las caras se
          conserva, siendo las medias-aristas
          incidentes por la izquierda con una cara.
        </p>
        <figure id="ejemplo_cara_con_agujeros">
          <img src="./images/capitulo_03/ejemplo_cara_con_agujeros.svg" width="90%" height="90%">
          <figcaption>
            Ejemplo de cara con agujeros.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Con esta estructura para representar
          medias-aristas podemos describir más
          claramente como representar a todos los
          vértices, aristas y caras de nuestra lista de
          aristas doblemente conectadas a continuación:
        </p>

        <p>
          Un vértice será formado por:
        <ul>
          <li>
            Coordenadas: los valores de las coordenadas
            de la posición del vértice.
          </li>
          <li>
            Arista incidente: apuntador a alguna
            media-arista arbitraria que tenga como
            origen al vértice.
          </li>
        </ul>
        </p>

        <p>
          Una media-arista será formada por:
        <ul>
          <li>
            Origen: apuntador al vértice origen de la
            media-arista.
          </li>
          <li>
            Gemela: apuntador a la media-arista gemela
            de esta media-arista.
          </li>
          <li>
            Cara incidente: apuntador a la cara a la
            que esta media-arista es incidente.
          </li>
          <li>
            Siguiente: apuntador a la media-arista
            siguiente en el perímetro de la cara
            incidente de esta media-arista.
          </li>
          <li>
            Anterior: apuntador a la media-arista
            anterior en el perímetro de la cara
            incidente de esta media-arista.
          </li>
        </ul>
        </p>

        <p>
          Una cara será formada por.
        <ul>
          <li>
            Componente externo: apuntador a alguna
            media-arista que pertenece al perímetro de
            la cara, esto es alguna media-arista que
            sea incidente a la cara, pero que no
            pertenezca a un agujero dentro de la cara.
            Nótese que siempre hay una cara que no
            tiene límites, en este caso el apuntador
            irá a null.
          </li>
        </ul>
        </p>
      </div>

      <div class="page">
        <ul>
          <li>
            Componentes internos: lista que para cada
            agujero en la cara, contiene un apuntador a
            una media-arista en dicho agujero, tal que
            la media-arista es incidente a la cara.
          </li>
        </ul>
        <figure id="cierre-convexo">
          <div class="interactive" width="450" height="500" window-size="false"
            src="./Interactivos/capitulo_3/DCEL_example.html"></div>
          <figcaption>Ejemplo de una lista de aristas doblemente conectadas.</figcaption>
        </figure>
      </div>

      <div class="page">
        <h2 id="cap3_calculando_traslape">Calculando el
          traslape de dos subdivisiones</h2>
        <p>
          Ahora que sabemos cómo representar
          subdivisiones usando la lista de aristas
          doblemente conectadas, podemos proceder a
          calcular el traslape de dos subdivisiones.
          <br>
          Para ello, primer definamos lo que es un traslape:
        </p>
        <p>
          Sean $S1$ y $S2$ dos subdivisiones,
          definiremos a la subdivisión $T(S1,S2)$ como
          el traslape de ambas donde existe una cara
          $c$ en $T(S1,S2)$ si y solo si existen las
          caras $c1$ en $S1$ y $c2$ en $S2$ tal que $c$
          es un subconjunto maximal conexo de $c1 \cap
          c2$.
        </p>
        TODO: Ejemplo de definición de traslape de dos
        subdivisiones.
      </div>

      <div class="page">
        <p>
          Entonces definamos el problema de calcular el
          traslape de dos subversiones como:
        </p>
        <p>
          Dadas dos subdivisiones $S1$ y $S2$
          representadas como lista de aristas
          doblemente conectadas, calcular la lista de
          aristas doblemente conectadas del traslape
          $T(S1,S2)$. Además para cada cara en
          $T(S1,S2)$ agregar las etiquetas de las caras
          en $S1$ y $S2$ que la contienen.
        </p>
        <p>
          Para comenzar con el problema, notemos que
          para calcular $T(S1,S2)$, podemos seguir
          utilizando las mismas medias-aristas de $S1$
          y $S2$, excepto aquellas donde hay
          intersecciones entre medias-aristas de
          subdivisiones distintas.
        </p>
        <p>
          Tomando esto en cuenta, podemos pensar al
          algoritmo de la siguiente manera. Comenzamos
          creando una nueva lista de aristas doblemente
          conectadas y copiamos todas las
          medias-aristas en $S1$ y $S2$ en ella. Lo que
          nos dejará con una lista de aristas
          doblemente conectadas mal formada. A
          continuación modificamos la nueva lista de
          aristas doblemente conectadas de tal forma que
          se convierta en un traslape valido
          $T(S1,S2)$, agregado las nuevas
          intersecciones entre las $S1$ y $S2$, y
          realizando las modificaciones necesarias para
          conectar dichas intersecciones. Y para
          finalizar, actualizamos la información de las
          nuevas caras en $T(S1,S2)$.
        </p>
        <p>
          De estas 3 partes en que podemos dividir el
          algoritmo, la que realmente resulta
          interesante es la de obtener el traslape
          teniendo las medias-aristas de $S1$ y $S2$.
          Esto lo haremos detectando intersecciones con
          un algoritmo basado en el de barrido de línea
          que ya fue abordado al inicio de este
          capítulo.
        </p>
      </div>

      <div class="page">
        bibliografía
        https://www.cs.tulane.edu/~carola/teaching/cmps3130-6130/spring15/slides/pointLocation.pdf
        02/12/22
        https://xlinux.nist.gov/dads/HTML/planarstrght.html
        02/12/22

      </div>


      <!--  -->
      <!-- CAPITULO 4: TRIANGULACIÓN Y VISIBILIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="triangulacion_divisibilidad">
            Triangulación de polígonos y visibilidad
          </h1>
          <h1 class="chap_num">4</h1>
        </div>
        <p>
          Para comenzar con el problema de la
          triangulación de polígonos, antes tomaremos
          en cuenta un problema relacionado con ello.
          <br>
          Dicho problema suele ser llamado el problema
          de la galería de arte, el cual describiremos
          a continuación.
        </p>
        <p>
          Supongamos que queremos resguardar las
          valiosas piezas de una galería de arte, y
          para ello usaremos cámaras para vigilar cada
          parte de la galería fácilmente, dichas
          cámaras pueden rotar para abarcar un área más
          grande, sin embargo nos interesaría poder
          hacer uso de la menor cantidad de cámaras
          posibles, ya que, todas estas serían
          transmitidas a un conjunto de pantallas que
          una persona se encargaría de vigilar, y
          resulta menos problemático vigilar solo una
          cantidad reducida de pantallas. Sin embargo,
          no podemos tener tan pocas cámaras al punto
          que no podamos vigilar cada área de la
          galería.
          <br>
          Entonces, lo que queremos es
          saber cuál sería el menor número de cámaras
          necesarias para vigilar toda la galería,
          además, dado que dependiendo de donde se
          pone cada cámara puede vigilar una área
          distinta, también queremos saber, en que
          partes de la galería poner dichas cámaras.
        </p>
        <h2 id="cap4_vigilancia_triangulaciones">Vigilancia y triangulaciones</h2>
        <p>
          Ya tenemos la idea del problema que queremos
          resolver, ahora veamos que tiene que ver
          este problema con las triangulaciones de
          polígonos.
        </p>
        <p>
          Para comenzar, podemos abstraer una galería
          de arte a un polígono
        </p>
      </div>

      <div class="page">
        <p>
          en 2 dimensiones y trabajar sobre este
          polígono, pues podemos ver a la galería como
          un plano arquitectónico de la misma y sobre este buscar los
          puntos donde poner las cámaras.
          <!-- https://thetourguy.com/travel-blog/france/paris/louvre/top-ten-things-to-see-at-the-louvre-museum/
          17/11/2022 imagen louvre -->
        <figure id="poligono_condiciones">
          <img src="./images/capitulo_04/Map_Great-Sphinx-of-Tanis_Louvre_The-Tour-Guy-750x420.jpg" width="90%"
            height="90%">
          <figcaption>Ejemplo de un plano arquitectónico del
            famoso museo Louvre.
            (https://thetourguy.com/travel-blog/france/paris/louvre/top-ten-things-to-see-at-the-louvre-museum/
            17/11/2022)</figcaption>
        </figure>
        </p>

        <p>
          Sin embargo, para motivos de estas notas, no
          trabajaremos polígonos como este plano del
          museo Louvre, ya que nos limitaremos a
          trabajar con
          <span class="bolded">polígonos simples</span>
          (que no tienen intersecciones consigo mismo y no
          tienen agujeros).
        </p>
        <p>
          Ahora que tenemos una abstracción para las
          galerías, ¿qué hay de las cámaras? Estas las
          podemos representar con un punto que esté
          dentro del polígono.
          <br>
          Además, diremos que esta cámara puede vigilar
          todos los puntos en el polígono a los que
          pueda trazar un segmento de tal manera que
          dicho segmento esté contenido totalmente en
          el polígono.
          <br>
          En la <ref ref_id="camara"></ref> se muestra
          un ejemplo de esto.
        </p>
      </div>

      <div class="page">
        <figure id="camara">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_4/intuitive_idea_Camera.html"></div>
          <figcaption>Ejemplo de la idea de una cámara
            (punto) en una galería (polígono simple) y el
            área que puede vigilar (área
            blanca).</figcaption>
        </figure>
        <p>
          Ahora que tenemos estas abstracciones,
          podemos preguntarnos, ¿cuántas cámaras
          necesitamos para vigilar totalmente un
          polígono simple?
        </p>
        <p>
          Podemos hablar del
          número de cámaras en términos del número de
          aristas de nuestro polígono, sin embargo, no
          nos podemos guiar únicamente por el número de
          vértices ya que a pesar de que calcular el
          número de cámaras para polígonos convexos no
          implica mayor dificultad, ya que pueden ser
          vigilados en su totalidad por una sola
          cámara, el número de vértices no nos dice
          mucho para cualquier polígono no convexo.
          <br>
          De hecho, el calcular el número mínimo
          necesario de cámaras necesarias para vigilar
          un polígono simple es un problema
          <a
            href="https://es.wikipedia.org/wiki/NP-hard#:~:text=En%20teoría%20de%20la%20complejidad,ser%20transformado%20polinomialmente%20en%20H.">
            <b>NP-Difícil</b>
          </a>.
        </p>
      </div>
      <div class="page">
        <p>
          A pesar de que no podemos obtener la mejor
          solución del problema, podemos calcular una muy buena
          solución al problema haciéndolo más fácil,
          descomponiendo el polígono en piezas más
          pequeñas.
        </p>
        <p>
          ¿Cómo podríamos descomponer el polígono en
          piezas más pequeñas? Sabemos que los
          polígonos convexos solo requieren una cámara
          para ser vigilados por lo que nos resultaría
          útil trabajar con polígonos convexos, sin
          embargo, para hacer la descomposición aún más
          simple, descompondremos el polígono en
          triángulos.
          <br>
          Aquí es donde entra la triangulación de polígonos,
          pero antes de abordarla, definamos que es una diagonal.
        </p>
        <p>
        <h4><span class="bolded">Diagonal.</span></h4>
        Es un segmento de línea recta abierto (no
        incluye los puntos extremos) que conecta dos
        vértices de un polígono $P$ tal que cada punto
        de este segmento yace completamente dentro del
        interior de $P$ (el área sin incluir al
        perímetro de $P$).
        </p>
        <figure id="diagonales">
          <img src="./images/capitulo_04/diagonales.svg" width="90%" height="90%">
          <figcaption>Ejemplo de un segmento que sí es diagonal(verde) y un segmento que no es diagonal(rojo) ya que el
            segmento no está contenido completamente en el polígono.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
        <h4><span class="bolded">Triangulación de un polígono.</span></h4>
        Es una descomposición de un polígono en un
        conjunto de triángulos por un conjunto
        maximal de diagonales que no se intersectan
        entre ellas.
        </p>
        <br>
        <figure id="triangulaciones_validas">
          <img src="./images/capitulo_04/Triangulacion.svg" width="70%" height="70%">
          <figcaption>Ejemplo de dos triangulaciones validas diferentes.
          </figcaption>
        </figure>
        <br>
        <figure id="triangulaciones_validas">
          <img src="./images/capitulo_04/NoTriangulacion.svg" width="70%" height="70%">
          <figcaption>Ejemplo de dos triangulaciones no
            validas diferentes, en la primera hay dos
            diagonales que se intersectan entre ellas, en
            la segunda no hay una cantidad maximal de
            diagonales, pues aún se puede añadir a una
            más.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Las triangulaciones no suelen ser únicas,
          como se puede apreciar en la <ref ref_id="triangulaciones_validas"></ref>,
          sin embargo, esto nos importa, dado que
          teniendo alguna triangulación, podemos
          colocar una cámara en cada triángulo para
          poder resolver nuestro problema.
        </p>
        <p>
          Lo que realmente nos interesa, es saber si
          siempre es posible encontrar alguna
          triangulación para cualquier polígono simple.
          La respuesta es sí, además, si el polígono
          simple tiene $n$ vértices, el número de triángulos
          resultantes son $n - 2$.
        </p>
        <p>
        <div class="bolded">
          De todo polígono simple se puede obtener una
          triangulación, y cualquier triangulación de
          un polígono simple de $n$ vértices consistirá
          de $n - 2$ vértices.
        </div>
        </p>
        <div class="bolded">
          Caso Base: $n = 3$ (triángulo)
        </div>
        <p>
          En este caso el triángulo ya está triangulado por definición
          y para sus $n = 3$ lados, contiene $n - 2 = 3 - 2 = 1$ un triángulo.
        </p>
        <div class="bolded">
          Hipótesis de inducción
        </div>
        <p>
          Supongamos que para un polígono con $n = k$ su triangulación
          existe y tiene $k - 2$ triángulos.
        </p>

        <div class="bolded">
          Paso inductivo: Demostrar para $n = k + 1$
        </div>
        <p>
          Sea $P$, nuestro polígono simple de $k + 1$
          vértices, tomemos al vértice $v$ más a la
          izquierda, esto es, el vértice con la menor
          coordenada en $x$, en caso de tener dos,
          tomaremos al que tenga la menor coordenada en
          $y$ y no habrá más de dos con el mismo valor
          de $x$ pues asumimos que no hay 3 puntos
          colineales en $P$.
        </p>
      </div>
      <div class="page">
        <p>
          A continuación definimos como $u$ y $w$ los
          vértices que comparten arista con $v$, y
          trazamos un segmento de recta de $u$ a $w$.
          <br>
          Esto nos deja con dos posibles casos,
          $\overline{uw}$ es diagonal o no.
        </p>
        <figure id="triangulaciones_validas">
          <img src="./images/capitulo_04/Demostración.svg" width="60%" height="60%">
          <figcaption>Ejemplo de los dos casos, cuando
            $\overline{uw}$ es diagonal(verde) y cuando
            no lo es(rojo).
          </figcaption>
        </figure>
        <p>
          Si $\overline{uw}$ es diagonal, podemos
          agregar esa diagonal y nos deja a un
          triángulo y un polígono $k$ vértices, el cual
          por hipótesis de inducción sabemos que tiene
          una triangulación con $k - 2$ triángulos,
          esto nos deja con $k - 1$ triángulos en
          total, lo cual es justo el número de vértices
          menos dos, $n - 2 = (k + 1) - 2 = k - 1$.
        </p>
        <figure id="demostracion_caso_1">
          <img src="./images/capitulo_04/Demostracin_caso1.svg" width="35%" height="35%">
          <figcaption>Ejemplo del caso uno, con un
            triángulo(verde) y un nuevo polígono(azul)
            después de agregar la diagonal.
          </figcaption>
        </figure>

      </div>
      <div class="page">
        <p>
          Si $\overline{uw}$ no es diagonal, significa
          que dentro del triángulo $uvw$ hay al menos
          un vértice de $P$, entonces debemos de buscar
          entre dichos vértices, un vértice $\mu$ que
          nos asegure que el segmento $\overline{v\mu}$
          es diagonal, el cual es el vértice dentro de
          $uvw$ que esté más lejos del segmento
          $\overline{uw}$, pues al ser el vértice más
          lejano al segmento $\overline{uw}$, nos
          asegura que entre $v$ y $\mu$ no hay ninguna
          arista de $P$, por lo tanto $\overline{v\mu}$
          es diagonal.
        </p>
        <p>
          Con $\overline{v\mu}$ como diagonal, podemos
          dividir el polígono en 2 polígonos, uno con
          $m$ vértices y el otro con $ (k + 1) - m + 2$
          vértices ($k + 1$ el tamaño original, $m$
          tamaño del otro polígono, $2$ número de
          vértices que comparten ambos polígonos).
          <br>
          Ahora bien, por hipótesis de inducción
          sabemos que ambos polinomios tienen una
          triangulación que consiste de $m - 2$ y $ ((k
          + 1) - m + 2) - 2$ triángulos,
          respectivamente, los cuales al sumarlos nos
          deja con $(k + 1) - 2 = k - 1$ lo cual es
          precisamente el número de vértices de $P$
          menos dos.
        </p>
        <figure id="demostracion_caso_1">
          <img src="./images/capitulo_04/Demostracin_caso2.svg" width="65%" height="65%">
          <figcaption>Ejemplo del caso dos, con un
            polígono de $m$ vértices (verde) y un polígono de $ (k + 1) - m + 2$ vértices(azul)
            después de agregar la diagonal.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Habiendo demostrado lo anterior, ya podemos
          resolver el problema, calcular la
          triangulación del polígono $P$ y colocar una
          cámara en cada triángulo lo que nos dejaría
          con $n - 2$ cámaras, sin embargo, esa es una
          gran cantidad de cámaras, así que conviene
          buscar una mejor forma de resolverlo.
        </p>
        <p>
          Una mejor forma de resolverlo sería colocar
          las cámaras en vértices de nuestra
          triangulación, en lugar de en cada triángulo,
          ya que un solo vértice puede vigilar varios
          triángulos y eso nos ahorraría muchas
          cámaras.
          <br>
          El problema ahora sería, ¿cómo escoger dichos
          vértices?, para hacer esto podemos calcular
          una 3-coloración a la triangulación de
          nuestro polígono $P$. A continuación se
          explica cómo calcular dicha coloración.
        </p>
        <p>
          Sea $P$ un polígono simple, para calcular la
          3-coloración de $T(P)$, colorearemos cada
          vértice de $T(P)$ con 3 colores distintos, de
          tal manera que ningún vértice esté conectado
          con otro vértice del mismo color, a través de
          una arista de $P$ o una diagonal de $T(P)$.
        </p>
        <figure id="demostracion_caso_1">
          <img src="./images/capitulo_04/3_coloracion.svg" width="45%" height="45%">
          <figcaption>Ejemplo de 3-coloración, donde
            nos resulta conveniente ponerlas cámaras en
            los vértices verdes que son precisamente
            $\lfloor n/3 \rfloor = \lfloor 8/3 \rfloor =
            2$.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          La 3-coloración ya mencionada, siempre puede
          ser calculada para una triangulación de un
          polígono simple, sin embargo, la demostración
          no será abordada en estas notas.
        </p>
        <p>
          Al tener la 3-coloración de $T(P)$ para
          vigilar todo $P$ podemos simplemente colocar
          una cámara en todos los vértices que
          correspondan a un solo color, ya que por
          construcción cada triángulo tendrá un vértice
          de cada color.
          <br>
          El color que escojamos no importa, pero sí
          importa el número de cámaras utilizadas,
          dicho esto, podemos escoger el color con
          menor número de vértices y poner una cámara
          en cada vértice de dicho color.
        </p>
        <p>
          Con esta coloración, ahora podemos colocar
          solo $ \lfloor n/3 \rfloor $ cámaras, y dado
          que sabemos que siempre podemos encontrar una
          triangulación y a su vez una 3-coloración,
          podemos decir que para vigilar un polígono
          simple resultan suficientes $ \lfloor n/3
          \rfloor $ cámaras, lo que nos deja la duda.
          <br>
          ¿Podrá hacerse con menos cámaras?
          <br>
          La respuesta es sí, pero no siempre es
          posible, como en el ejemplo de la
          <ref ref_id="peine"></ref>,
          el cual es un ejemplo
          muy común de un polígono simple que no puede
          ser vigilado con menos de $ \lfloor n/3
          \rfloor
          $.
        </p>
        <figure id="peine">
          <img src="./images/capitulo_04/Peine.svg" width="45%" height="45%">
          <figcaption>
            Este polígono tiene 3 vértices
            para cada "pico", y no es posible colocar
            menos de $ \lfloor n/3 \rfloor $, pues es
            necesario tener al menos una para cada
            "pico".
          </figcaption>
        </figure>
        peine interactivo?
      </div>

      <div class="page">
        <h2 id="cap4_dividiendo_polígono">Dividiendo un
          polígono en piezas monótonas</h2>
        <p>
          Con lo aprendido hasta ahora podemos
          empezar a buscar un algoritmo para resolver
          el problema, recordando que siempre hay una
          triangulación para un polígono simple,
          podemos construir dicha triangulación de la
          misma manera en que se construyó la
          demostración.
          <br>
          Construir la triangulación de esta manera
          resultaría en una complejidad de $O(n^{2})$
          ya que en el peor de los casos cada nueva diagonal
          agregada sería de estilo del caso 2(agregar ref),
          tomando $O(n)$ para agregar cada diagonal,
          ya que requiere buscar el vértice más lejano a
          $\overline{uv}$. A su vez cada diagonal añadida
          solo agregaría un triángulo por lo que este
          proceso se tomaría también $O(n)$.
        </p>
        <p>
          Es por esta razón por la que buscando mejorar
          dicha complejidad dividiremos el polígono
          simple inicial, en polígonos más fáciles de
          triangular.
          <br>
          Dichos polígonos son llamados, <b>polígonos
            monótonos</b>, y a continuación
          profundizaremos en su definición y en una
          forma eficiente de particionar nuestro
          polígono simple, en polígonos monótonos.
        </p>
      </div>

      <div class="page">

        <h4><span class="bolded">Polígono monótono.</span></h4>
        <p>
          Un <b>polígono monótono</b> con respecto a
          una línea $l$, es un polígono simple $P$ tal
          que para cualquier línea $l'$ perpendicular a
          $l$, si $P$ y $l'$ se intersectan, la
          intersección del polígono $P$ y $l'$ es un
          segmento de línea o un punto.
        </p>
        <p>
          Adicionalmente podemos definir como
          <b>$x$-monótonos</b>
          y <b>$y$-monótonos</b> a los polígonos que
          son monótonos con respecto al eje $x$ y $y$
          respectivamente.
        </p>
        <p>
          La <ref ref_id="poligonos_monotonos"></ref>
          muestra 2 polígonos distintos los cuales
          podemos verificar si son $x$-monótonos o
          $y$-monótonos deslizando una línea vertical u
          horizontal a lo largo del polígono.
        </p>

        <figure id="poligonos_monotonos">
          <div class="interactive" width="300" height="200" src="./Interactivos/capitulo_4/poligonos_monotonos.html">
          </div>
          <figcaption>Ejemplo de polígonos <b>$x$-monótonos</b>
            y <b>$y$-monótonos</b>$$.
          </figcaption>
        </figure>
        <br>


      </div>

      <div class="page">
        <p>
          De estos dos tipos de polígonos monótonos,
          nos interesa particionar nuestro polígono
          simple inicial en polígonos $y$-monótonos
          para poder calcular la triangulación de una
          forma más eficiente.
          <br>
          Pero, ¿Cómo podemos particionar en polígonos
          $y$-monótonos de forma eficiente?
        </p>
        <p>
          Para comenzar, notemos que cuando hacemos un
          recorrido de arriba a abajo por los vértices
          de un polígono $y$-monótono, estos cumplen la
          propiedad de que las aristas que conectan a
          los vértices nunca van de abajo a arriba,
          como se muestra en la Figura TODO. Propiedad
          de polígonos monótonos.
        </p>
        TODO: ejemplo con flechas apuntando a abajo.
      </div>

      <div class="page">
        <p>
          Para poder lograr que dicha condición se
          cumpla es útil saber cuáles son los tipos de
          formas, que pueden tener las aristas que
          conectan a los vértices en los polígonos. Es
          por ello que procederemos a clasificar a los
          vértices pertenecientes a polígonos simples
          de la siguiente manera.
        </p>
        <p>
          Diremos que un vértice $v$ es <b>vértice
            vuelta</b>
          si los vértices $u$ y $w$ adyacentes a $v$
          tienen ambos coordenadas en $y$ mayores a la
          coordenada en $y$ de $v$ o de lo contrario
          tienen ambos coordenadas en $y$ menores a la
          coordenada en $y$ de $v$.
        </p>

        <figure id="vertices_vuelta">
          <img src="./images/capitulo_04/Vertices_vuelta.svg" width="65%" height="65%">
          <figcaption>
            Este polígono tiene 3 vértices
            para cada "pico", y no es posible colocar
            menos de $ \lfloor n/3 \rfloor $, pues es
            necesario tener al menos una para cada
            "pico".
          </figcaption>
        </figure>

        <p>
          Este tipo de vértices los podemos clasificar
          en 4 distintos, vértices
          <b>principio</b>, <b>final</b>,
          <b>separación</b> y <b>unión</b>.
        </p>
      </div>

      <div class="page">
        <h4><span class="bolded">Vértice
            principio.</span></h4>
        <p>
          Diremos que un vértice $v$ es vértice
          principio, si los vértices $u$ y $w$
          adyacentes a $v$ tienen coordenadas en $y$
          menores a la coordenada en $y$ de $v$ y
          además el ángulo interior de $v$ es menor a
          $180^{\circ}$.
        </p>
        TODO:imagen

        <h4><span class="bolded">Vértice
            separación.</span></h4>
        <p>
          Diremos que un vértice $v$ es vértice
          principio, si los vértices $u$ y $w$
          adyacentes a $v$ tienen coordenadas en $y$
          menores a la coordenada en $y$ de $v$ y
          además el ángulo interior de $v$ es mayor a
          $180^{\circ}$.
        </p>
        TODO:imagen
      </div>

      <div class="page">
        <h4><span class="bolded">Vértice
            final.</span></h4>
        <p>
          Diremos que un vértice $v$ es vértice
          principio, si los vértices $u$ y $w$
          adyacentes a $v$ tienen coordenadas en $y$
          mayores a la coordenada en $y$ de $v$ y
          además el ángulo interior de $v$ es menor a
          $180^{\circ}$.
        </p>
        TODO:imagen
        <h4><span class="bolded">Vértice unión.</span></h4>
        <p>
          Diremos que un vértice $v$ es vértice
          principio, si los vértices $u$ y $w$ adyacentes a $v$
          tienen coordenadas en $y$ mayores a la
          coordenada en $y$ de $v$ y además el ángulo
          interior de $v$ es mayor a $180^{\circ}$.
        </p>
        TODO:imagen
      </div>

      <div class="page">
        <p>
          Dadas estas definiciones, podemos decir que
          un polígono simple $P$ es $y$-monótono si no
          contiene vértices separación ni vértices
          unión.
        </p>
        <p>
          Entonces podemos decir que nuestro algoritmo
          para transformar un polígono simple en un
          polígono $y$-monótono, tenemos que eliminar
          todos los vértices separación y unión.
          Para ello es necesario poder agregar
          diagonales válidas(que no se intersecten
          entre ellas, y que estén completamente
          contenidas en $P$) a todos los vértices
          separación y unión.
          <br>

        </p>
        <h2 id="cap4_triangulando_polígono">Triangulando un
          polígono monótono</h2>
      </div>


      <!--  -->
      <!-- CAPITULO 5: PROGRAMACIÓN LINEAL -->
      <!--  -->
      <div class="page">

        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="programacion_lineal">Programación lineal</h1>
          <h1 class="chap_num">5</h1>
        </div>

        <h2 id="cap5_geometria_amoldado">La geometría de amoldado</h2>
        <h2 id="cap5_interseccion_semiplanos">Intersección de semiplanos</h2>
        <h2 id="cap5_circulo_contenedor">Círculo contenedor de radio mínimo</h2>
        <h2 id="cap5_programacion_lineal_incremental">Programación lineal incremental</h2>
        <h2 id="cap5_programacion_lineal_aleatoria">Programación lineal aleatoria</h2>
        <h2 id="cap5_programacion_lineal_dimensiones">Programación lineal en dimensiones superiores</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 6: BÚSQUEDA DE RANGOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="busqueda_rangos">Búsqueda de rangos ortogonales</h1>
          <h1 class="chap_num">6</h1>
        </div>

        <h2 id="cap6_busqueda_una_dimension">Búsqueda en una dimensión</h2>
        <h2 id="cap6_arboles_kd">Árboles Kd</h2>
        <h2 id="cap6_arboles_rangos">Árboles de rangos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 7: LOCALIZACIÓN DE PUNTOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="localizacion_puntos">Localización de puntos</h1>
          <h1 class="chap_num">7</h1>
        </div>

        <h2 id="cap7_localizacion_punto_subdivision">Localización de un punto en una subdivisión plana</h2>
        <h2 id="cap7_metodo_bandas">Método de bandas</h2>
        <h2 id="cap7_metodo_cadena">Método de cadena</h2>
        <h2 id="cap7_metodo_trapezoidal">Método trapezoidal</h2>
        <h2 id="cap7_algoritmo_incremental">Algoritmo incremental aleatorio</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 8: DIAGRAMAS DE VORONOI -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="diagramas_voronoi">Diagramas de Voronoi</h1>
          <h1 class="chap_num">8</h1>
        </div>

        <h2 id="cap8_definicion_propiedades">Definición y propiedades básicas</h2>
        <h2 id="cap8_construyendo_diagrama">Construyendo el diagrama de Voronoi</h2>
        <h2 id="cap8_cota_minima">Cota mínima</h2>
        <h2 id="cap8_diagramas_voronoi">Diagramas de Voronoi de orden superior</h2>
        <h2 id="cap8_aplicaciones">Aplicaciones</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 9: ARREGLOS DE LINEAS Y DUALIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="arreglos_lineas_dualidad">Arreglos de líneas y dualidad</h1>
          <h1 class="chap_num">9</h1>
        </div>

        <h2 id="cap9_arreglos">Arreglos de líneas</h2>
        <h2 id="cap9_dualidad">Dualidad</h2>
        <h2 id="cap9_triangulacion_delaunay">Triangulación de Delaunay</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 10: PROXIMIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="proximidad">Proximidad</h1>
          <h1 class="chap_num">10</h1>
        </div>

        <h2 id="cap10_puntos_cercanos_lejanos">Par de puntos más cercanos y más lejanos</h2>
        <h2 id="cap10_arboles_generadores_minimos">Árboles generadores mínimos euclidianos</h2>
        <h2 id="cap10_agente_viagero">El problema del agente viajero euclidiano</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 11: ESTRUCTURAS DE DATOS GEOMÉTRICAS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="estructuras_datos_geometricas">Algunas estructuras de datos geométricas</h1>
          <h1 class="chap_num">11</h1>
        </div>

        <h2 id="cap11_arboles_intervalos">Árboles de intervalos</h2>
        <h2 id="cap11_arboles_prioridades_busqueda">Árboles de prioridades y búsqueda</h2>
        <h2 id="cap11_arboles_segmentos">Árboles de segmentos</h2>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>


      <!--  -->
      <!-- <div class="page">
        <iframe src="https://youtu.be/EzeYI7p9MjU?t=2135"
          frameborder="0" allowtransparency="true" allow="encrypted-media" style="width:100%;height:400px"></iframe>
      </div> -->

      <!--  -->
      <div class="page">

      </div>

      <!--  -->
      <div class="page invertcolor" num=""
        style="background-image: radial-gradient(white, #ecf0f1, #e3e5e7); display:flex; align-items:center; justify-content:center;">
        <a style="width:50%" target="_blank" href="http://descartes.matem.unam.mx/"><img
            src="images/general/logo_descartes.svg" width="100%"></a>
      </div>
    </div>

    <!-- [cierra] pages_container -->
  </div>
  <!-- [cierra] book_container -->
  </div>

</body>

</html>