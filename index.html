<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=yes,minimal-ui">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <title>Notas para el curso Geometría Computacional</title>

  <!-- configuración del libro -->
  <script>
    window.book_config = {
      // parámetro que indica si los capítulos, secciones y figura se auto numeran
      // para que los capítulos se auto numeren deben utilizar la etiqueta <h1>
      // para que las secciones se auto numeren deben utilizar la etiqueta <h2>
      auto_numerate_sections_and_figures: true,
      remember_last_page: true,
    }
  </script>

  <!-- núcleo del libro interactivo -->
  <link rel="stylesheet" href="book/css/style.css" type="text/css">
  <script type="text/javascript" src="book/js/book.js" charset="utf-8"></script>

  <!-- personalización del usuario -->
  <link rel="stylesheet" href="extra/fonts.css" type="text/css">
  <link rel="stylesheet" href="extra/style.css" type="text/css">

  <!-- Bibliotecas para interactivos p5js -->
  <script src="libraries/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>

  <!-- inclusión de la biblioteca KaTex -->
  <link rel="stylesheet" type="text/css" href="extra/katex/katex.min.css" />
  <script src="extra/katex/katex.min.js"></script>
  <script src="extra/katex/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }, { left: "\\[", right: "\\]", display: true }, { left: "\\(", right: "\\)", display: false }]
      });
    });
  </script>
</head>

<body>
  <div id="book_loader_container">
    <div id="book_loader"></div>
  </div>

  <div id="book_container">
    <div id="btn_back_page"></div>
    <div id="btn_next_page"></div>
    <button id="go_to_table_of_content"></button>

    <button id="btn_config"></button>
    <div id="config_options">
      <div id="dark_light_mode"></div>
    </div>

    <!-- si este elemento no esta presente, el botón de la tabla de contenido lleva a la primera página con un elemento class="toc_link" -->
    <div id="table_of_content"></div>

    <div id="pages_container">
      <!--  -->
      <div class="page" style="background-color:transparent;"></div>

      <!-- Portada -->
      <div class="page invertcolor"
        style="margin:0; padding:0; background-size:contain; background-image:url(images/general/portada.svg);">
        <div class="cover_title">Notas para el curso</div>
        <div class="cover_subtitle">Geometría Computacional</div>
      </div>

      <!--  -->
      <div class="page" style="display:flex; align-items:center; justify-content:center;">VACÍA</div>

      <!--  -->
      <!-- init-page-num="true" es un parámetro que indica que a partir de esta página comienza la numeración -->
      <!-- inicialmente los números de las páginas se numeran con numerales romanos -->
      <!-- num="" es un parámetro que indica que esta página no lleva numeración visible -->
      <!--  -->
      <div class="page" init-page-num="true" style="text-align:right; font-size:120%;" num="">
        <br>
        <p><b style="font-size:150%;">Notas para el curso Geometría Computacional</b></p>

        <br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <p style="text-align:right; margin:0;">
          <br>
          <b>Edgar Samuel Perea Domínguez</b>
          <br><br>
          Universidad Nacional Autónoma de México
        </p>

      </div>

      <!--  -->
      <div class="page" num="">
        <p>
          Título de la obra:
          <br>
          Notas para el curso Geometría Computacional
        </p>
        <br>

        <p>
          Autores:
          <br>
          Edgar Samuel Perea Domínguez
        </p>
        <br><br>

        <p>
          Código JavaScript para el libro: <a href="https://github.com/jlongi/libro_interactivo" target="_blank">Joel
            Espinosa Longi</a>, <a href="https://www.matem.unam.mx/" target="_blank">IMATE</a>, UNAM.
          <br>
          Recursos interactivos: <a href="http://descartes.matem.unam.mx/" target="_blank">DescartesJS</a>
          <br>
          Fuentes: <a href="https://fonts.google.com/specimen/Lato" target="_blank">Lato</a> y <a
            href="https://fonts.google.com/specimen/Ubuntu+Mono" target="_blank">UbuntuMono</a>
        </p>
        <br>

        <p>
          DATOS DE LA EDICIÓN
        </p>
        <br><br>

        <p>
        <p>LICENCIA</p>
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank"><img
            src="images/general/by-nc-sa.svg" style="height:1.75em; margin-right:0.75em;"></a>
        <p>El contendido de esta obra esta bajo una licencia <a
            href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank">Creative Commons
            (Atribución-NoComercial-CompartirIgual)</a>.</p>
        </p>
      </div>

      <!-- Indice -->
      <div class="page">
        <h2>Tabla de contenido</h2>

        <!-- con esto se agrega una entrada en la tabla de contenido,
        href="#prefacio" indica una referencia a una elemento html con 
        el parámetro id="prefacio", automáticamente se busca está referencia
        y se agrega el título correspondiente y la página donde se encuentra -->

        <div class="toc_link" href="#prefacio"></div>

        <!-- Capitulo 1 -->
        <div class="toc_link" href="#introduccion"></div>
        <div class="toc_link" href="#cap1_definiciones_generales"></div>
        <div class="toc_link" href="#cap1_repaso_estructuras_datos"></div>
        <div class="toc_link" href="#cap1_preliminares_geometricos"></div>

        <!-- Capitulo 2 -->
        <div class="toc_link" href="#cierre_convexo"></div>
        <div class="toc_link" href="#cap2_cota_minima"></div>
        <div class="toc_link" href="#cap2_algorithmo_grahan"></div>
        <div class="toc_link" href="#cap2_algoritmo_jarvis"></div>
        <div class="toc_link" href="#cap2_algoritmos_divide_venceras"></div>
        <div class="toc_link" href="#cap2_algoritmos_dinamicos"></div>
        <div class="toc_link" href="#cap2_extensiones_variantes"></div>

        <!-- Capitulo 3 -->
        <div class="toc_link" href="#intersecciones_segmentos"></div>
        <div class="toc_link" href="#cap3_deteccion"></div>
        <div class="toc_link" href="#cap3_algoritmos"></div>
        <div class="toc_link" href="#cap3_lista_doblemente_ligada"></div>
        <div class="toc_link" href="#cap3_calculando_traslape"></div>
        <div class="toc_link" href="#cap3_barrido_topologico"></div>
        <div class="toc_link" href="#cap3_ordenando_pendientes"></div>

        <!-- Capitulo 4 -->
        <div class="toc_link" href="#triangulacion_divisibilidad"></div>
        <div class="toc_link" href="#cap4_vigilancia_triangulaciones"></div>
        <div class="toc_link" href="#cap4_dividiendo_polígono"></div>
        <div class="toc_link" href="#cap4_triangulando_polígono"></div>
        <div class="toc_link" href="#cap4_calcular_grafica_divisibilidad"></div>

      </div>

      <div class="page">
        <!-- Capitulo 5 -->
        <div class="toc_link" href="#programacion_lineal"></div>
        <div class="toc_link" href="#cap5_geometria_amoldado"></div>
        <div class="toc_link" href="#cap5_interseccion_semiplanos"></div>
        <div class="toc_link" href="#cap5_circulo_contenedor"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_incremental"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_aleatoria"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_dimensiones"></div>

        <!-- Capitulo 6 -->
        <div class="toc_link" href="#busqueda_rangos"></div>
        <div class="toc_link" href="#cap6_busqueda_una_dimension"></div>
        <div class="toc_link" href="#cap6_arboles_kd"></div>
        <div class="toc_link" href="#cap6_arboles_rangos"></div>

        <!-- Capitulo 7 -->
        <div class="toc_link" href="#localizacion_puntos"></div>
        <div class="toc_link" href="#cap7_localizacion_punto_subdivision"></div>
        <div class="toc_link" href="#cap7_metodo_bandas"></div>
        <div class="toc_link" href="#cap7_metodo_cadena"></div>
        <div class="toc_link" href="#cap7_metodo_trapezoidal"></div>
        <div class="toc_link" href="#cap7_algoritmo_incremental"></div>

        <!-- Capitulo 8 -->
        <div class="toc_link" href="#diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_definicion_propiedades"></div>
        <div class="toc_link" href="#cap8_construyendo_diagrama"></div>
        <div class="toc_link" href="#cap8_cota_minima"></div>
        <div class="toc_link" href="#cap8_diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_aplicaciones"></div>
      </div>

      <div class="page">
        <!-- Capitulo 9 -->
        <div class="toc_link" href="#arreglos_lineas_dualidad"></div>
        <div class="toc_link" href="#cap9_arreglos"></div>
        <div class="toc_link" href="#cap9_dualidad"></div>
        <div class="toc_link" href="#cap9_triangulacion_delaunay"></div>

        <!-- Capitulo 10 -->
        <div class="toc_link" href="#proximidad"></div>
        <div class="toc_link" href="#cap10_puntos_cercanos_lejanos"></div>
        <div class="toc_link" href="#cap10_arboles_generadores_minimos"></div>
        <div class="toc_link" href="#cap10_agente_viagero"></div>

        <!-- Capitulo 11 -->
        <div class="toc_link" href="#estructuras_datos_geometricas"></div>
        <div class="toc_link" href="#cap11_arboles_intervalos"></div>
        <div class="toc_link" href="#cap11_arboles_prioridades_busqueda"></div>
        <div class="toc_link" href="#cap11_arboles_segmentos"></div>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- num-type-arabic="true" es un parámetro que indica que a partir de esta página la numeración utilizara numerales arábigos -->
      <!--  -->
      <div class="page" num-type-arabic="true">
        <h1 id="prefacio">Prefacio</h1>

        <p>
          Este es un ejemplo sin contenido para
          comenzar la creación de un libro interactivo.
        </p>
      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="introduccion">Introducción</h1>
          <h1 class="chap_num">1</h1>
        </div>
        <p>
          El objetivo de esta sección será refrescar o
          introducir, los conceptos que se consideran
          básicos o necesarios, para que el lector
          pueda comprender con mayor facilidad los
          temas que se abordarán en el resto del libro,
          además de adoptar una notación para los
          mismos.
        </p>
        <p>
          Es por ello que, solamente formarán parte de
          esta sección las definiciones básicas, las
          definiciones que puedan ser más complejas
          serán presentadas en los capítulos
          correspondientes.
        </p>
        <p>
          Ya que es bastante común que en el estudio de
          la <b><i>Geometría computacional</i></b>, se
          aborden temas que hacen uso de conjuntos de
          puntos en un espacio euclidiano, es necesario
          saber representar a estos puntos.<br>
          Sin embargo, resulta claro que no es
          suficiente con solo saber representar puntos,
          pues, los objetos geométricos que se estudian
          o de los que se hace uso para estudiar la
          <b><i>Geometría computacional</b></i>, a
          pesar de no que necesitan consistir de un
          número finito de puntos, sí resulta necesario
          que tengan una especificación finita.
          <br>
          Es por eso que, además de considerar
          <b><i>puntos</b></i>
          individuales, se consideran elementos más
          complejos, tales como,
          <b><i>líneas rectas</b></i>, <b><i>segmentos
              de líneas rectas</b></i>,
          <b><i>planos</b></i>,
          <b><i>polígonos</b></i>, etcétera, cuyas
          definiciones y/o conceptos básicos serán
          presentados en la primer parte del capitulo
          actual.
        </p>
      </div>

      <div class="page">
        <p>
          Adicionalmente, para el uso de algoritmos
          geométricos es necesario manipular
          estructuras que no son manejadas a nivel de
          lenguaje de máquina. Por lo que es necesario
          implementar y/o utilizar diversas estructuras
          de datos, de las cuales las más comúnmente
          utilizadas son los conjuntos y los conjuntos
          ordenados, pero resulta claro comprender que
          estas no son las únicas utilizadas. Sin
          embargo en este capítulo solo se mencionarán
          las que se consideran necesarias, teniendo en
          cuenta que el lector ya cuenta con
          conocimientos de las estructuras de datos más
          básicas.
        </p>
      </div>
      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!-- Parte 1: Definiciones generales -->
      <!--  -->
      <div class="page">
        <h2 id="cap1_definiciones_generales">Definiciones generales.</h2>
        <p>
          Para comenzar, denotaremos como
          $\mathbb{R}^d$ al espacio euclídeo
          d-dimensional, esto es, el espacio de
          d-vectores $(x_1 , \dots , x_d)$ de números
          reales $\ x_i, \ i = 1, … , d\ $ con
          <a href="https://en.wikipedia.org/wiki/Metric_(mathematics)">
            métrica
          </a>
          $( \sum^{d}_{i=1} x^{2}_{i})^{1/2}$.
        </p>
        <p>
          Dada esta definición podemos continuar con
          las que resultan más indispensables para el
          estudio de la geometría computacional.
        </p>
        <!-- PUNTO -->
        <h4><b><i>Punto.</i></b></h4>
        <p>
          Un vector con $d$ componentes $(x_1 , \dots ,
          x_d)$ aplicado en el origen de $\mathbb{R}^d$
          denota un
          <b><i>punto</i></b> $p$ en $\mathbb{R}^d$.
        </p>
        <p>
          En la <ref ref_id="ejemplo_punto"></ref> se muestra un interactivo
          en el cual se representa un punto en el
          espacio en $\mathbb{R}^2$, al cual podemos
          cambiar sus valores en cada uno de sus
          componentes.
        </p>
        <figure id="ejemplo_punto">
          <div class="interactive" width="400" height="200"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_punto.html"></div>
          <figcaption>Ejemplo de punto en $\mathbb{R}^2$.</figcaption>
        </figure>
      </div>

      <div class="page">
        <!-- LINEA -->
        <h4><b><i>Línea.</i></b></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, el conjunto de todos los
          puntos $r$ que satisfacen

          \[ r = \alpha \ p_1
          + (1 -\alpha ) p_2 \qquad ( \alpha \in
          \mathbb{R} ) \]

          describe una
          <b><i>línea</i></b> en $\mathbb{R}^d$.
        </p>
        <p>
          A pesar de que un solo par de puntos
          distintos definen perfectamente una línea,
          una línea en $\mathbb{R}^d$ contiene un
          número infinito de puntos. Lo cual puede
          apreciarse en la siguiente figura(<ref ref_id="linea"></ref> ), en el cual las
          flechas azul y verde, representan la partes
          respectivas que aportan los puntos $p_2$ y
          $p_1$ al nuevo punto $r$ respectivamente.
          <br> De esta manera, al cambiar el valor de
          $\alpha$ podemos obtener cualquier punto
          sobre la línea roja.
        </p>

        <figure id="linea">
          <div class="interactive" width="500" height="300" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_linea.html"></div>
          <figcaption>
            Ejemplo de definición de
            línea.
          </figcaption>
        </figure>

      </div>
      <div class="page">
        <!-- Segmento de línea-->
        <h4><b><i>Segmento de línea.</i></b></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, si a la definición anterior
          agregamos la condición $ \ 0 \leq \alpha \leq
          1 \ $, esto es \[ r = \alpha \ p_1 + (1
          -\alpha ) p_2 \qquad ( 0 \leq \alpha \leq 1 )
          \] el conjunto de todos los puntos que
          satisfacen dicha definición, describe el
          <b><i>segmento de linea</i></b>
          recta que une los dos puntos $ \ q_1 \ $ y $
          \ q_2 \ $ en $\mathbb{R}^d$. Normalmente este
          <b><i>segmento de linea</i></b>
          se denota como $ \ \overline{ p_1 p_2}$.
        </p>
        <p>
          La siguiente figura(<ref ref_id="segmento_de_linea"></ref>) muestra un
          interactivo que funciona de la misma manera
          al presente en la figura anterior(<ref ref_id="linea"></ref>), el cual muestra la
          definición de línea, sin embargo se puede
          notar como en este recurso el valor de
          $\alpha$ cumple la condición $( 0 \leq \alpha
          \leq 1 )$, lo cual nos limita a solo poder
          representar puntos que están sobre la línea y
          a su vez entre los puntos $ p_1 p_2 $.
        </p>
        <figure id="segmento_de_linea">
          <div class="interactive" width="500" height="280" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_segmento.html"></div>
          <figcaption>
            Ejemplo de definición de segmento
            de línea.
          </figcaption>
        </figure>
      </div>
      <div class="page">
        <!-- Polígono-->
        <h4><b><i>Polígono.</i></b></h4>
        <p>
          En $\mathbb{R}^d$ un
          <b><i>polígono</i></b> $P$, es la región
          cerrada del plano, acotada por una colección
          finita de segmentos de línea, formando una
          <br>
          Ya que puede ser complejo explicar el
          significado de
          <b><i>curva cerrada simple</i></b>, podemos
          abordar la definición de la siguiente manera,
          para poderlo explicar de una forma más
          sencilla.
        </p>
        <p>
          Sean $v_0, v_1, v_2,\dots, v_{n-1}$ $n$
          puntos en el plano. Sean $ e_0 = $
          $ \overline{v_0 v_1}, \ e_1 = $
          $ \overline{v_1 v_2}, \ \ \dots \ ,e_i =$
          $ \overline{v_{i} v_{i+1}}, \ \dots$
          $, e_{n-1} = \overline{v_{n-1} v_{0}} $;
          $n - 1$ segmentos conectando los
          puntos, estos segmentos delimitan un
          <b><i>polígono</i></b>
          si y solo si:
        </p>
        <ol>
          <li>
            La intersección de cada par de segmentos
            adyacentes en el ciclo ordenado es el único
            punto que comparten entre ellos:
            <br>
            $ e_i \cap e_{i+1} = v_{i+1, \ }$ para todo
            $i = 0, \dots, n - 1$.
          </li>
          <li>
            Los segmentos no adyacentes no se
            intersectan:
            <br>
            $ e_i \cap e_{j} = \emptyset, \ $ para todo
            $j \neq i - 1$.
          </li>
        </ol>

        <figure id="poligono_condiciones">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_01/Ejemplo_condiciones_poligono.png">
          <figcaption>Ejemplo condiciones del
            polígono.</figcaption>
        </figure>

      </div>



      <div class="page">
        <p>
          En la <ref ref_id="poligono_condiciones"></ref> tenemos un ejemplo de un
          conjunto de segmentos de línea que no cumplen
          ambas condiciones.
          <br>
          Podemos observar como las aristas $e_1$ y
          $e_2$ (azul y roja, respectivamente) no
          cumplen la segunda condición, y a su vez las
          aristas $e_3$ y $e_4$ (negra y verde,
          respectivamente) no cumplen la primer
          condición.
        </p>
        <p>
          Dada esta definición, podemos explicar de una
          forma más simple, qué es una
          <b><i>curva cerrada simple</i></b> <br>
          La razón por la cual estos segmentos de línea
          se definen como una <b><i>curva</i></b> es
          porque están conectados por los extremos; la
          razón por la cual esta curva es
          <b><i>cerrada</i></b> es porque forma un
          ciclo; y la razón por la que la curva
          cerrada, es además <b><i>simple</i></b>, es
          porque los segmentos no adyacentes no se
          intersectan.
        </p>
        <p>
          Podemos definir a los objetos que cumplen
          solo la primer condición como
          <b><i>polígonos no simples</i></b>, si
          cumplen también la segunda (los segmentos no
          adyacentes no se intersectan) los llamaremos
          <b><i>polígonos simples</i></b>, otra forma
          más simple de definirlo es que un polígono es
          simple si no se cruza a sí mismo.
          <br>
          Ya que prácticamente solo se hará uso de los
          <b><i>polígonos no simples</i></b>, por
          simplicidad solo los llamaremos
          <b><i>polígonos</i></b>.
        </p>
        <p>
          En un polígono, los segmentos $e_i$ son
          llamados <b><i>aristas</i></b>
          (se usa la notación $e$ ya que la traducción
          de arista al inglés es edge, y es bastante
          común encontrar dicha notación en la
          literatura, utilizaremos dicha notación por
          esa razón), y los puntos $v_i$ (puntos donde
          se intersectan los segmentos de línea
          adyacentes) son llamados
          <b><i>vertices</i></b>.
        </p>
      </div>

      <div class="page">
        <p>
          Un polígono, con sus aristas y vertices,
          encierra una región del plano, nos
          referiremos a esta región como el
          <b><i>interior del polígono</i></b>. La
          región no delimitada que rodea al polígono
          forma el <b><i>exterior del polígono</i></b>.
        </p>
        <p>
          El conjunto de vertices y aristas de un
          polígono $P$ (el polígono sin su interior) es
          llamado perímetro, y es denotado como $
          \partial P$.
          <br>
          A lo largo del libro cuando nos refiramos a
          un polígono nos referiremos a la unión de su
          perímetro y su interior. Lo que significa que
          si mencionamos un punto en un polígono este
          se puede encontrar ya sea en el interior o en
          su perímetro.
          <br><br>
        </p>

        <p>
          Existen algoritmos que necesitan dividir a
          los polígonos en varias partes para
          procesarlos. Una forma natural de dividir a
          los polígonos en partes más simples se logra
          dibujando <b><i>diagonales</i></b>.
          <br>
          Una <b><i>diagonal</i></b> de un polígono
          $P$, es un segmento de línea que conecta dos
          vertices de $P$ y que yace en el interior de
          $P$, este segmento no toca a $ \partial P$
          excepto en su punto inicial y su punto final.
        </p>
        <p>
          Dos diagonales no se cruzan si no comparten
          puntos interiores, esto es, si comparten a lo
          más alguno de sus puntos de inicio o fin.
        </p>

      </div>

      <div class="page">
        <img src="/images/capitulo_01/Diagonales_from_Devad_discrete_and_computational_geo.jpg" width="90%">
        <br>
        Figure 1.2 shows (a) a polygon, (b) a diagonal, (c) a line segment
        that is not a diagonal, and (d) two crossing diagonals.
        <br><br>
        Definition. A triangulation of a polygon P is a decomposition of P into
        triangles by a maximal set of noncrossing diagonals.
        Here maximal means that no further diagonal may be added to the
        set without crossing (sharing an interior point with) one already in
        the set.
      </div>

      <!-- REPASO DE ESTRUCTURAS DE DATOS -->
      <div class="page">
        <h2 id="cap1_repaso_estructuras_datos">Repaso de estructuras de datos</h2>
        <p>
          Como ya se mencionó al inicio de este capítulo las
          estructuras de datos resultan una herramienta
          fundamental para el uso de los algoritmos geométricos.
          Muchas de estas estructuras de datos son muy bien
          descritas en el curso referente a estructuras de datos,
          y dado que no es la intención de este libro volver
          a describir dichas estructuras de datos,
          a continuación serán descritas únicamente las que
          resulten indispensables por no formar parte del
          temario oficial de dicho curso.
          <br><br>
        </p>

        <h2 id="cap1_preliminares_geometricos">Preliminares geométricos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 2: CIERRE CONVEXO -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="cierre_convexo">
            Cierre convexo de un conjunto de puntos
          </h1>
          <h1 class="chap_num">2</h1>
        </div>
        <p>
          Antes de comenzar este capitulo, necesitamos
          saber que es un <b><i>cierre convexo</i></b>,
          antes de definirlo formalmente, podemos
          tomarnos la libertad de definirlo de una
          forma más intuitiva.
        </p>
        <p>
          Esto es, dado un conjunto finito de puntos
          $S$ en el plano, si vemos a cada punto de $S$
          como un clavo colocado en una superficie plana,
          una madera por ejemplo, y tomamos una liga para estirarla
          al rededor de todos los clavos y la soltamos,
          podemos ver al <b><i>cierre convexo</i></b> de $S$
          como la región que queda encerrada por la
          liga al rededor de todos los clavos.
        </p>
        <p>
          La siguiente figura, <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>,
          contiene un recurso interactivo que nos
          muestra esta idea, donde los círculos
          representan los "clavos" (puntos en $S$) y
          las líneas verdes la "liga" que los encierra.
          <br>
          Puedes hacer click en cualquiera de los
          círculos blancos que representan a los puntos
          en $S$ para poder moverlo en la dirección que
          muevas el cursos, y a su vez puedes dar de
          nuevo click para dejarlo fijo en la nueva
          posición de cursor y ver como se modifica el
          cierre convexo.
        </p>
      </div>

      <div class="page">

        <figure id="cierre-convexo">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_2/intuitive_idea.html"></div>
          <figcaption>Ejemplo de la idea intuitiva de un cierre convexo.</figcaption>
        </figure>

        Ahora que tenemos esta definición que nos sirve
        para tener más clara la idea geométrica,
        podemos avanzar más fácilmente y comenzar con
        definiciones adicionales que sean más formales.
        </p>
        <p>
          A continuación definiremos una <b><i>combinación convexa</i></b>
          para después poder definir lo que es un <b><i>cierre convexo</i></b>
          a partir de la primera.
          <br>
        </p>

        <p>
          <!-- Conjunto convexo.-->
        <h4><b><i>Combinación convexa.</i></b></h4>
        Dado un número finito $k$ de puntos
        $p_0, p_1, p_2,\dots, p_{k}$ en $\mathbb{R}^d$,
        una combinación convexa de dicho conjunto de puntos es
        un punto de la forma:
        \[
        r = \alpha_1 p_1 + \alpha_2 p_2 + \dots + \alpha_k p_k
        \]
        donde $\alpha_i$ satisfacen las siguientes condiciones:
        \[
        ( \alpha_i \in \mathbb{R}, \ \ 0 \leq \alpha_i \leq 1,\ \ \alpha_1 + \dots + \alpha_k = 1 )
        \]
        <bibref ref_id="CG_in_C"></bibref>
        </p>



      </div>

      <div class="page">
        <p>
          Si prestamos atención, podemos notar que un
          <b><i>segmento de línea</i></b> consta de
          todas las combinaciones convexas que pueden
          ser generadas de sus puntos extremos que lo
          definen. Lo cual puede ser visto claramente
          en la <pageref ref_id="segmento_de_linea">
            <ref ref_id="segmento_de_linea"></ref>
          </pageref>.
        </p>
        <p>
          De manera similar podemos notar como un
          triangulo consiste de todas las combinaciones
          convexas de los 3 puntos (no colineales) que
          lo definen. Lo cual puede ser visto en la
          siguiente <ref ref_id="combinacion-convexa"></ref>, en la
          cual, al presionar el botón en la parte
          inferior, podemos generar una combinación
          convexa aleatoria a partir de los tres puntos
          que forman al triangulo. En la parte superior
          podemos apreciar como se define al punto r
          siguiendo la definición de combinación
          convexa, tomando cada uno de los puntos que
          definen al triangulo ($p_1 = (1,5)$, $p_2 =
          (8,1)$ y $p_3 = (8,8)$) multiplicándolos por
          una $\alpha_i$ aleatoria, de tal manera que
          la suma de las $\alpha_i$s suman 1.
        </p>
        <figure id="combinacion-convexa">
          <div class="interactive" width="500" height="295" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_conjunto_convexo.html"></div>
          <figcaption>Ejemplo de una combinación convexa generada por los puntos que definen un triangulo.</figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Una vez vistos los ejemplos anteriores
          podemos ver un ejemplo más, esta vez con 5
          puntos, $p_1 = (1,5)$, $p_2 = (8,1)$ y $p_3 =
          (8,8)$, $p_4 = (4,6)$ y $p_5 = (7,6)$. <br>
          En la
          <ref ref_id="combinacion-convexa-2"></ref>
          podemos dar valores entre cero y uno a cada
          $\alpha_i$ (cada $\alpha_i$ tiene al mismo
          color del punto al cual multiplica), y en el
          caso que cumplan la condición $ \alpha_1 +
          \dots + \alpha_5 = 1 $ el punto $r$ será una
          combinación convexa generada con los 5
          puntos, justo como en los ejemplos anteriores
          y en la definición.

        </p>
        <figure id="combinacion-convexa-2">
          <div class="interactive" width="600" height="365" window-size="false"
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_combinacion_convexa_2.html"></div>
          <figcaption>Ejemplo de combinación convexa generada por 5 puntos.</figcaption>
        </figure>
        <p>
          Después de apreciar este ejemplo, podemos
          notar como todas las posibles combinaciones
          convexas generadas del conjunto de puntos,
          resultan estar contenidas en un area convexa,
          la cual en las figuras, <pageref ref_id="combinacion-convexa">
            <ref ref_id="combinacion-convexa"></ref>
          </pageref>
          y
          <pageref ref_id="combinacion-convexa-2">
            <ref ref_id="combinacion-convexa-2"></ref>
          </pageref>
          se muestra de color morado.
        </p>
      </div>

      <div class="page">
        <p>
          Ahora pensemos a que nos recuerda si tomamos
          a cada punto del conjunto como un clavo
          clavado en el plano y los rodeamos con una
          liga, esto sin lugar a dudas nos resultará
          familiar, esta misma era la idea intuitiva
          del
          <b><i>cierre convexo</i></b>, lo que nos deja
          ver que area formada por todas las posibles
          combinaciones convexas generadas del conjunto
          de puntos, es justo el area encerrada por la
          liga, dicho de otra manera, es el cierre
          convexo del conjunto de puntos.
        </p>
        <p>
          Por lo que, aprovehcandonos de eto, podemos
          pasar a definir más formalmente a nuestro
          <b><i>cierre convexo</i></b> de la siguiente
          manera.
        </p>
        <!-- Cierre convexo.-->
        <p>
        <h4><b><i>Cierre convexo.</i></b></h4>
        Dado un conjunto finito $S$ de puntos en
        $\mathbb{R}^d$, el <b><i>cierre convexo</i></b>
        de $S$, denotado por $conv(S)$, es el conjunto
        de todas las combinaciones convexas de los
        puntos en $S$.
        <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Ahora que podemos comprender que es el cierre
          convexo, nos sería de gran utilidad saber ¿cómo
          representar al cierre convexo? y ¿qué significa
          calcular el cierre convexo?, pues resulta
          necesario para poder nuestro objetivo, que es
          indagar en los algoritmos para calcularlo.
        </p>
        <p>
          Comencemos primero por buscar una forma de
          representarlo.
        </p>
        <p>
          Recordando la idea intuitiva de la liga que
          rodea a los clavos, podemos notar que el area
          que encierra esta liga es un polígono convexo,
          lo cual podemos ver en la <pageref ref_id="cierre-convexo">
            <ref ref_id="cierre-convexo"></ref>
          </pageref>,
          moviendo los puntos a voluntad. <br>
          Esto nos lleva una definición alternativa, que
          es la siguiente.
        </p>
      </div>

      <div class="page">
        <p>
        <h4><b><i>Cierre convexo definición
              alternativa.</i></b></h4>
        El cierre convexo de un conjunto finito $S$ de
        puntos en el plano es el único polígono convexo
        cuyos vertices son puntos de $S$ y que
        contienen todos los puntos de $S$.
        </p>
        <p>
          Ya que el objetivo de este libro no es ser
          totalmente formales, se pasan por alto muchas
          de las pruebas, pero se invita al lector a
          buscar en la bibliografía en caso de requerir
          más formalidad.
          <bibref ref_id="CG_in_C">Pag. 64</bibref>
        </p>
        <p>
          Esta nueva definición nos resulta util pues podremos representar
          al cierre convexo como un polígono convexo, teniendo en cuenta
          que el area contenida por este polígono es el cierre convexo.
        </p>
        <p>
          Ahora que sabemos que podemos representar al
          cierre convexo de un conjunto de puntos $S$
          como un polígono, resulta esencial saber como
          representar a este polígono.
        </p>
        <p>
          Una forma natural de hacerlo es listando los
          vertices de dicho polígono en orden de las
          manecillas del reloj, comenzando desde algún
          punto arbitrario.
        </p>
        <p>
          Tomando esta forma de representar a
          un conjunto convexo, podemos describir el problema de
          encontrar el conjunto convexo de un conjunto de
          puntos, de la siguiente manera:
        </p>
        <h4><b><i>Descripción del problema.</i></b></h4>
        <p>
          Dado un conjunto de puntos $S =
          p_0, p_1, p_2,\dots, p_{n}$ en el plano,
          calcular una lista que contenga a todos los
          puntos de $S$ que son vertices del $conv(S)$
          listados en orden contrario a las manecillas del
          reloj.
        </p>
      </div>
      <div class="page">
        <p>
          Por ejemplo, dado el siguiente conjunto de puntos:
          <img src="./images/capitulo_01/Ejemplo_ch_problema.png">
        <figcaption>Conjunto de puntos de entrada y polígono formado por la salida.</figcaption>
        <br>
        La entrada y salida serían las siguientes:
        \[
        Entrada = conjunto \ de \ puntos \ completo: \\
        p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9
        \]
        \[
        Salida = conjunto \ de \ puntos \\
        que \ representan \ al \ cierre \ convexo: \\
        p_2, p_8, p_5, p_4, p_9
        \]
        </p>
      </div>

      <div class="page">
        <p>
          Es importante recordar que los puntos $p_2,
          p_9, p_4, p_5, p_8$ no son el cierre convexo de
          $S$, son solo la representación de cierre
          convexo pues el cierre convexo sería el
          polígono (interior y perímetro) formado con
          estos puntos, lo que en el ejemplo se
          representa con el area color morado.
        </p>
        <p>
          Ahora que sabemos qué es un cierre convexo, y
          además sabemos como describir el problema
          dada una cierta entrada para obtener una
          cierta salida, podemos empezar a indagar de
          que manera podremos solucionar estos
          problemas.
        </p>

        <p>
        <h4><b><i>Bibliografía</i></b></h4>
        Sería buena opción agregar todas las fuentes aquí al final?
        </p>
      </div>

      <!-- Algoritmo de Graham.-->
      <div class="page" id="graham_algorithm_page">
        <h2 id="cap2_algorithmo_grahan">Algoritmo de Graham</h2>

        <h4><b><i>Contexto</i></b></h4>
        <p>
          El algoritmo que se abordará en esta sección,
          surgió a finales de la década de 1960, en los
          laboratorios Bell, de la necesidad de su
          creador Ron Graham, por calcular el cierre
          convexo de una gran cantidad de puntos en el
          plano. Una complejidad de $O(n^2)$ en tiempo
          no le resultaba practica, lo que lo llevó a
          describir un algoritmo con una complejidad de
          $O(n log n)$ en tiempo, el cual pasó a ser el
          posiblemente primer articulo publicado en el
          campo de la geometría computacional en 1972,
          año en que fue publicado.
        </p>
        <p>
          En esta publicación Graham mostró que al
          realizar un ordenamiento de los puntos, al
          inicio del algoritmo, podía encontrar los
          puntos externos que describen al cierre
          convexo con una complejidad de $O(n)$ en
          tiempo.
        </p>
        <h4><b><i>Algoritmo</i></b></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por
          los puntos del polígono que forman al cierre
          convexo $conv(S)$.
        </p>
        <p>
          Dividamos al algoritmo en pasos, para una
          mejor comprensión del mismo.

        </p>
        <h5><b><i>Paso 1. Tomar el punto inferior.</i></b></h5>
        <p>
          Comencemos por encontrar al punto con la
          coordenada en $y$ más pequeña, de ser más de
          uno, tomaremos entre estos, al punto con la
          coordenada en $x$ más grande y lo agregamos
          al conjunto de salida $conv(S)$.
        </p>
      </div>
      <div class="page">
        <p>
          Dado que este punto es el punto inferior
          sabemos que pertenece al polígono que forma
          al cierre convexo, y lo tomaremos como punto
          inicial, para de aquí ir agregando a los
          puntos restantes.
        </p>
        <figure id="punto_inferior">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_02/punto_inferior.jpg" width="50%" height="50%">
          <figcaption>Seleccionamos el punto interior.</figcaption>
        </figure>
        <h5><b><i>Paso 2. Ordenar los puntos con respecto al inferior.</i></b></h5>
        <p>
          Posteriormente ordenaremos todos los demás
          puntos en $S$ por angulo, al sentido
          contrario a las manecillas del reloj con
          respecto a nuestro punto inferior que
          seleccionamos en el paso anterior.
        </p>

        <figure id="ordenar_puntos">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_02/puntos_ordenados.jpg" width="50%" height="50%">
          <figcaption>Ordenamos con respecto al punto interior.</figcaption>
        </figure>
      </div>
      <div class="page">
        <h5><b><i>Paso 3. Recorrer los puntos ordenados y agregar puntos al $conv(S)$.</i></b></h5>
        <p>
          A partir de aquí, recorreremos el conjunto de
          puntos ordenados, tomando tripletas de puntos
          consecutivos en orden contrario a las
          manecillas del reloj.
          <br>
          Esta tripleta la formaremos con los últimos
          dos puntos dentro del conv(S) que llamaremos
          $p_k$ y $p_{k-1}$ y el punto siguiente en el
          conjunto de puntos ordenados, que llamaremos
          $p_{k+1}$.
          <br>
          Tomando esta tripleta $p_{k-1}p_{k}p_{k+1}$
          verificaremos si el angulo interior que
          forman forma es concavo (que mide más de
          $\displaystyle \pi \,$ rad y menos de $
          {\displaystyle 2\pi \,}$ rad.) o no.
          <br>
          Si el
          angulo es concavo diremos que se da una
          vuelta derecha, si es convexo diremos que se
          da una vuelta izquierda.
          <bibref ref_id="CG_in_C">Pag. 42</bibref>
          <bibref ref_id="CG_an_Introduction">Pag. 106</bibref>
        </p>
        <p>
          La siguiente Figura muestra un ejemplo de
          la vuelta izquierda y la vuelta derecha.
        </p>
        <figure id="ordenar_puntos">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_02/Ejemplo_vueltas.png" width="80%" height="60%">
          <figcaption>Ejemplo de la definición de vuelta derecha e izquierda.</figcaption>
        </figure>
      </div>
      <div class="page">
        <p>
          Una vez sabiendo si la tripleta de puntos dan
          una vuelta derecha o izquierda, actuamos de
          la siguiente manera.
        </p>
        <p>
          Si la tripleta $p_{k-1}p_{k}p_{k+1}$ forma
          una vuelta izquierda, agregamos al punto
          $p_{k+1}$ a nuestro conjunto de salida
          $conv(S)$ y si aún hay puntos en el conjunto
          ordenado de puntos, repetimos el proceso con
          la tripleta $p_{k}p_{k+1}p_{k+2}$.
        </p>
        <p>
          Si la tripleta $p_{k-1}p_{k}p_{k+1}$ forma
          una vuelta derecha, eliminamos al ultimo
          punto de nuestro conjunto de salida
          $conv(S)$, esto es al punto $p_{k}$ y
          volvemos a revisar que tipo de vuelta se
          forma con los últimos puntos de nuestro
          conjunto, esto sería con
          $p_{k-2}p_{k-1}p_{k+1}$.


          Ya que no es posible formar una tripleta el
          primer punto del conjunto ordenado, a este
          simplemente lo agregaremos sin más.
        </p>
        CODIGO?
        <p>
          A continuación, en la <ref ref_id="graham_scan_algorithm"></ref> podemos ver un ejemplo de la
          ejecución del algoritmo de graham paso a paso
        </p>
      </div>
      <div class="page">

        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/graham_scan.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Graham.</figcaption>
        </figure>
        <!-- Fuentes: Discrete%20and%20computational%20geometry%20by%20Devadoss%20S.,%20ORourke%20J.%20(z-lib.org).pdf -->
        <!-- Computational_Geometry_An_Introduction_by_Franco_P_Preparata,_Michael. -->
        <!-- Computational%20Geometry%20in%20C%20by%20Joseph%20ORourke%20(z-lib.org).pdf -->
      </div>

      <div class="page" id="graham_algorithm__complexity_page">
        <h4><b><i>Complejidad</i></b></h4>
        <p>
          Procederemos a hacer un análisis simple la
          complejidad del algoritmo, con ayuda de su
          division en pasos, analizaremos la complejidad
          de cada uno para obtener la total del
          algoritmo.
        </p>
        <h5><b><i>Paso 1. Tomar el punto inferior.</i></b></h5>
        <p>
          Dado que lo único que nos interesa en este
          paso es obtener un punto en algún extremo del
          conjunto de puntos $S$, resulta indistinto
          cual escoger, en este caso se toma al punto
          interior.
          <br>
          Para poder obtener este punto inferior
          resulta claro que es necesario recorrer todos
          y cada uno de los puntos en $S$ y llevar registro
          del que tiene el menor valor en el eje y, lo cual
          podemos hacer en una complejidad en tiempo de $O(n)$
          donde $n$ es el número de puntos en $S$.
        </p>
        <h5><b><i>Paso 2. Ordenar los puntos con respecto al inferior.</i></b></h5>
        <p>
          Para esta parte del algoritmo necesitamos
          ordenar a todos los demás puntos en $S$ con
          respecto al angulo que forman con nuestro
          punto inferior, en sentido contrario a las
          manecillas del reloj.
          <br>
          Dado que podemos comparar cual es menor
          respecto al angulo que forma con nuestro
          punto inferior, en sentido contrario a las
          manecillas del reloj, haciendo uso del
          producto cruz, podemos asumir que la
          complejidad de ordenar $n-1$ puntos nos
          tomará $O(nlog(n))$.
        </p>
      </div>

      <div class="page">
        <h5><b><i>Paso 3. Recorrer los puntos ordenados y agregar puntos al $conv(S)$.</i></b></h5>
        <p>
          En este paso podemos observar que recorremos
          la lista de puntos ordenados uno por uno,
          verificando si forma una vuelta derecha o
          izquierda, dicha comprobación puede ser
          realizada haciendo uso del producto punto.
          Además podemos observar que cada punto en el
          conjunto ordenado, es añadido y removido del
          conjunto de salida $conv(s)$ a lo más una
          vez, entonces, dicho recorrido sobre los puntos
          ordenados se realiza en $O(n)$ iteraciones.
        </p>
        <p>
          Por lo tanto la complejidad es $O(nlog(n))$,
          pues la complejidad de ordenar a los puntos
          en el paso 2 domina las complejidades de los
          pasos 1 y 3.
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmo_jarvis">Algoritmo de Jarvis</h2>
        <h4><b><i>Contexto</i></b></h4>
        <p>
          En el algoritmo pasado comenzamos
          identificando a un punto extremo en el
          conjunto de puntos original, ahora bien,
          ¿podríamos hacer lo mismo para encontrar
          todos los puntos que representan al cierre
          convexo?.
          <br>
          Ciertamente, encontrar todos los puntos
          extremos no resulta tan fácil como encontrar
          el inferior, el superior, el más a la derecha
          y el más a la izquierda, sin embargo, una vez
          tomado un extremo, resulta más fácil
          encontrar otro punto extremo, si sabemos que
          la linea que trazan ambos puntos, está en un
          extremo también, es decir, si todos los demás
          puntos en $S$ están o sobre la misma linea o
          a un solo lado de la linea.<bibref ref_id="CG_an_Introduction">Pag. 110</bibref>
        </p>
        <p>
          La siguiente figura un muestra ejemplo de
          esto, tomando el punto los puntos ($p_8$) y
          ($p_5$) podemos trazar una linea que cumple
          la condición ya mencionada.
        </p>
        <figure id="linea_extrema">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_02/Ejemplo_linea_extrema.png" width="80%" height="80%">
          <figcaption>Seleccionamos el punto interior.</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Podríamos hacer uso de este conocimiento y
          buscar todos los pares de puntos que
          representan líneas que cumplen dicha
          condición, pues justo estas son las que
          forman al $conv(S)$, sin embargo el número de
          parejas de puntos sobre las que deberíamos
          iterar para comprobar si cumplen dicha
          condición, son <a href="https://en.wikipedia.org/wiki/Complete_graph">
            $n(n-1)/2$</a>, lo cual nos tomaría un tiempo
          de $O(n^2)$, además de que para cada línea
          formada por cada par de puntos deberíamos
          comprobar si todos los demás puntos cumplen
          la condición de yacer solo a un lado de la
          línea, lo que nos tomaría $O(n)$ para cada
          par de puntos, esto es $O(n^3)$ para el
          algoritmo completo.
        </p>
        <p>
          ¿Se podría hacer algo mejor que eso usando la
          misma idea? <br>
          Tal parece que sí, Jarvis en su articulo de
          1973, mostró como se puede reducir la
          complejidad a $O(n^2)$ si tomamos en cuenta
          que una vez tenemos un par de puntos $p_a$ y
          $p_b$ en $conv(S)$, sabemos que debe existir
          otro punto $p_c$ que junto con $p_b$ definan
          una linea que tenga a todos los demás puntos
          de un solo lado.
          <bibref ref_id="CG_an_Introduction">Pag.
            111</bibref>
        </p>
        <p>
          El algoritmo presentado en esta sección hará
          uso de esta idea para obtener todos los
          puntos que representan a $conv(S)$.
        </p>

      </div>

      <div class="page">
        <h4><b><i>Algoritmo</i></b></h4>
        <p>
          Dado lo que sabemos hasta ahora, podemos describir el algoritmo de Jarvis
          en solo dos pasos, los cuales son los siguientes:
        </p>

        <h5><b><i>Paso 1. Tomar el punto inferior.</i></b></h5>
        <p>
          Este paso es exactamente igual al primer paso del
          <pageref ref_id="graham_algorithm_page">algoritmo de
            graham antes descrito</pageref>.
        </p>
        <h5><b><i>Paso 2. Ir agregando puntos a $conv(S)$ tomando el ultimo punto en
              $conv(S)$ como referencia.</i></b></h5>

        <p>
          En esta parte del algoritmo tomamos al ultimo
          punto que fue agregado a $conv(S)$, al que
          nos referiremos como $p_k$, posteriormente,
          procedemos a comparar a todos los demás
          puntos en $S$ por al angulo que forman con
          respecto a dicho punto $p_k$ en sentido
          contrario a las manecillas del reloj, y
          tomamos al que tenga el menor angulo, este
          será el siguiente punto en ser agregado a
          $conv(S)$.
          <br>
          Repetiremos este procedimiento hasta que el
          siguiente punto a agregar sea uno que ya
          pertenece a $conv(S$.
        </p>
      </div>
      <div class="page">
        <figure id="graham_scan_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/jarvis_march.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo de Jarvis.</figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><b><i>Complejidad</i></b></h4>
        <p>
          Procederemos a hacer un análisis simple la
          complejidad del algoritmo, con ayuda de su
          division en pasos, analizaremos la complejidad
          de cada uno para obtener la total del
          algoritmo.
        </p>
        <h5><b><i>Paso 1. Tomar el punto inferior.</i></b></h5>
        <p>
          Esto sería exactamente al análisis del primer paso del
          <pageref ref_id="graham_algorithm__complexity_page">algoritmo de
            graham antes descrito</pageref>.
        </p>
        <h5><b><i>Paso 2. Ir agregando puntos a $conv(S)$ tomando el ultimo punto en
              $conv(S)$ como referencia.</i></b></h5>
        <p>
          Para esta parte del algoritmo necesitamos
          a un punto $p$ cuyo angulo (en sentido
          contrario a las manecillas del reloj) que forma con
          respecto al ultimo punto $p_k$ en $conv(S)$ sea el
          menor entre todos los puntos en $S$.
          <br>
          Haciendo uso del producto cruz, dados dos puntos
          podemos comparar cual de ellos es menor
          respecto al angulo (en sentido contrario a las
          manecillas del reloj) que forma con nuestro
          ultimo punto en $conv(S)$, $ \ p_k$.
          <br>
          Esto lo tenemos que hacer para cada punto en
          $S$ usando al ultimo punto en $conv(S)$ hasta
          que no es posible agregar más puntos a
          $conv(S)$. Lo que significa que para cada
          punto en $conv(S)$ iteraremos sobre todos los
          puntos en $S$, esto, en el peor de los casos
          tiene una complejidad de $O(n^2)$ pues en el
          peor de los casos $S = conv(S)$.

        </p>
      </div>

      <div class="page">
        <p>
          Esta cota superior es acertada, sin embargo,
          es posible hacerla un poco más justa, ya que
          sabemos que no siempre se cumple que $S =
          conv(S)$, por lo que, si tomamos a $n$ como
          el numero de puntos en $S$ y a $h$ el numero
          de puntos en $conv(S)$, podemos decir que
          el algoritmo tiene una complejidad de $O(nh)$
          pues la complejidad del paso 1 es $O(n)$ y
          $O(nh)$ domina.
        </p>
        <p>
          Esta característica nos deja ver como este
          algoritmo corre más rápido en casos donde en
          cierre convexo es pequeño, a este tipo de algoritmos
          se les suele llamar <a href="https://en.wikipedia.org/wiki/Output-sensitive_algorithm">
            algoritmos sensibles a la salida
          </a>
        </p>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_divide_venceras">Algoritmos usando divide y vencerás</h2>
        <h4><b><i>Contexto</i></b></h4>
        <p>
          En esta sección nos centraremos en un nuevo
          enfoque para, resolver el problema del cierre
          convexo, el cual hará uso de un paradigma
          ampliamente conocido y utilizado, el
          paradigma
          <a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide
            y vencerás</a>.
          <br>
          Los primeros en aplicar este paradigma para
          encontrar el cierre convexo fueron
          <a href="https://dl.acm.org/doi/abs/10.1145/359423.359430">Franco Preparata y June Hong en 1977</a>,
          utilizándolo no solo para el problema en 2
          dimensiones, si no que también para 3
          dimensiones, lo cual hace de este enfoque aun
          mas interesante.
        </p>
        <p>
          Este algoritmo, divide el problema inicial,
          de encontrar el cierre convexo de un conjunto
          de puntos $S$, en subproblemas que serán
          resueltos y posteriormente unidos, de una
          manera muy similar al algoritmo de
          ordenamiento <a href="https://en.wikipedia.org/wiki/Merge_sort"><i>merge
              sort</i> </a>.
          <br>
          La forma de dividir el problema en
          subproblemas es bastante simple, pues es
          posible ordenar los puntos por su componente
          en $x$ y dividir el problema en dos, calcular
          el cierre convexo de la primer mitad de
          dichos puntos ordenados y hacer lo mismo para
          la segunda mitad, posteriormente es necesario
          unir los cierres convexos resultantes de
          dichos subproblemas, sin embargo, realizar
          dicha union de los subproblemas, de una forma
          optima, no resulta trivial.
        </p>
        <p>
          En este momento, nos queda la pregunta, dados
          dos cierres convexos, ¿cómo podemos unirlos
          para formar el cierre convexo de ambos?
        </p>
        <p>
          Lo único que necesitamos es encontrar dos
          lineas tangentes a ambos cierres convexos,
          una superior y una inferior, un ejemplo de tales lineas
          puede ser apreciado en la <ref ref_id="lineas_tangentes"></ref>
        </p>
      </div>

      <div class="page">
        <figure id="lineas_tangentes">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_02/Ejemplo_lineas_tangentes.png" width="80%" height="80%">
          <figcaption>Ejemplo de líneas tangentes en dos cierres convexos.</figcaption>
        </figure>
        <p>
          La primer idea que nos puede venir a la
          mente, para encontrar dichas lineas
          tangentes, es tomar todos los posibles
          segmentos de lineas, que se pueden formar
          tomando un punto de cada cierre convexo, y
          tomar al par que forme una línea tal que
          todos los demás puntos estén bajo ella y al
          par que forme una línea tal que todos los
          demás puntos estén sobre ella.
          <br>
          Si embargo, realizar este procedimiento no
          sería muy eficiente, pues resultaría en
          comprobar para cada par de puntos (n(n-1)) si
          todos los demás puntos (n-2) yacen todos
          sobre el mismo lado de la línea, lo cual
          tendría una complejidad de $O(n^3)$.
        </p>
        <p>
          Una posible mejora que podríamos realizar a
          este algoritmo sería evitar tener que
          comparar cada línea con todos los demás
          puntos para saber si es una línea tangente.
          <br>
          ¿Cómo podemos comprobar que una línea es
          tangente a los cierres convexos sin comparar
          con todos los puntos?
        </p>
      </div>

      <div class="page">
        <p>
          Podemos trazar una línea vertical, entre
          ambos cierres convexos, y para cada línea
          trazada por los puntos entre los cierres
          convexos, tomaremos en cuenta el punto en el
          que intercepta a la línea que trazamos,
          entonces, tomaremos como nuestras líneas
          tangentes por arriba y por abajo, a las
          líneas con el mayor y menor valor de
          intersección, con la línea vertical que
          trazamos entre ambos puntos.
          <br>
          La <ref ref_id="ch_slow_merge_algorithm"></ref> muestra un ejemplo
          en el que se pude visualizar esto fácilmente.
        </p>
        <figure id="ch_slow_merge_algorithm">
          <div class="interactive" width="810" height="750" window-size="false"
            src="./Interactivos/capitulo_2/ch_slow_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos.</figcaption>
        </figure>
      </div>

      <div class="page">
        <p>
          Haciendo uso de este algoritmo la
          complejidad para encontrar las líneas
          tangentes superior e inferior pasa a $O(n^2)$, sin
          embargo, esto aún no es optimo.
        </p>
        <p>
          ¿Qué se puede hacer para mejorarlo?
        </p>
        <p>
          Podemos evitar tener que revisar sobre todas
          las parejas de puntos y solo revisar sobre
          las que resulte indispensable, esto es
          posible lograrlo usando a la idea que
          proponen Preparata y Hong en su articulo.
          <br>
          La idea es la siguiente y resulta
          prácticamente la misma para obtener la
          tangente superior, o la inferior, por lo que
          a continuación solo se describe como obtener
          la inferior.
        </p>
        <p>
          Dado que sabemos que la tangente $T$ que
          buscamos, tiene un punto en el cierre convexo
          del subproblema izquierdo, y un punto en el
          cierre convexo del subproblema derecho,
          tomaremos como $T$, a la línea formada por el
          punto mas a la derecha del cierre convexo
          izquierdo, y el punto más a la izquierda del
          cierre convexo derecho. Posteriormente,
          comenzaremos a hacer "descender" la tangente
          $T$ cambiando primero su punto en un cierre
          convexo y después sobre el otro, repitiendo
          hasta encontrar la tangente inferior.
        </p>
        <p>
          Dicho proceso de descenso, se realiza
          haciendo uso del hecho, de que la
          representación de cada cierre convexo es una
          lista de puntos, ordenada en sentido
          contrario a las manecillas del reloj.
          <br>
          Este descenso comienza sustituyendo el punto
          actual $pd_j$ en el conjunto convexo derecho,
          por el punto anterior a él $pd_{j-1}$ ( el
          siguiente en sentido de las manecillas del
          reloj), siempre y cuando la linea nueva $T$
          resultante esté mas abajo que la anterior
          (para saber eso usamos el valor de
          intersección con la línea vertical), y
          seguiremos sustituyendo este punto hasta que
          no podamos encontrar una $T$ más abajo.
        </p>

      </div>


      <div class="page">
        <p>
          Una vez hayamos "descendido" lo más posible
          sobre el punto del cierre convexo derecho,
          hacemos lo equivalente con el punto del lado
          izquierdo $pi_k$, pero en lugar de cambiar
          con el punto anterior $pi_{k-1}$, cambiamos
          el punto actual por el siguiente en el cierre
          convexo $pi_{k+1}$ (el siguiente en sentido
          contrario a las manecillas del reloj), y
          seguimos cambiando por el siguiente punto
          mientras la $T$ resultante se encuentre más
          abajo que a anterior.
          <br>
          Una vez que ya no sea posible "descender" más
          sobre el cierre convexo izquierdo, repetimos
          el proceso comenzando a descender lo más
          posible sobre el punto del cierre convexo
          derecho y luego sobre el izquierdo, hasta que
          no sea posible descender más en ninguno de los
          los.
        </p>
        <p>
          La <ref ref_id="ch_merge_algorithm"></ref> muestra como es este algoritmo
          de forma interactiva.
        </p>
        <p>
          De esta manera encontramos la tangente
          inferior, en tiempo $O(n)$ pues la forma en
          la que descendemos nunca da pasos atrás, por
          lo tanto no pasa más de una vez por cada
          punto. Y como ya mencionamos, el proceso para
          encontrar la tangente superior, resulta ser
          análogo. Una vez sabiendo cuales son estas
          tangentes, combinar ambos cierres convexos
          resulta trivial, pues solo es cuestión de
          recorrer los cierres convexos que ya
          conocíamos, desde una tangente a otra,
          proceso en el cual visitaríamos a lo más
          todos los puntos en ambos cierres convexos
          una sola vez, lo cual puede ser realizado en
          $O(n)$.
        </p>
        <p>
          Gracias a este algoritmo para unir dos
          conjuntos convexos, reducimos la complejidad que
          teníamos de $O(n^2)$ a $O(n)$.
        </p>
      </div>

      <div class="page">
        <figure id="ch_merge_algorithm">
          <div class="interactive" width="810" height="1050" window-size="false"
            src="./Interactivos/capitulo_2/ch_merge.html">
          </div>
          <figcaption>Ejemplo de la ejecución del algoritmo para unir dos cierres convexos de forma eficiente.
          </figcaption>
        </figure>
      </div>

      <div class="page">
        <h4><b><i>Algoritmo</i></b></h4>
        <p>
          Dado nuestro conjunto $S$ de puntos,
          obtengamos el cierre convexo $conv(S)$
          representado por los puntos del polígono que
          forman al cierre convexo $conv(S)$.
        </p>
        <p>
          Ahora que conocemos la forma de unir dos
          cierres convexos de forma eficiente, podemos
          describir el algoritmo completo, el cual
          podemos dividir en lo siguientes pasos.
        </p>

        <h5><b><i>Paso 1. Ordenar los puntos por sus coordenadas en x.</i></b></h5>
        <p>
          Para comenzar ordenaremos todos los puntos en
          $S$ por su coordenada en $x$ de forma
          ascendente.
          Lo cual podemos realizar con una complejidad de $O(nlog)$ en tiempo.
        </p>
        <h5><b><i>Paso 2. Dividir los puntos en dos
              conjuntos I y D con la primera mitad de puntos
              y la segunda mitad de puntos
              respectivamente.</i></b></h5>
        <h5><b><i>Paso 3. Calcular recursivamente los cierres convexos de I y D.</i></b></h5>
        <h5><b><i>Paso 4. Unir $conv(I)$ y $conv(D)$.</i></b></h5>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmos_dinamicos">Algoritmos dinámicos</h2>
      </div>

      <div class="page">
        <h2 id="cap2_extensiones_variantes">Extensiones y variantes</h2>
      </div>

      <div class="page">

        <h2 id="cap2_cota_minima">Cota mínima</h2>
        So far, we have described three algorithms for constructing the convex
        hull, each superior to the previous in terms of time complexity,
        both of which run in O(n log n) time. A natural
        question to consider is whether we can do better.
        It seems at least feasible that 0 (n) might be possible. We show in
        this section that this is in fact not possible: n log n is a "lower bound" on the complexity
        of any algorithm that finds the hull.
        The short answer is “no” (assuming a model of
        computation based on binary comparisons).
        We show in
        this section that this is in fact not possible: n log n is a "lower bound" on the complexity
        of any algorithm that finds the hull.

        Researchers in computer science have found it fiendishly difficult to establish no
        trivial lower bounds for problems. The difficulty is that the lower bound must hold
        for any conceivable algorithm, and it is hard to capture all algorithms in a proof.
        Nevertheless, this has been accomplished for a few key problems, notably sorting:
        Q(n log n) is a lower bound for sorting n elements.
        https://www.youtube.com/watch?v=eK6Ual_3ezA
        Once a lower bound for one problem has been established, lower bounds for other problems can be proved via
        "problem
        reduction."
        this is the typical approach to establishing a lower bound
        on all algorithms that solve a particular problem: reduce the problem
        to another whose lower bound had been previously established.

        Suppose problem A is known to have some particular lower bound. One can view
        this as knowing that problem A is "hard" to the degree exhibited by the lower bound.
        So if A has a lower bound of n(n4 ), it is a rather hard problem. Now suppose problem
        A can be reduced to problem B, in the sense that an algorithm for solving problem B
        can be used to solve problem A (with little additional work). A has been reduced to B
        in the sense that if we can solve B quickly, we can solve A quickly. This often leads
        to a lower bound on B, since if we could solve B too quickly, the known lower bound
        on A would be violated.

        This is how we will establish a lower bound on constructing the hull: we will show that it
        is possible to reduce the sorting problem to the convex hull problem in linear time. This implies that
        any O(f(n))-time algorithm for the convex hull problem implies an O(n + f(n))-time algorithm for
        sorting. Clearly, f(n) cannot be smaller than Ω(n log n) for otherwise we would obtain an immediate
        contradiction to the lower bound on sorting.

        The reduction works by projecting the points onto a convex curve. In particular, let X = {x1, . . . , xn}
        be the n values that we wish to sort. Suppose we “lift” each of these points onto a parabola y = x^2
        , by mapping x-i to the point p-i = (x_i, x^2_i).
        Let P denote the resulting set of points (see Fig. 18(a)). Note
        that all the points of P lie on its convex hull.

        Next, compute the convex hull of P by whatever algorithm we like in O(f(n)) time, which we assume
        to be given as a counter-clockwise cyclic enumeration of its vertices (see Fig. 18(b)). In O(n) time
        we can find the leftmost vertex of this cyclic order, and then read out the rest of the points in O(n)
        time (see Fig. 18(c)). Whenever we encounter some point pi
        in this order, we output its x-coordinate.
        Clearly, the points appear on the hull in left-to-right order, and therefore the final output is the sorted
        order of X, as desired. Except for the f(n) time to compute the convex hull, all the other steps can
        be performed in O(n) time. Thus, any super-linear lower bound on the sorting problem must apply to
        the function f(n) as well.

        This reduction leaves open two questions:
        • What if we don’t require that the points be enumerated in cyclic order, just that they all be
        identified? It remained an open problem for several years to determine if finding extreme
        points was easier, but the work of several researchers finally established that O (n logn)
        is a lower bound on this problem also. Solo nos quedaremos con esto,
        no se ahondará más en la demostración, pero recomendamos a los lectores más
        aventurados a saber más de esto a mirar See Preparata & Shamos (1985, pp. 101-3).

        • What if the all the points of P do not lie on the convex hull? The above reduction only suggests
        that the vertices of the hull need to sorted. This suggests that we might do better, if we know
        that the output size is significantly smaller than n. An algorithm whose running time is expressed
        as a function of both its input size and output size is called output sensitive. In this lecture we
        will discuss two output sensitive convex hull algorithms.


        ¿Es este el mejor lugar para poner esta parte del temario?

      </div>

      <div class="page">
        <h2 id="cap2_bib">Bibliografía</h2>

        <bibitem id="CG_in_C">
          O'Rourke, Joseph. <b>Computational Geometry In C.
          </b> Cambridge University Press, February 15, 2001.
        </bibitem>

        <bibitem id="Discrete_and_CG">
          Satyan L. Devadoss, Joseph O'Rourke. <b>
            Discrete and Computational geometry. </b>
          Princeton University Press, 2011
        </bibitem>

        <bibitem id="CG_an_Introduction">
          Franco P. Preparata, Michael Ian Shamos. <b>
            Computational Geometry An Introduction </b>
          Springer-Verlag New York Inc, 1985
        </bibitem>
      </div>

      <!--  -->
      <!-- CAPITULO 3: INTERSECCIÓN DE SEGMENTOS -->
      <!--  -->
      <div class="page">

        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="intersecciones_segmentos">Intersecciones entre segmentos de rectas</h1>
          <h1 class="chap_num">3</h1>
        </div>
        <h2 id="cap3_deteccion">Detección</h2>
        <h2 id="cap3_algoritmos">Algoritmos</h2>
        <h2 id="cap3_lista_doblemente_ligada">Lista doblemente conexa de aristas</h2>
        <h2 id="cap3_calculando_traslape">Calculando el traslape de dos subdivisiones</h2>
        <h2 id="cap3_barrido_topologico">Barrido topológico</h2>
        <h2 id="cap3_ordenando_pendientes">Ordenando pendientes en O(n^2)</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 4: TRIANGULACIÓN Y VISIBILIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="triangulacion_divisibilidad">
            Triangulación de polígonos y visibilidad
          </h1>
          <h1 class="chap_num">4</h1>
        </div>

        <h2 id="cap4_vigilancia_triangulaciones">Vigilancia y triangulaciones</h2>
        <h2 id="cap4_dividiendo_polígono">Dividiendo un polígono en piezas monótonas</h2>
        <h2 id="cap4_triangulando_polígono">Triangulando un polígono monótono</h2>
        <h2 id="cap4_calcular_grafica_divisibilidad">Calcular la gráfica de visibilidad</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 5: PROGRAMACIÓN LINEAL -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="programacion_lineal">Programación lineal</h1>
          <h1 class="chap_num">5</h1>
        </div>

        <h2 id="cap5_geometria_amoldado">La geometría de amoldado</h2>
        <h2 id="cap5_interseccion_semiplanos">Intersección de semiplanos</h2>
        <h2 id="cap5_circulo_contenedor">Círculo contenedor de radio mínimo</h2>
        <h2 id="cap5_programacion_lineal_incremental">Programación lineal incremental</h2>
        <h2 id="cap5_programacion_lineal_aleatoria">Programación lineal aleatoria</h2>
        <h2 id="cap5_programacion_lineal_dimensiones">Programación lineal en dimensiones superiores</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 6: BÚSQUEDA DE RANGOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="busqueda_rangos">Búsqueda de rangos ortogonales</h1>
          <h1 class="chap_num">6</h1>
        </div>

        <h2 id="cap6_busqueda_una_dimension">Búsqueda en una dimensión</h2>
        <h2 id="cap6_arboles_kd">Árboles Kd</h2>
        <h2 id="cap6_arboles_rangos">Árboles de rangos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 7: LOCALIZACIÓN DE PUNTOS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="localizacion_puntos">Localización de puntos</h1>
          <h1 class="chap_num">7</h1>
        </div>

        <h2 id="cap7_localizacion_punto_subdivision">Localización de un punto en una subdivisión plana</h2>
        <h2 id="cap7_metodo_bandas">Método de bandas</h2>
        <h2 id="cap7_metodo_cadena">Método de cadena</h2>
        <h2 id="cap7_metodo_trapezoidal">Método trapezoidal</h2>
        <h2 id="cap7_algoritmo_incremental">Algoritmo incremental aleatorio</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 8: DIAGRAMAS DE VORONOI -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="diagramas_voronoi">Diagramas de Voronoi</h1>
          <h1 class="chap_num">8</h1>
        </div>

        <h2 id="cap8_definicion_propiedades">Definición y propiedades básicas</h2>
        <h2 id="cap8_construyendo_diagrama">Construyendo el diagrama de Voronoi</h2>
        <h2 id="cap8_cota_minima">Cota mínima</h2>
        <h2 id="cap8_diagramas_voronoi">Diagramas de Voronoi de orden superior</h2>
        <h2 id="cap8_aplicaciones">Aplicaciones</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 9: ARREGLOS DE LINEAS Y DUALIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="arreglos_lineas_dualidad">Arreglos de líneas y dualidad</h1>
          <h1 class="chap_num">9</h1>
        </div>

        <h2 id="cap9_arreglos">Arreglos de líneas</h2>
        <h2 id="cap9_dualidad">Dualidad</h2>
        <h2 id="cap9_triangulacion_delaunay">Triangulación de Delaunay</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 10: PROXIMIDAD -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="proximidad">Proximidad</h1>
          <h1 class="chap_num">10</h1>
        </div>

        <h2 id="cap10_puntos_cercanos_lejanos">Par de puntos más cercanos y más lejanos</h2>
        <h2 id="cap10_arboles_generadores_minimos">Árboles generadores mínimos euclidianos</h2>
        <h2 id="cap10_agente_viagero">El problema del agente viajero euclidiano</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 11: ESTRUCTURAS DE DATOS GEOMÉTRICAS -->
      <!--  -->
      <div class="page">
        <div class="chap_space">
          <h1></h1>
          <h1 class="chap_name" id="estructuras_datos_geometricas">Algunas estructuras de datos geométricas</h1>
          <h1 class="chap_num">11</h1>
        </div>

        <h2 id="cap11_arboles_intervalos">Árboles de intervalos</h2>
        <h2 id="cap11_arboles_prioridades_busqueda">Árboles de prioridades y búsqueda</h2>
        <h2 id="cap11_arboles_segmentos">Árboles de segmentos</h2>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>


      <!--  -->
      <!-- <div class="page">
        <iframe src="https://youtu.be/EzeYI7p9MjU?t=2135"
          frameborder="0" allowtransparency="true" allow="encrypted-media" style="width:100%;height:400px"></iframe>
      </div> -->

      <!--  -->
      <div class="page">

      </div>

      <!--  -->
      <div class="page invertcolor" num=""
        style="background-image: radial-gradient(white, #ecf0f1, #e3e5e7); display:flex; align-items:center; justify-content:center;">
        <a style="width:50%" target="_blank" href="http://descartes.matem.unam.mx/"><img
            src="images/general/logo_descartes.svg" width="100%"></a>
      </div>
    </div>

    <!-- [cierra] pages_container -->
  </div>
  <!-- [cierra] book_container -->
  </div>

</body>

</html>