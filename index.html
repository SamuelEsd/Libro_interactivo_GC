<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=yes,minimal-ui">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <title>Notas para el curso Geometría Computacional</title>

  <!-- configuración del libro -->
  <script>
    window.book_config = {
      // parámetro que indica si los capítulos, secciones y figura se auto numeran
      // para que los capítulos se auto numeren deben utilizar la etiqueta <h1>
      // para que las secciones se auto numeren deben utilizar la etiqueta <h2>
      auto_numerate_sections_and_figures: true,
      remember_last_page: true,
    }
  </script>

  <!-- núcleo del libro interactivo -->
  <link rel="stylesheet" href="book/css/style.css" type="text/css">
  <script type="text/javascript" src="book/js/book.js" charset="utf-8"></script>

  <!-- personalización del usuario -->
  <link rel="stylesheet" href="extra/fonts.css" type="text/css">
  <link rel="stylesheet" href="extra/style.css" type="text/css">

  <!-- Bibliotecas para interactivos p5js -->
  <script src="libraries/p5.min.js"></script>
  <script src="libraries/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>

  <!-- inclusión de la biblioteca KaTex -->
  <link rel="stylesheet" type="text/css" href="extra/katex/katex.min.css" />
  <script src="extra/katex/katex.min.js"></script>
  <script src="extra/katex/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }, { left: "\\[", right: "\\]", display: true }, { left: "\\(", right: "\\)", display: false }]
      });
    });
  </script>
</head>

<body>
  <div id="book_loader_container">
    <div id="book_loader"></div>
  </div>

  <div id="book_container">
    <div id="btn_back_page"></div>
    <div id="btn_next_page"></div>
    <button id="go_to_table_of_content"></button>

    <button id="btn_config"></button>
    <div id="config_options">
      <div id="dark_light_mode"></div>
    </div>

    <!-- si este elemento no esta presente, el botón de la tabla de contenido lleva a la primera página con un elemento class="toc_link" -->
    <div id="table_of_content"></div>

    <div id="pages_container">
      <!--  -->
      <div class="page" style="background-color:transparent;"></div>

      <!-- Portada -->
      <div class="page invertcolor"
        style="margin:0; padding:0; background-size:contain; background-image:url(images/general/portada.svg);">
        <div class="cover_title">Notas para el curso</div>
        <div class="cover_subtitle">Geometría Computacional</div>
      </div>

      <!--  -->
      <div class="page" style="display:flex; align-items:center; justify-content:center;">VACIA</div>

      <!--  -->
      <!-- init-page-num="true" es un parámetro que indica que a partir de esta página comienza la numeración -->
      <!-- inicialmente los números de las páginas se numeran con numerales romanos -->
      <!-- num="" es un parámetro que indica que esta página no lleva numeración visible -->
      <!--  -->
      <div class="page" init-page-num="true" style="text-align:right; font-size:120%;" num="">
        <br>
        <p><b style="font-size:150%;">Notas para el curso Geometría Computacional</b></p>

        <br><br><br><br><br><br><br><br><br><br><br><br><br><br>
        <p style="text-align:right; margin:0;">
          <br>
          <b>Edgar Samuel Perea Domínguez</b>
          <br><br>
          Universidad Nacional Autónoma de México
        </p>

      </div>

      <!--  -->
      <div class="page" num="">
        <p>
          Título de la obra:
          <br>
          Notas para el curso Geometría Computacional
        </p>
        <br>

        <p>
          Autores:
          <br>
          Edgar Samuel Perea Domínguez
        </p>
        <br><br>

        <p>
          Código JavaScript para el libro: <a href="https://github.com/jlongi/libro_interactivo" target="_blank">Joel
            Espinosa Longi</a>, <a href="https://www.matem.unam.mx/" target="_blank">IMATE</a>, UNAM.
          <br>
          Recursos interactivos: <a href="http://descartes.matem.unam.mx/" target="_blank">DescartesJS</a>
          <br>
          Fuentes: <a href="https://fonts.google.com/specimen/Lato" target="_blank">Lato</a> y <a
            href="https://fonts.google.com/specimen/Ubuntu+Mono" target="_blank">UbuntuMono</a>
        </p>
        <br>

        <p>
          DATOS DE LA EDICIÓN
        </p>
        <br><br>

        <p>
        <p>LICENCIA</p>
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank"><img
            src="images/general/by-nc-sa.svg" style="height:1.75em; margin-right:0.75em;"></a>
        <p>El contendido de esta obra esta bajo una licencia <a
            href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank">Creative Commons
            (Atribución-NoComercial-CompartirIgual)</a>.</p>
        </p>
      </div>

      <!-- Indice -->
      <div class="page" >
        <h2>Tabla de contenido</h2>

        <!-- con esto se agrega una entrada en la tabla de contenido,
        href="#prefacio" indica una referencia a una elemento html con 
        el parámetro id="prefacio", automáticamente se busca está referencia
        y se agrega el título correspondiente y la página donde se encuentra -->

        <div class="toc_link" href="#prefacio"></div>

        <!-- Capitulo 1 -->
        <div class="toc_link" href="#introduccion"></div>
        <div class="toc_link" href="#cap1_definiciones_generales"></div>
        <div class="toc_link" href="#cap1_repaso_estructuras_datos"></div>
        <div class="toc_link" href="#cap1_preliminares_geometricos"></div>

        <!-- Capitulo 2 -->
        <div class="toc_link" href="#cierre_convexo"></div>
        <div class="toc_link" href="#cap2_cota_minima"></div>
        <div class="toc_link" href="#cap2_algorithmo_grahan"></div>
        <div class="toc_link" href="#cap2_algoritmo_jarvis"></div>
        <div class="toc_link" href="#cap2_algoritmos_divide_venceras"></div>
        <div class="toc_link" href="#cap2_algoritmos_dinamicos"></div>
        <div class="toc_link" href="#cap2_extensiones_variantes"></div>

        <!-- Capitulo 3 -->
        <div class="toc_link" href="#intersecciones_segmentos"></div>
        <div class="toc_link" href="#cap3_deteccion"></div>
        <div class="toc_link" href="#cap3_algoritmos"></div>
        <div class="toc_link" href="#cap3_lista_doblemente_ligada"></div>
        <div class="toc_link" href="#cap3_calculando_traslape"></div>
        <div class="toc_link" href="#cap3_barrido_topologico"></div>
        <div class="toc_link" href="#cap3_ordenando_pendientes"></div>

        <!-- Capitulo 4 -->
        <div class="toc_link" href="#triangulacion_divisibilidad"></div>
        <div class="toc_link" href="#cap4_vigilancia_triangulaciones"></div>
        <div class="toc_link" href="#cap4_dividiendo_polígono"></div>
        <div class="toc_link" href="#cap4_triangulando_polígono"></div>
        <div class="toc_link" href="#cap4_calcular_grafica_divisibilidad"></div>

      </div>

      <div class="page">
        <!-- Capitulo 5 -->
        <div class="toc_link" href="#programacion_lineal"></div>
        <div class="toc_link" href="#cap5_geometria_amoldado"></div>
        <div class="toc_link" href="#cap5_interseccion_semiplanos"></div>
        <div class="toc_link" href="#cap5_circulo_contenedor"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_incremental"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_aleatoria"></div>
        <div class="toc_link" href="#cap5_programacion_lineal_dimensiones"></div>

        <!-- Capitulo 6 -->
        <div class="toc_link" href="#busqueda_rangos"></div>
        <div class="toc_link" href="#cap6_busqueda_una_dimension"></div>
        <div class="toc_link" href="#cap6_arboles_kd"></div>
        <div class="toc_link" href="#cap6_arboles_rangos"></div>

        <!-- Capitulo 7 -->
        <div class="toc_link" href="#localizacion_puntos"></div>
        <div class="toc_link" href="#cap7_localizacion_punto_subdivision"></div>
        <div class="toc_link" href="#cap7_metodo_bandas"></div>
        <div class="toc_link" href="#cap7_metodo_cadena"></div>
        <div class="toc_link" href="#cap7_metodo_trapezoidal"></div>
        <div class="toc_link" href="#cap7_algoritmo_incremental"></div>

        <!-- Capitulo 8 -->
        <div class="toc_link" href="#diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_definicion_propiedades"></div>
        <div class="toc_link" href="#cap8_construyendo_diagrama"></div>
        <div class="toc_link" href="#cap8_cota_minima"></div>
        <div class="toc_link" href="#cap8_diagramas_voronoi"></div>
        <div class="toc_link" href="#cap8_aplicaciones"></div>
      </div>

      <div class="page">
        <!-- Capitulo 9 -->
        <div class="toc_link" href="#arreglos_lineas_dualidad"></div>
        <div class="toc_link" href="#cap9_arreglos"></div>
        <div class="toc_link" href="#cap9_dualidad"></div>
        <div class="toc_link" href="#cap9_triangulacion_delaunay"></div>

        <!-- Capitulo 10 -->
        <div class="toc_link" href="#proximidad"></div>
        <div class="toc_link" href="#cap10_puntos_cercanos_lejanos"></div>
        <div class="toc_link" href="#cap10_arboles_generadores_minimos"></div>
        <div class="toc_link" href="#cap10_agente_viagero"></div>

        <!-- Capitulo 11 -->
        <div class="toc_link" href="#estructuras_datos_geometricas"></div>
        <div class="toc_link" href="#cap11_arboles_intervalos"></div>
        <div class="toc_link" href="#cap11_arboles_prioridades_busqueda"></div>
        <div class="toc_link" href="#cap11_arboles_segmentos"></div>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- num-type-arabic="true" es un parámetro que indica que a partir de esta página la numeración utilizara numerales arábigos -->
      <!--  -->
      <div class="page" num-type-arabic="true">
        <h1 id="prefacio">Prefacio</h1>

        <p>
          Este es un ejemplo sin contenido para
          comenzar la creación de un libro interactivo.
      </p>
      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>

      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="introduccion">Introducción</h1>
        <p>
          El objetivo de esta sección será refrescar o
          introducir, los conceptos que se consideran
          básicos o necesarios, para que el lector
          pueda comprender con mayor facilidad los
          temas que se abordarán en el resto del libro,
          además de adoptar una notación para los
          mismos.
        </p>
        <p>
          Es por ello que, solamente formarán parte de
          esta sección las definiciones básicas, las
          definiciones que puedan ser más complejas
          serán presentadas en los capítulos
          correspondientes.
        </p>
        <p>
          Ya que es bastante común que en el estudio de
          la <b><i>Geometría computacional</i></b>, se
          aborden temas que hacen uso de conjuntos de
          puntos en un espacio euclidiano, es necesario
          saber representar a estos puntos.<br>
          Sin embargo, resulta claro que no es
          suficiente con solo saber representar puntos,
          pues, los objetos geométricos que se estudian
          o de los que se hace uso para estudiar la
          <b><i>Geometría computacional</b></i>, a
          pesar de no que necesitan consistir de un
          número finito de puntos, sí resulta necesario
          que tengan una especificación finita.
          <br>
          Es por eso que, además de considerar
          <b><i>puntos</b></i>
          individuales, se consideran elementos más
          complejos, tales como,
          <b><i>líneas rectas</b></i>, <b><i>segmentos
          de líneas rectas</b></i>,
          <b><i>planos</b></i>,
          <b><i>polígonos</b></i>, etcétera, cuyas
          definiciones y/o conceptos básicos serán
          presentados en la primer parte del capitulo
          actual.
        </p>
      </div>

      <div class="page">
        <p>
          Adicionalmente, para el uso de algoritmos
          geométricos es necesario manipular
          estructuras que no son manejadas a nivel de
          lenguaje de máquina. Por lo que es necesario
          implementar y/o utilizar diversas estructuras
          de datos, de las cuales las más comúnmente
          utilizadas son los conjuntos y los conjuntos
          ordenados, pero resulta claro comprender que
          estas no son las únicas utilizadas. Sin
          embargo en este capítulo solo se mencionarán
          las que se consideran necesarias, teniendo en
          cuenta que el lector ya cuenta con
          conocimientos de las estructuras de datos más
          básicas.
        </p>
      </div>
      <!--  -->
      <!-- CAPITULO 1: INTRODUCCIÓN -->
      <!-- Parte 1: Definiciones generales -->
      <!--  -->
      <div class="page">
        <h2 id="cap1_definiciones_generales">Definiciones generales.</h2>
        <p>
          Para comenzar, denotaremos como
          $\mathbb{R}^d$ al espacio euclídeo
          d-dimensional, esto es, el espacio de
          d-vectores $(x_1 , \dots , x_d)$ de números
          reales $\ x_i, \ i = 1, … , d\ $ con
          <a
          href="https://en.wikipedia.org/wiki/Metric_(mathematics)">
          métrica
          </a>
          $( \sum^{d}_{i=1} x^{2}_{i})^{1/2}$.
        </p>
        <p>
          Dada esta definición podemos continuar con
          las que resultan más indispensables para el
          estudio de la geometría computacional.
        </p>
        <!-- PUNTO -->
        <h4><b><i>Punto.</i></b></h4>
        <p>
          Un vector con $d$ componentes $(x_1 , \dots ,
          x_d)$ aplicado en el origen de $\mathbb{R}^d$
          denota un
          <b><i>punto</i></b> $p$ en $\mathbb{R}^d$.
        </p>
        <p>
          En la <ref ref_id="ejemplo_punto"></ref> se muestra un interactivo
          en el cual se representa un punto en el
          espacio en $\mathbb{R}^2$, al cual podemos
          cambiar sus valores en cada uno de sus
          componentes.
        </p>
        <figure id="ejemplo_punto">
          <div class="interactive" width="400"
            height="200" 
            src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_punto.html"></div>
          <figcaption>Ejemplo de punto en $\mathbb{R}^2$.</figcaption>
        </figure>
      </div>

      <div class="page">
        <!-- LINEA -->
        <h4><b><i>Línea.</i></b></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, el conjunto de todos los
          puntos $r$ que satisfacen 

          \[ r = \alpha \ p_1
          + (1 -\alpha ) p_2 \qquad ( \alpha \in
          \mathbb{R} ) \] 

          describe una
          <b><i>línea</i></b> en $\mathbb{R}^d$.
        </p>
        <p>
          A pesar de que un solo par de puntos
          distintos definen perfectamente una línea,
          una línea en $\mathbb{R}^d$ contiene un
          número infinito de puntos. <br> Lo cual puede
          apreciarse en el siguiente interactivo, en el
          cual las flechas azul y verde, representan la
          partes respectivas que aportan los puntos
          $p_2$ y $p_1$ al nuevo punto $r$
          respectivamente. <br> De esta manera, al
          cambiar el valor de $\alpha$ podemos obtener
          cualquier punto sobre la línea roja,
          apreciando como va cambiando la "cantidad" de
          cada punto $p_1$ $p_2$ que es "necesaria"
          para formar el nuevo punto $r$.
        </p>

        <div class="interactive" width="500"
        height="270" window-size="false"
        src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_linea.html"></div>
      </div>
      <div class="page">
        <!-- Segmento de línea-->
        <h4><b><i>Segmento de línea.</i></b></h4>
        <p>
          Dados dos puntos distintos $p_1$ y $p_2$ en
          $\mathbb{R}^d$, si a la definición anterior
          agregamos la condición $ \ 0 \leq \alpha \leq
          1 \ $, esto es \[ r = \alpha \ p_1 + (1
          -\alpha ) p_2 \qquad ( 0 \leq \alpha \leq 1 )
          \] el conjunto de todos los puntos que
          satisfacen dicha definición, describe el
          <b><i>segmento de linea</i></b>
          recta que une los dos puntos $ \ q_1 \ $ y $
          \ q_2 \ $ en $\mathbb{R}^d$. Normalmente este
          <b><i>segmento de linea</i></b>
          se denota como $ \ \overline{ p_1 p_2}$.
        </p>
        <p>
          El siguiente interactivo funciona de la misma
          manera que el interactivo anterior, el cual
          muestra la definición de línea, sin embargo
          se puede notar como en este recurso el valor
          de $\alpha$ cumple la condición $( 0 \leq
          \alpha \leq 1 )$, lo cual nos limita a solo
          poder representar puntos que están sobre la
          línea y a su vez entre los puntos $ p_1 p_2
          $.
        </p>
        <div class="interactive" width="500"
        height="280" window-size="false"
        src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_segmento.html"></div>
      </div>
      <div class="page">
        <!-- Polígono-->
        <h4><b><i>Polígono.</i></b></h4>
        <p>
          En $\mathbb{R}^d$ un
          <b><i>polígono</i></b> $P$, es la región
          cerrada del plano, acotada por una colección
          finita de segmentos de línea, formando una
          <br>
          Ya que puede ser complejo explicar el
          significado de
          <b><i>curva cerrada simple</i></b>, podemos
          abordar la definición de la siguiente manera,
          para poderlo explicar de una forma más
          sencilla.
        </p>
        <p>
          Sean $v_0, v_1, v_2,\dots, v_{n-1}$ $n$
          puntos en el plano. Sean $ e_0 = $ 
          $ \overline{v_0 v_1}, \  e_1 = $
          $ \overline{v_1 v_2}, \ \ \dots \ ,e_i =$
          $ \overline{v_{i} v_{i+1}}, \ \dots$
          $, e_{n-1} = \overline{v_{n-1} v_{0}} $;
          $n - 1$ segmentos conectando los
          puntos, estos segmentos delimitan un
          <b><i>polígono</i></b>
          si y solo si:
        </p>
        <ol>
          <li>
            La intersección de cada par de segmentos
            adyacentes en el ciclo ordenado es el único
            punto que comparten entre ellos:
            <br>
            $ e_i \cap e_{i+1} = v_{i+1, \ }$ para todo
            $i = 0, \dots, n - 1$.
          </li>
          <li>
            Los segmentos no adyacentes no se
            intersectan:
            <br>
            $ e_i \cap e_{j} = \emptyset, \ $ para todo
            $j \neq i - 1$.
          </li>
        </ol>
        
        <figure id="poligono_condiciones">
          <!-- <div class="interactive" width="600"
          height="310" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_condiciones_poligono.html"></div> -->
          <img src="./images/capitulo_01/Ejemplo_condiciones_poligono.png">
          <figcaption>Ejemplo condiciones del
          polígono.</figcaption>
        </figure>
        
      </div>



      <div class="page">
        <p>
          En la <ref ref_id="poligono_condiciones"></ref> tenemos un ejemplo de un
          conjunto de segmentos de línea que no cumplen
          ambas condiciones.
          <br>
          Podemos observar como las aristas $e_1$ y
          $e_2$ (azul y roja, respectivamente) no
          cumplen la segunda condición, y a su vez las
          aristas $e_3$ y $e_4$ (negra y verde,
          respectivamente) no cumplen la primer
          condición.
        </p>
        <p>
          Dada esta definición, podemos explicar de una
          forma más simple, qué es una
          <b><i>curva cerrada simple</i></b> <br>
          La razón por la cual estos segmentos de línea
          se definen como una <b><i>curva</i></b> es
          porque están conectados por los extremos; la
          razón por la cual esta curva es
          <b><i>cerrada</i></b> es porque forma un
          ciclo; y la razón por la que la curva
          cerrada, es además <b><i>simple</i></b>, es
          porque los segmentos no adyacentes no se
          intersectan.
        </p>
        <p>
          Podemos definir a los objetos que cumplen
          solo la primer condición como
          <b><i>polígonos no simples</i></b>, si
          cumplen también la segunda (los segmentos no
          adyacentes no se intersectan) los llamaremos
          <b><i>polígonos simples</i></b>, otra forma
          más simple de definirlo es que un polígono es
          simple si no se cruza a sí mismo.
          <br>
          Ya que prácticamente solo se hará uso de los
          <b><i>polígonos no simples</i></b>, por
          simplicidad solo los llamaremos
          <b><i>polígonos</i></b>.
        </p>
        <p>
          En un polígono, los segmentos $e_i$ son
          llamados <b><i>aristas</i></b>
          (se usa la notación $e$ ya que la traducción
          de arista al inglés es edge, y es bastante
          común encontrar dicha notación en la
          literatura, utilizaremos dicha notación por
          esa razón), y los puntos $v_i$ (puntos donde
          se intersectan los segmentos de línea
          adyacentes) son llamados
          <b><i>vertices</i></b>.
        </p>
      </div>

      <div class="page">
        <p>
          Un polígono, con sus aristas y vertices,
          encierra una región del plano, nos
          referiremos a esta región como el
          <b><i>interior del polígono</i></b>. La
          región no delimitada que rodea al polígono
          forma el <b><i>exterior del polígono</i></b>.
        </p>
        <p>
          El conjunto de vertices y aristas de un
          polígono $P$ (el polígono sin su interior) es
          llamado perímetro, y es denotado como $
          \partial P$.
          <br>
          A lo largo del libro cuando nos refiramos a
          un polígono nos referiremos a la unión de su
          perímetro y su interior. Lo que significa que
          si mencionamos un punto en un polígono este
          se puede encontrar ya sea en el interior o en
          su perímetro.
          <br><br>
        </p>

        <p>
          Existen algoritmos que necesitan dividir a
          los polígonos en varias partes para
          procesarlos. Una forma natural de dividir a
          los polígonos en partes más simples se logra
          dibujando <b><i>diagonales</i></b>.
          <br>
          Una <b><i>diagonal</i></b> de un polígono
          $P$, es un segmento de línea que conecta dos
          vertices de $P$ y que yace en el interior de
          $P$, este segmento no toca a $ \partial P$
          excepto en su punto inicial y su punto final.
        </p>
        <p>
          Dos diagonales no se cruzan si no comparten
          puntos interiores, esto es, si comparten a lo
          más alguno de sus puntos de inicio o fin.
        </p>

      </div>

      <div class="page">
        <img src="/images/capitulo_01/Diagonales_from_Devad_discrete_and_computational_geo.jpg" width="90%">
        <br>
        Figure 1.2 shows (a) a polygon, (b) a diagonal, (c) a line segment
        that is not a diagonal, and (d) two crossing diagonals.
        <br><br>
        Definition. A triangulation of a polygon P is a decomposition of P into
        triangles by a maximal set of noncrossing diagonals.
        Here maximal means that no further diagonal may be added to the
        set without crossing (sharing an interior point with) one already in
        the set.
      </div>

      <!-- REPASO DE ESTRUCTURAS DE DATOS -->
      <div class="page">
        <h2 id="cap1_repaso_estructuras_datos">Repaso de estructuras de datos</h2>
        <p>
          Como ya se mencionó al inicio de este capítulo las
          estructuras de datos resultan una herramienta
          fundamental para el uso de los algoritmos geométricos.
          Muchas de estas estructuras de datos son muy bien
          descritas en el curso referente a estructuras de datos,
          y dado que no es la intención de este libro volver
          a describir dichas estructuras de datos,
          a continuación serán descritas únicamente las que
          resulten indispensables por no formar parte del
          temario oficial de dicho curso.
          <br><br>
        </p>

        <h2 id="cap1_preliminares_geometricos">Preliminares geométricos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 2: CIERRE CONVEXO -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="cierre_convexo">
          Cierre convexo de un conjunto de puntos
        </h1>
        <p>
          Antes de comenzar este capitulo, necesitamos
          saber que es un <b><i>cierre convexo</i></b>,
          antes de definirlo formalmente, podemos
          tomarnos la libertad de definirlo de una
          forma más intuitiva.
        </p>
        <p>
          Esto es, dado un conjunto finito de puntos
          $S$ en el plano, si vemos a cada punto de $S$
          como un clavo colocado en una superficie plana, 
          una madera por ejemplo, y tomamos una liga para estirarla
          al rededor de todos los clavos y la soltamos,
          podemos ver al <b><i>cierre convexo</i></b> de $S$
          como la región que queda encerrada por la
          liga al rededor de todos los clavos.
        </p>
        <p>
          La siguiente figura, <ref
          ref_id="cierre-convexo"></ref>, contiene un
          recurso interactivo que nos muestra esta
          idea, donde los círculos representan los
          "clavos" (puntos en $S$) y las líneas verdes
          la "liga" que los encierra.
          <br>
          Puedes hacer click en cualquiera de los
          círculos blancos que representan a los puntos
          en $S$ para poder moverlo en la dirección que
          muevas el cursos, y a su vez puedes dar de
          nuevo click para dejarlo fijo en la nueva
          posición de cursor y ver como se modifica el
          cierre convexo.
        </p>
      </div>

      <div class="page">
        
        <figure id="cierre-convexo">
          <div class="interactive" width="810" height="500" window-size="false"
            src="./Interactivos/capitulo_1/cierre_convexo.html"></div>
          <figcaption>Ejemplo de la idea intuitiva de un cierre convexo.</figcaption>
        </figure>
          
          Ahora que tenemos esta definición que nos sirve
          para tener más clara la idea geométrica,
          podemos avanzar más fácilmente y comenzar con
          definiciones adicionales que sean más formales.
        </p>
        <p>
          A continuación definiremos una <b><i>conjunto convexo</i></b>
          para después poder definir lo que es un <b><i>cierre convexo</i></b>.
          <br>
        </p>

        <p>
          <!-- Cierre convexo.-->
          <h4><b><i>Conjunto convexo.</i></b></h4>
          Dados $k$ puntos
          $p_0, p_1, p_2,\dots, p_{k}$ en $\mathbb{R}^d$,
          el conjunto de puntos:
          \[
          r = \alpha_1 p_1 + \alpha_2 p_2 + \dots + \alpha_k p_k 
          \]
          \[
          ( \alpha_i \in \mathbb{R}, 0 \leq \alpha_i \leq 1, \alpha_1 + \dots + \alpha_k = 1 )
          \]
          es el $conjunto \ convexo$ generado por $p_0, p_1, p_2,\dots, p_{k}$,
          y $p$ es una combinación convexa de $p_0, p_1, p_2,\dots, p_{k}$.
        </p>
      </div>

      <div class="page">
        <p>
          Si prestamos atención, podemos ver como la definición de 
          <b><i>segmento de línea</i></b> cumple con la definición de 
          <b><i>conjunto convexo</i>, por lo que podemos ver como
          un segmento de línea no es más que un caso particular del 
          conjunto convexo donde solo tenemos 2 puntos, o todos 
          nuestros puntos son colineales.
        </p>
        <div class="interactive" width="600" height="580" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_conjunto_convexo.html"></div>
      </div>

      <div class="page">
        <!-- Cierre convexo.-->
      <p>
        <h4><b><i>Cierre convexo.</i></b></h4>
        Dado un subconjunto arbitrario $S$ de puntos en
        $\mathbb{R}^d$, el <b><i>cierre convexo</i></b>
        de $S$, denotado por $conv(S)$, es la
        intersección de todos los <b><i>conjuntos
        convexos</i></b>
        que contienen a $S$.
      </p>
      <p>
        Ahora que podemos comprender que es el cierre
        convexo, podríamos preguntarnos, ¿cómo podemos
        representar al cierre convexo de un conjunto de
        puntos $S$? y ¿qué significa calcular el cierre
        convexo un conjunto de puntos $S$?
      </p>
      <p>
        Recordando la idea intuitiva de la liga que
        rodea a los clavos, el area que encierra esta
        liga es el cierre convexo de $S$.<br>
        Esto nos lleva a una definición alternativa del
        cierre convexo de un conjunto finito $S$ de
        puntos en el plano: el cierre convexo es el
        único polígono convexo cuyos vertices son
        puntos de $S$ y que contienen todos los puntos
        de $S$.
      </p>
      <p>
        Ya que el objetivo de este libro no es ser
        totalmente formales, se pasan por alto muchas
        de las pruebas, incluida la última afirmación
        con respecto a la definición del cierre convexo
        como un polígono, pero se invita al lector a
        buscar en la bibliografía en caso de requerir
        más formalidad.
      </p>
      <p>
        Ahora que sabemos que podemos representar al
        cierre convexo de un conjunto de puntos $S$
        como un polígono, resulta esencial saber como
        representar a este polígono.
        <br>
        Una forma natural de hacerlo es listando los
        vertices de dicho polígono en orden de las
        manecillas del reloj, comenzando desde algún
        punto arbitrario.
      </p>
      </div>

      <div class="page">
      <p>
        Por lo tanto podemos describir el problema de
        encontrar el conjunto convexo de un conjunto de
        puntos como: dado un conjunto de puntos $S =
        p_0, p_1, p_2,\dots, p_{n}$ en el plano,
        calcular una lista qe contenga a todos los
        puntos de $S$ que son vertices del $conv(S)$
        listados en e orden de las manecillas del
        reloj.
      </p>
      <p>
        Por ejemplo:
        \[
        Entrada = conjunto \ de \ puntos: \\
        p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8
        \]
        \[
        Salida = representación \ del \ cierre \ convexo: \\
        p_2, p_9, p_4, p_5, p_8
        \]
        <div class="interactive" width="380" height="200" window-size="false"
          src="./Interactivos/capitulo_1/utils/descartesJS/Ejemplo_ch_problema.html"></div>
        <br>
        Es importante recordar que los puntos $p_2,
        p_9, p_4, p_5, p_8$ no son el cierre convexo de
        $S$, son solo la representación de cierre
        convexo pues el cierre convexo sería el
        polígono (interior y perímetro) formado con
        estos puntos, lo que en el ejemplo se
        representa con el area color morado.
      </div>

      <div class="page">
        <p>
          Ahora que sabemos qué es un cierre convexo, y
          además sabemos como describir el problema
          dada una cierta entrada para obtener una
          cierta salida, podemos empezar a indagar de
          que manera podremos solucionar estos
          problemas.
        </p>
      </div>
      
        <!-- Algoritmo de Graham.-->
      <div class="page">
        <h2 id="cap2_algorithmo_grahan">Algoritmo de Graham</h2>
        
        <h4><b><i>Contexto</i></b></h4>
        <p>
          El algoritmo que se abordará en esta sección,
          surgió a finales de la década de 1960, en los 
          laboratorios Bell, de la necesidad de su creador 
          Ron Graham, por calcular el cierre convexo de una gran cantidad
          de puntos en el plano. Una complejidad de $O(n^2)$ en tiempo no 
          le resultaba practica, lo que lo llevó a describir un 
          algoritmo con una complejidad de $O(n log n)$ en tiempo,
          el cual pasó a ser el posiblemente primer articulo
          publicado en el campo de la geometría Computacional
          en 1972, año en que fue publicado.
          <br>
          En esta publicación Graham mostró que al realizar
          un ordenamiento de los puntos, al inicio del algoritmo,
          podía encontrar los puntos externos que describen al
          cierre convexo con una complejidad de $O(n)$ en tiempo.
        </p>
        <h4><b><i>Algoritmo</i></b></h4>
        <p>

        </p>

        For a point set S in general position, just as in the gift-wrapping
        algorithm, choose the rightmost bottom point. Sort the remaining points
        of S by the angle they form with the horizontal line, from the largest angle
        to the smallest. From here on, the points are processed in this angularly
        sorted order. For each point c, a calculation is made to determine whether
        the two endpoints of the last constructed hull edge ab and c form a left
        turn or a right turn. If abc is a right turn, this means that b is not part
        of the hull and so should be removed from consideration (such as points
        a = 3, b = 4, and c = 5 in Figure 2.8). This discarding continues as long
        as the last three points form a right turn. We move to the next point in
        our list once abc is a left turn. This continues until we eventually return
        to the starting point, which completes the hull.

        The scan begins at the point labelled START, which may be taken as the 
rightmost smallest-ordinate point of the given set and hence is certainly a 
hull vertex. We repeatedly examine triples of consecutive points in counterclockwise order to determine whether or not they define a reflex angle (one 
that is >_ it). If internal anglepIP2P3 is reflex, then pip2P3 is said to be a "right 
turn," otherwise it is a "left turn." T

        hat is the time complexity of the Graham scan algorithm? As mentioned in 
        Section 2.3, sorting the points has time complexity O(n log n).
        As we walk through the algorithm, we see that each point is considered
        at most twice, once when added and once if it forms an illegal right
        turn. Since right-turn discarded points are never revisited, the search
        for hull points executes O(n) iterations. So the overall complexity is
        O(n log n), dominated not by the hull search but by the initial sorting
        of the points.

  <!-- Fuentes: Discrete%20and%20computational%20geometry%20by%20Devadoss%20S.,%20ORourke%20J.%20(z-lib.org).pdf -->
  <!-- Computational_Geometry_An_Introduction_by_Franco_P_Preparata,_Michael. -->
  <!-- Computational%20Geometry%20in%20C%20by%20Joseph%20ORourke%20(z-lib.org).pdf -->
        <!-- Contexto, envoltura de regalo.

        One approach is to wrap a string
        around the entire point set, where the string catches and turns at each
        of the hull points. This method is appropriately called the gift-wrapping
        algorithm, first suggested by Donald Chand and Sham Kapur in 1970
        (primarily for hulls in higher dimensions). Figure 2.7 shows this algorithm
        in action.

        Let’s look at the details. Let S be a point set in general position, with
        no three points collinear. Consider the bottommost point; if there are
        ties, choose the rightmost. This point will be the anchor from which we
        wind our string around S. From this point, draw a line segment to all
        other points in S. Choose the next anchor point on our wrapping of S to
        be the point that makes the largest angle with the horizontal line. Now
        that we have started our wrapping, we continue as follows. From the
        new anchor, draw a line segment to all other points in S, and choose
        the next anchor forming the largest angle with the last constructed hull
        edge. This is repeated until the algorithm ends, winding around the entire
        hull. -->

        <div class="interactive" width="810" height="800" window-size="false"
          src="./Interactivos/capitulo_2/graham_scan.html"></div>
      </div>

      <div class="page">
        <h2 id="cap2_algoritmo_jarvis">Algoritmo de Jarvis</h2>
        <h2 id="cap2_algoritmos_divide_venceras">Algoritmos usando divide y vencerás</h2>
        <h2 id="cap2_algoritmos_dinamicos">Algoritmos dinámicos</h2>
        <h2 id="cap2_extensiones_variantes">Extensiones y variantes</h2>
      </div>
      <div class="page">

        <h2 id="cap2_cota_minima">Cota mínima</h2>
        So far, we have described three algorithms for constructing the convex
        hull, each superior to the previous in terms of time complexity,
        both of which run in O(n log n) time. A natural
        question to consider is whether we can do better. 
        It seems at least feasible that 0 (n) might be possible. We show in
        this section that this is in fact not possible: n log n is a "lower bound" on the complexity
        of any algorithm that finds the hull.
        The short answer is “no” (assuming a model of
        computation based on binary comparisons).
        We show in
        this section that this is in fact not possible: n log n is a "lower bound" on the complexity
        of any algorithm that finds the hull.
        
        Researchers in computer science have found it fiendishly difficult to establish no 
        trivial lower bounds for problems. The difficulty is that the lower bound must hold
        for any conceivable algorithm, and it is hard to capture all algorithms in a proof.
        Nevertheless, this has been accomplished for a few key problems, notably sorting:
        Q(n log n) is a lower bound for sorting n elements. 
        https://www.youtube.com/watch?v=eK6Ual_3ezA
        Once a lower bound for one problem has been established, lower bounds for other problems can be proved via "problem
        reduction."
        this is the typical approach to establishing a lower bound
        on all algorithms that solve a particular problem: reduce the problem
        to another whose lower bound had been previously established.

        Suppose problem A is known to have some particular lower bound. One can view
        this as knowing that problem A is "hard" to the degree exhibited by the lower bound.
        So if A has a lower bound of n(n4 ), it is a rather hard problem. Now suppose problem
        A can be reduced to problem B, in the sense that an algorithm for solving problem B
        can be used to solve problem A (with little additional work). A has been reduced to B
        in the sense that if we can solve B quickly, we can solve A quickly. This often leads
        to a lower bound on B, since if we could solve B too quickly, the known lower bound
        on A would be violated.
  
        This is how we will establish a lower bound on constructing the hull: we will show that it
        is possible to reduce the sorting problem to the convex hull problem in linear time. This implies that
        any O(f(n))-time algorithm for the convex hull problem implies an O(n + f(n))-time algorithm for
        sorting. Clearly, f(n) cannot be smaller than Ω(n log n) for otherwise we would obtain an immediate
        contradiction to the lower bound on sorting.

        The reduction works by projecting the points onto a convex curve. In particular, let X = {x1, . . . , xn}
        be the n values that we wish to sort. Suppose we “lift” each of these points onto a parabola y = x^2
        , by mapping x-i to the point p-i = (x_i, x^2_i). 
        Let P denote the resulting set of points (see Fig. 18(a)). Note
        that all the points of P lie on its convex hull.

        Next, compute the convex hull of P by whatever algorithm we like in O(f(n)) time, which we assume
        to be given as a counter-clockwise cyclic enumeration of its vertices (see Fig. 18(b)). In O(n) time
        we can find the leftmost vertex of this cyclic order, and then read out the rest of the points in O(n)
        time (see Fig. 18(c)). Whenever we encounter some point pi
        in this order, we output its x-coordinate.
        Clearly, the points appear on the hull in left-to-right order, and therefore the final output is the sorted
        order of X, as desired. Except for the f(n) time to compute the convex hull, all the other steps can
        be performed in O(n) time. Thus, any super-linear lower bound on the sorting problem must apply to
        the function f(n) as well.

        This reduction leaves open two questions:
          • What if we don’t require that the points be enumerated in cyclic order, just that they all be
          identified? It remained an open problem for several years to determine if finding extreme
          points was easier, but the work of several researchers finally established that O (n logn)
          is a lower bound on this problem also. Solo nos quedaremos con esto,
          no se ahondará más en la demostración, pero recomendamos a los lectores más
          aventurados a saber más de esto a mirar See Preparata & Shamos (1985, pp. 101-3).
          
          • What if the all the points of P do not lie on the convex hull? The above reduction only suggests
          that the vertices of the hull need to sorted. This suggests that we might do better, if we know
          that the output size is significantly smaller than n. An algorithm whose running time is expressed
          as a function of both its input size and output size is called output sensitive. In this lecture we
          will discuss two output sensitive convex hull algorithms.


        ¿Es este el mejor lugar para poner esta parte del temario?
        
      </div>

      <!--  -->
      <!-- CAPITULO 3: INTERSECCIÓN DE SEGMENTOS -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="intersecciones_segmentos">Intersecciones entre segmentos de rectas</h1>
        <h2 id="cap3_deteccion">Detección</h2>
        <h2 id="cap3_algoritmos">Algoritmos</h2>
        <h2 id="cap3_lista_doblemente_ligada">Lista doblemente conexa de aristas</h2>
        <h2 id="cap3_calculando_traslape">Calculando el traslape de dos subdivisiones</h2>
        <h2 id="cap3_barrido_topologico">Barrido topológico</h2>
        <h2 id="cap3_ordenando_pendientes">Ordenando pendientes en O(n^2)</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 4: TRIANGULACIÓN Y VISIBILIDAD -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" style="font-size: 200%;" id="triangulacion_divisibilidad">Triangulación de polígonos y
          visibilidad</h1>

        <h2 id="cap4_vigilancia_triangulaciones">Vigilancia y triangulaciones</h2>
        <h2 id="cap4_dividiendo_polígono">Dividiendo un polígono en piezas monótonas</h2>
        <h2 id="cap4_triangulando_polígono">Triangulando un polígono monótono</h2>
        <h2 id="cap4_calcular_grafica_divisibilidad">Calcular la gráfica de visibilidad</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 5: PROGRAMACIÓN LINEAL -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="programacion_lineal">Programación lineal</h1>

        <h2 id="cap5_geometria_amoldado">La geometría de amoldado</h2>
        <h2 id="cap5_interseccion_semiplanos">Intersección de semiplanos</h2>
        <h2 id="cap5_circulo_contenedor">Círculo contenedor de radio mínimo</h2>
        <h2 id="cap5_programacion_lineal_incremental">Programación lineal incremental</h2>
        <h2 id="cap5_programacion_lineal_aleatoria">Programación lineal aleatoria</h2>
        <h2 id="cap5_programacion_lineal_dimensiones">Programación lineal en dimensiones superiores</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 6: BÚSQUEDA DE RANGOS -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="busqueda_rangos">Búsqueda de rangos ortogonales</h1>

        <h2 id="cap6_busqueda_una_dimension">Búsqueda en una dimensión</h2>
        <h2 id="cap6_arboles_kd">Árboles Kd</h2>
        <h2 id="cap6_arboles_rangos">Árboles de rangos</h2>
      </div>

      <!--  -->
      <!-- CAPITULO 7: LOCALIZACIÓN DE PUNTOS -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="localizacion_puntos">Localización de puntos</h1>

        <h2 id="cap7_localizacion_punto_subdivision">Localización de un punto en una subdivisión plana</h2>
        <h2 id="cap7_metodo_bandas">Método de bandas</h2>
        <h2 id="cap7_metodo_cadena">Método de cadena</h2>
        <h2 id="cap7_metodo_trapezoidal">Método trapezoidal</h2>
        <h2 id="cap7_algoritmo_incremental">Algoritmo incremental aleatorio</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 8: DIAGRAMAS DE VORONOI -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="diagramas_voronoi">Diagramas de Voronoi</h1>

        <h2 id="cap8_definicion_propiedades">Definición y propiedades básicas</h2>
        <h2 id="cap8_construyendo_diagrama">Construyendo el diagrama de Voronoi</h2>
        <h2 id="cap8_cota_minima">Cota mínima</h2>
        <h2 id="cap8_diagramas_voronoi">Diagramas de Voronoi de orden superior</h2>
        <h2 id="cap8_aplicaciones">Aplicaciones</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 9: ARREGLOS DE LINEAS Y DUALIDAD -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="arreglos_lineas_dualidad">Arreglos de líneas y dualidad</h1>

        <h2 id="cap9_arreglos">Arreglos de líneas</h2>
        <h2 id="cap9_dualidad">Dualidad</h2>
        <h2 id="cap9_triangulacion_delaunay">Triangulación de Delaunay</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 10: PROXIMIDAD -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="proximidad">Proximidad</h1>

        <h2 id="cap10_puntos_cercanos_lejanos">Par de puntos más cercanos y más lejanos</h2>
        <h2 id="cap10_arboles_generadores_minimos">Árboles generadores mínimos euclidianos</h2>
        <h2 id="cap10_agente_viagero">El problema del agente viajero euclidiano</h2>

      </div>

      <!--  -->
      <!-- CAPITULO 11: ESTRUCTURAS DE DATOS GEOMÉTRICAS -->
      <!--  -->
      <div class="page">
        <h1 class="chap_name" id="estructuras_datos_geometricas">Algunas estructuras de datos geométricas</h1>

        <h2 id="cap11_arboles_intervalos">Árboles de intervalos</h2>
        <h2 id="cap11_arboles_prioridades_busqueda">Árboles de prioridades y búsqueda</h2>
        <h2 id="cap11_arboles_segmentos">Árboles de segmentos</h2>

      </div>

      <!--  -->
      <!-- Una página en blanco y sin numeración visible -->
      <!--  -->
      <div class="page" num=""></div>


      <!--  -->
      <div class="page">
        <iframe src="https://developer.spotify.com/documentation/widgets/guides/adding-a-spotify-play-button/"
          frameborder="0" allowtransparency="true" allow="encrypted-media" style="width:100%;height:400px"></iframe>
      </div>

      <!--  -->
      <div class="page">

      </div>

      <!--  -->
      <div class="page invertcolor" num=""
        style="background-image: radial-gradient(white, #ecf0f1, #e3e5e7); display:flex; align-items:center; justify-content:center;">
        <a style="width:50%" target="_blank" href="http://descartes.matem.unam.mx/"><img
            src="images/general/logo_descartes.svg" width="100%"></a>
      </div>
    </div>

    <!-- [cierra] pages_container -->
  </div>
  <!-- [cierra] book_container -->
  </div>

</body>

</html>